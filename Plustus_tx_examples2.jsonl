{"text": "<s>[INST] What does the following Haskell Plutus smart contract code implement, and how does it work? [/INST]This Haskell Plutus smart contract implements an n-out-of-m multisig (multi-signature) scheme that allows multiple participants (m signatories) to propose and authorize payments, where at least n participants' signatures are required to release the funds. The contract manages state transitions through a state machine, tracking when a payment proposal is made, when signatures are added, and when payments are executed. The contract uses off-chain and on-chain code to achieve this.","detailed_explanation": {"language_extensions": ["{-# LANGUAGE DeriveGeneric #-}","{-# LANGUAGE MultiParamTypeClasses #-}"],"imports": ["Control.Lens (makeClassyPrisms)","qualified Ledger.Interval as Interval","GHC.Generics (Generic)","Ledger.Validation (PendingTx, PendingTx'(..))","qualified Ledger.Validation as Validation","qualified Ledger.Typed.Scripts as Scripts","Ledger.Value (Value)","qualified Ledger.Value as Value","Ledger (PubKey, Slot)","Playground.Contract (printSchemas, ensureIotsDefinitions, ensureKnownCurrencies, KnownCurrency, mkSchemaDefinitions, ToSchema)","qualified Language.PlutusTx as PlutusTx","Language.Plutus.Contract","Language.Plutus.Contract.StateMachine (ValueAllocation(..), AsSMContractError, StateMachine(..))","qualified Language.Plutus.Contract.StateMachine as SM","qualified Language.Plutus.Contract.Tx as Tx","Language.PlutusTx.Prelude hiding (check, Applicative (..), (<>))","qualified Prelude as Haskell"],"concepts_implemented": [{"concept": "Payment Structure","description": "Defines a `Payment` structure that holds the amount to be paid, the recipient's public key, and the deadline by which signatures must be collected."},{"concept": "State Transitions","description": "The smart contract transitions between states (such as Holding and CollectingSignatures) depending on whether a payment has been proposed or signatures are being collected."},{"concept": "Multisig Scheme","description": "The contract checks whether a minimum number of required signatures have been collected, and only allows the transaction to proceed if the required signatories agree."},{"concept": "State Machine Logic","description": "The contract operates as a state machine where actions like proposing payments, adding signatures, canceling payments, and making payments all trigger state transitions."},{"concept": "Input and Output Validation","description": "The contract ensures that the funds are preserved correctly and paid to the right addresses by verifying signatures and checking the validity of payment proposals."},{"concept": "Error Handling","description": "Defines custom error types (`MultiSigError`) and uses lenses (`makeClassyPrisms`) for extensibility and error handling."}],"data_types": [{"type": "Payment","fields": {"paymentAmount": "Value","paymentRecipient": "PubKey","paymentDeadline": "Slot"},"description": "Represents a payment proposal including amount, recipient, and deadline."},{"type": "Params","fields": {"mspSignatories": "[PubKey]","mspRequiredSigs": "Integer"},"description": "Represents the parameters of the multisig contract, including the list of signatories and the required number of signatures."},{"type": "State","variants": ["Holding Value","CollectingSignatures Value Payment [PubKey]"],"description": "The state of the contract, either holding funds or collecting signatures for a proposed payment."},{"type": "Input","variants": ["ProposePayment Payment","AddSignature PubKey","Cancel","Pay"],"description": "Represents the inputs to the state machine, including proposing payments, adding signatures, canceling, and paying."}],"core_functions": [{"function": "isSignatory","description": "Checks if a given public key is one of the authorized signatories."},{"function": "isValidProposal","description": "Validates whether a proposed payment can be made with the current locked funds."},{"function": "proposalExpired","description": "Checks if the deadline for a proposed payment has passed."},{"function": "step","description": "Defines the state transitions based on inputs like proposing a payment, adding a signature, or making the payment."},{"function": "check","description": "Ensures that inputs and transactions are valid by checking conditions such as whether enough signatures are collected and whether the funds are preserved."}],"smart_contract_flow": {"initial_state": "Holding funds","transitions": ["ProposePayment: Transitions to CollectingSignatures with the proposed payment and an empty signature list.","AddSignature: Adds the signer's public key to the list of collected signatures.","Cancel: Cancels the current proposal if the deadline is passed, returning to the Holding state.","Pay: Moves to the Holding state after transferring the value to the recipient."]},"onchain_validation": {"mkValidator": "This function checks whether the transaction complies with the contract's logic (valid signatures, valid proposals, etc.)","validatorCode": "Compiles the validation logic into Plutus Core, the low-level language of the Plutus platform."},"schema_definitions": [{"name": "MultiSigSchema","endpoints": ["propose-payment","add-signature","cancel-payment","pay","lock"],"description": "The schema defines the endpoints for proposing a payment, adding a signature, canceling, making a payment, and locking funds."}],"full_code": "```haskell\n{-# LANGUAGE DeriveGeneric #-}{-# LANGUAGE MultiParamTypeClasses #-}import Control.Lens (makeClassyPrisms)import qualified Ledger.Interval as Intervalimport GHC.Generics (Generic)import Ledger.Validation (PendingTx, PendingTx'(..))import qualified Ledger.Validation as Validationimport qualified Ledger.Typed.Scripts as Scriptsimport Ledger.Value (Value)import qualified Ledger.Value as Valueimport Ledger (PubKey, Slot)import Playground.Contract (printSchemas, ensureIotsDefinitions, ensureKnownCurrencies, KnownCurrency, mkSchemaDefinitions, ToSchema)import qualified Language.PlutusTx as PlutusTximport Language.Plutus.Contractimport Language.Plutus.Contract.StateMachine (ValueAllocation(..), AsSMContractError, StateMachine(..))import qualified Language.Plutus.Contract.StateMachine as SMimport qualified Language.Plutus.Contract.Tx as Tximport Language.PlutusTx.Prelude hiding (check, Applicative (..), (<>))import qualified Prelude as Haskell --   $multisig --   The n-out-of-m multisig contract works like a joint account of --   m people, requiring the consent of n people for any payments. --   In the smart contract the signatories are represented by public keys, --   and approval takes the form of signatures on transactions. -- --   The multisig contract in --   'Language.PlutusTx.Coordination.Contracts.MultiSig' expects n signatures on --   a single transaction. This requires an off-chain communication channel. The --   multisig contract implemented in this module uses a proposal system that --   allows participants to propose payments and attach their signatures to --   proposals over a period of time, using separate transactions. All contract --   state is kept on the chain so there is no need for off-chain communication. -- | A proposal for making a payment under the multisig scheme. data Payment = Payment { paymentAmount :: Value , paymentRecipient :: PubKey , paymentDeadline :: Slot } deriving stock (Show, Generic) deriving anyclass (ToSchema)instance Eq Payment where {-# INLINABLE (==) #-}(Payment vl pk sl) == (Payment vl' pk' sl') = vl == vl' && pk == pk' && sl == sl' data Params = Params { mspSignatories :: [PubKey] , mspRequiredSigs :: Integer } -- | State of the multisig contract. data State = Holding Value | CollectingSignatures Value Payment [PubKey] deriving (Show)instance Eq State where {-# INLINABLE (==) #-}(Holding v) == (Holding v') = v == v'(CollectingSignatures vl pmt pks) == (CollectingSignatures vl' pmt' pks') = vl == vl' && pmt == pmt' && pks == pks' _ == _ = False data Input = ProposePayment Payment | AddSignature PubKey | Cancel | Pay deriving Show data MultiSigError = MSContractError ContractError | MSStateMachineError (SM.SMContractError State Input) deriving Show makeClassyPrisms ''MultiSigErrorinstance AsContractError MultiSigError where _ContractError = _MSContractErrorinstance AsSMContractError MultiSigError State Input where _SMContractError = _MSStateMachineError type MultiSigSchema = BlockchainActions .\/ Endpoint "propose-payment" Payment .\/ Endpoint "add-signature" () .\/ Endpoint "cancel-payment" () .\/ Endpoint "pay" () .\/ Endpoint "lock" Value{-# INLINABLE isSignatory #-}isSignatory :: PubKey -> Params -> BoolisSignatory pk (Params sigs _) = any (\pk' -> pk == pk') sigs{-# INLINABLE containsPk #-}containsPk :: PubKey -> [PubKey] -> BoolcontainsPk pk = any (\pk' -> pk' == pk'){-# INLINABLE isValidProposal #-}isValidProposal :: Value -> Payment -> BoolisValidProposal vl (Payment amt _ _) = amt `Value.leq` vl{-# INLINABLE proposalExpired #-}proposalExpired :: PendingTx -> Payment -> BoolproposalExpired PendingTx{pendingTxValidRange} Payment{paymentDeadline} = paymentDeadline `Interval.before` pendingTxValidRange{-# INLINABLE proposalAccepted #-}proposalAccepted :: Params -> [PubKey] -> BoolproposalAccepted (Params signatories numReq) pks = let numSigned = length (filter (\pk -> containsPk pk signatories) pks) in numSigned >= numReq{-# INLINABLE check #-}check :: Params -> Payment -> State -> [Input] -> Boolcheck params payment state inputs = case (state, inputs) of (Holding _, [ProposePayment pmt]) -> isValidProposal (valueLocked state) pmt && proposalExpired (PendingTx{..}) pmt (CollectingSignatures vl pmt pks, [AddSignature pk]) -> isSignatory pk params && not (containsPk pk pks) (CollectingSignatures vl pmt pks, [Cancel]) -> proposalExpired (PendingTx{..}) pmt (CollectingSignatures vl pmt pks, [Pay]) -> proposalAccepted params pks (CollectingSignatures vl pmt pks, [Cancel]) -> proposalExpired (PendingTx{..}) pmt _ -> False{-# INLINABLE step #-}step :: Params -> State -> Input -> Maybe Statestep params state input = case (state, input) of (Holding vl, ProposePayment pmt) -> Just (CollectingSignatures vl pmt []) (CollectingSignatures vl pmt pks, AddSignature pk) -> Just (CollectingSignatures vl pmt (pk : pks)) (CollectingSignatures vl pmt pks, Cancel) -> if proposalExpired (PendingTx{..}) pmt then Just (Holding vl) else Nothing (CollectingSignatures vl pmt pks, Pay) -> if proposalAccepted params pks then Just (Holding (valueLocked state - paymentAmount pmt)) else Nothing _ -> Nothing{-# INLINABLE mkValidator #-}mkValidator :: Params -> State -> Input -> Validation (MultiSigError) ()mkValidator params state input = let check' = check params payment state inputs step' = step params state input in if check' then Validation.valid else Validation.invalid (MSStateMachineError step'){-# INLINABLE mkSchemaDefinitions #-}mkSchemaDefinitions :: [TypeRep]mkSchemaDefinitions = [typeRep (Proxy :: Proxy MultiSigSchema)]{-# INLINABLE validatorCode #-}validatorCode :: Scripts.TypedValidator MultiSigValidator.validatorCode = Scripts.mkTypedValidator @MultiSigValidator $$(PlutusTx.compile [|| mkValidator ||]) $$(PlutusTx.compile [|| wrap ||]){-# INLINABLE wrap #-}wrap :: Scripts.ValidatorTypes MultiSigValidator.wrap = Scripts.wrapValidator @Params @State @Input{-# INLINABLE endPoints #-}endPoints :: Contract () MultiSigSchema Text ()endPoints = Contract.selectList [proposePayment, addSignature, cancelPayment, pay, lock] >>= \case (Left err) -> Contract.throwError err (Right _) -> Contract.logInfo @Text "No endpoint selected" .@endpoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endpoints"}}}
{"text": "<s>[INST] What is the purpose of the `collect-gift.sh` script, and how does it handle the process of submitting a Cardano transaction on a testnet? [/INST] The `collect-gift.sh` script is designed to automate the process of submitting a Cardano transaction on a testnet. It handles querying protocol parameters, building a transaction, signing it, and submitting it to the network. After submission, it retrieves and prints the transaction ID and provides a link to view the transaction on CardanoScan. The script first queries the protocol parameters and saves them to `protocol-parameters.json`. It then builds the transaction by specifying the input, script file, datum, redeemer, collateral, change address, and protocol parameters, saving the transaction body to `collect-gift.txbody`. Next, it signs the transaction using the signing key and saves it to `collect-gift.tx`. Finally, it submits the transaction to the testnet and prints the transaction ID along with a CardanoScan link for viewing the transaction status. #!/bin/bash assets=/workspaces/plutus-pioneer-program/code/Week02/assets keypath=/workspaces/plutus-pioneer-program/keys name=\"$1\" collateral=\"$2\" txin=\"$3\" pp=\"$assets/protocol-parameters.json\" body=\"$assets/collect-gift.txbody\" tx=\"$assets/collect-gift.tx\" # Query the protocol parameters \\ cardano-cli query protocol-parameters \\ --testnet-magic 2 \\ --out-file \"$pp\" # Build the transaction cardano-cli transaction build \\ --babbage-era \\ --testnet-magic 2 \\ --tx-in \"$txin\" \\ --tx-in-script-file \"$assets/gift.plutus\" \\ --tx-in-inline-datum-present \\ --tx-in-redeemer-file \"$assets/unit.json\" \\ --tx-in-collateral \"$collateral\" \\ --change-address \"$(cat \"$keypath/$name.addr\")\" \\ --protocol-params-file \"$pp\" \\ --out-file \"$body\" # Sign the transaction cardano-cli transaction sign \\ --tx-body-file \"$body\" \\ --signing-key-file \"$keypath/$name.skey\" \\ --testnet-magic 2 \\ --out-file \"$tx\" # Submit the transaction cardano-cli transaction submit \\ --testnet-magic 2 \\ --tx-file \"$tx\" tid=$(cardano-cli transaction txid --tx-file \"$tx\") echo \"transaction id: $tid\" echo \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\" </s>"}
{"text": "<s>[INST] What does the `make-gift.sh` script do and how does it manage Cardano transactions on a testnet? [/INST] The `make-gift.sh` script is used to automate the process of building, signing, and submitting a Cardano transaction on a testnet. It starts by building a gift address from a payment script file and saving it to `gift.addr`. Then, it constructs a transaction by specifying inputs, outputs, inline datum, and change address, saving the transaction body to `gift.txbody`. The script signs the transaction with the provided signing key and saves the signed transaction to `gift.tx`. Finally, it submits the transaction to the testnet and prints the transaction ID along with a CardanoScan link to view the transaction status. #!/bin/bash assets=/workspaces/plutus-pioneer-program/code/Week02/assets keypath=/workspaces/plutus-pioneer-program/keys name=\"$1\" txin=\"$2\" body=\"$assets/gift.txbody\" tx=\"$assets/gift.tx\" # Build gift address cardano-cli address build \\ --payment-script-file \"$assets/gift.plutus\" \\ --testnet-magic 2 \\ --out-file \"$assets/gift.addr\" # Build the transaction cardano-cli transaction build \\ --babbage-era \\ --testnet-magic 2 \\ --tx-in \"$txin\" \\ --tx-out \"$(cat \"$assets/gift.addr\") + 3000000 lovelace\" \\ --tx-out-inline-datum-file \"$assets/unit.json\" \\ --change-address \"$(cat \"$keypath/$name.addr\")\" \\ --out-file \"$body\" # Sign the transaction cardano-cli transaction sign \\ --tx-body-file \"$body\" \\ --signing-key-file \"$keypath/$name.skey\" \\ --testnet-magic 2 \\ --out-file \"$tx\" # Submit the transaction cardano-cli transaction submit \\ --testnet-magic 2 \\ --tx-file \"$tx\" tid=$(cardano-cli transaction txid --tx-file \"$tx\") echo \"transaction id: $tid\" echo \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\" </s>"}
{"text": "<s>[INST] What functionality does the `Homework.hs` module provide in the context of Plutus smart contracts? [/INST] The `Homework.hs` module includes Haskell code for testing two Plutus smart contracts (`Homework1` and `Homework2`) using the `Tasty` testing framework. It defines scripts and validators for each homework assignment, sets up users with initial balances, and tests various cases of transactions involving gift transfers. The module performs the following: it builds and submits transactions, checks balances, and verifies that transactions have the desired effects on user balances. It uses different redeemer values to test the behavior of the contracts and reports errors if final balances are not as expected. The code is organized into functions for setting up transactions (`giveTx`, `takeTx`, `giveTx'`, `takeTx'`) and validating results against expected outcomes. {-# LANGUAGE NumericUnderscores #-} module Main where import Control.Monad (replicateM, unless) import Plutus.Model import Plutus.V2.Ledger.Api import Prelude import Test.Tasty import qualified Homework1 as H1 import qualified Homework2 as H2 type Homework1Script = TypedValidator () (Bool, Bool) script1 :: Homework1Script script1 = TypedValidator $ toV2 H1.validator type Homework2Script = TypedValidator () H2.MyRedeemer script2 :: Homework2Script script2 = TypedValidator $ toV2 H2.validator setupUsers :: Run [PubKeyHash] setupUsers = replicateM 3 $ newUser $ ada (Lovelace 1000) main :: IO () main = do defaultMain $ do testGroup \"Homework tests\" [ homework1 defaultBabbage , homework2 defaultBabbage ] homework1 :: MockConfig -> TestTree homework1 cfg = do testGroup \"Testing Homework1\" [ good \"Case: (True, True)\" $ giveGift (True, True) , bad \"Case: (True, False)\" $ giveGift (True, False) , bad \"Case: (False, True)\" $ giveGift (False, True) , bad \"Case: (False, False)\" $ giveGift (False, False) ] where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000) cfg giveGift :: (Bool, Bool) -> Run () giveGift redeemer = do users <- setupUsers let [u1, u2, _u3] = users val = adaValue 100 checkBalance (gives u1 val script1) $ do sp <- spend u1 val submitTx u1 $ giveTx sp val utxos <- utxoAt script1 let [(giftRef, giftOut)] = utxos checkBalance (gives script1 (txOutValue giftOut) u2) $ do submitTx u2 $ takeTx u2 redeemer giftRef (txOutValue giftOut) vals <- mapM valueAt users let [v1, v2, _] = vals unless (v1 == adaValue 900 && v2 == adaValue 1100) $ logError \"Final balances are incorrect\" giveTx :: UserSpend -> Value -> Tx giveTx usp val = mconcat [ userSpend usp , payToScript script1 (HashDatum ()) val ] takeTx :: PubKeyHash -> (Bool, Bool) -> TxOutRef -> Value -> Tx takeTx pkh redeemer giftRef giftVal = mconcat [ spendScript script1 giftRef redeemer () , payToKey pkh giftVal ] homework2 :: MockConfig -> TestTree homework2 cfg = do testGroup \"Testing Homework2\" [ bad \"Case: MyRedeemer True True\" $ giveGift' (H2.MyRedeemer True True) , good \"Case: MyRedeemer True False\" $ giveGift' (H2.MyRedeemer True False) , good \"Case: MyRedeemer False True\" $ giveGift' (H2.MyRedeemer False True) , bad \"Case: MyRedeemer False False\" $ giveGift' (H2.MyRedeemer False False) ] where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000) cfg giveGift' :: H2.MyRedeemer -> Run () giveGift' redeemer = do users <- setupUsers let [u1, u2, _u3] = users val = adaValue 100 checkBalance (gives u1 val script2) $ do sp <- spend u1 val submitTx u1 $ giveTx' sp val utxos <- utxoAt script2 let [(giftRef, giftOut)] = utxos checkBalance (gives script2 (txOutValue giftOut) u2) $ do submitTx u2 $ takeTx' u2 redeemer giftRef (txOutValue giftOut) vals <- mapM valueAt users let [v1, v2, _] = vals unless (v1 == adaValue 900 && v2 == adaValue 1100) $ logError \"Final balances are incorrect\" giveTx' :: UserSpend -> Value -> Tx giveTx' usp val = mconcat [ userSpend usp , payToScript script2 (HashDatum ()) val ] takeTx' :: PubKeyHash -> H2.MyRedeemer -> TxOutRef -> Value -> Tx takeTx' pkh redeemer giftRef giftVal = mconcat [ spendScript script2 giftRef redeemer () , payToKey pkh giftVal ] </s>"}
{"text": "<s>[INST] What is a smart contract that defines a validator which checks if two Booleans in the redeemer are true. If both are true, the smart contract validates successfully and is marked as valid by the ledger? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} {-# LANGUAGE OverloadedStrings   #-} module Homework1 where import qualified Plutus.V2.Ledger.Api as PlutusV2 import           PlutusTx             (compile) import           PlutusTx.Prelude     (Bool (..), BuiltinData, traceIfFalse, ($), (&&)) import           Utilities            (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkValidator #-} -- This should validate if and only if the two Booleans in the redeemer are True! mkValidator :: () -> (Bool, Bool) -> PlutusV2.ScriptContext -> Bool mkValidator _ (a, b) _ = traceIfFalse \"One or more bools are not true\" $ a && b wrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedVal = wrapValidator mkValidator validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||]) </s>"}
{"text": "<s>[INST] What is the basic structure of a Plutus smart contract that checks if two Boolean flags are different and validates the contract if they are? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE DeriveAnyClass      #-} {-# LANGUAGE DeriveGeneric       #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} {-# LANGUAGE OverloadedStrings   #-} module Homework2 where import qualified Plutus.V2.Ledger.Api as PlutusV2 import           PlutusTx             (unstableMakeIsData,compile) import           PlutusTx.Prelude     (Bool, BuiltinData, traceIfFalse, ($), (/=)) import           Utilities            (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MyRedeemer = MyRedeemer { flag1 :: Bool , flag2 :: Bool } PlutusTx.unstableMakeIsData ''MyRedeemer {-# INLINABLE mkValidator #-} -- Create a validator that unlocks the funds if MyRedemeer's flags are different mkValidator :: () -> MyRedeemer -> PlutusV2.ScriptContext -> Bool mkValidator _ myRed _ = traceIfFalse \"flags are not different\" $ flag1 myRed /= flag2 myRed wrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedVal = wrapValidator mkValidator validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||]) </s>"}
{"text": "<s>[INST] What does the Plutus smart contract in the Burn module do, and how does it use traceError and writeValidatorToFile to create a validator that always fails and saves the validator to a file? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module Burn where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import PlutusTx.Prelude (traceError) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator always fails --                    Datum         Redeemer     ScriptContext mkBurnValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkBurnValidator _ _ _ = traceError \"it burns!!!\" {-# INLINABLE mkBurnValidator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkBurnValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/burn.plutus\" validator"}
{"text": "<s>[INST] How can I use Template Haskell and unstableMakeIsData to create a custom data type for my redeemer and a validator that succeeds only when the redeemer is a specific value? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module CustomTypes where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile, unstableMakeIsData) import PlutusTx.Prelude (Bool, Eq ((==)), Integer, traceIfFalse, ($)) import Prelude (IO) import Utilities (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- We can create custom data types for our datum and redeemer like this: newtype MySillyRedeemer = MkMySillyRedeemer Integer PlutusTx.unstableMakeIsData ''MySillyRedeemer -- Use TH to create an instance for IsData. -- This validator succeeds only if the redeemer is `MkMySillyRedeemer 42` --              Datum     Redeemer            ScriptContext mkCTValidator :: () -> MySillyRedeemer -> PlutusV2.ScriptContext -> Bool mkCTValidator _ (MkMySillyRedeemer r) _ = traceIfFalse \"expected 42\" $ r == 42 {-# INLINABLE mkCTValidator #-} wrappedMkVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedMkVal = wrapValidator mkCTValidator {-# INLINABLE wrappedMkVal #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedMkVal ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/customtypes.plutus\" validator"}
{"text": "<s>[INST] How can I make a Plutus validator that checks if the redeemer is exactly 42 and succeeds if it is? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module FortyTwo where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import PlutusTx.Builtins as Builtins (mkI) import PlutusTx.Prelude (otherwise, traceError, (==)) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator succeeds only if the redeemer is 42 --                  Datum         Redeemer     ScriptContext mk42Validator :: BuiltinData -> BuiltinData -> BuiltinData -> () mk42Validator _ r _ | r == Builtins.mkI 42 = () | otherwise            = traceError \"expected 42\" {-# INLINABLE mk42Validator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mk42Validator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/fortytwo.plutus\" validator"}
{"text": "<s>[INST] What does the validator do in the FortyTwo module, and how does it use PlutusTx.Builtins.mkI to check if the redeemer is exactly 42? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module FortyTwoTyped where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (compile) import PlutusTx.Prelude (Bool, Eq ((==)), Integer, traceIfFalse, ($)) import Prelude (IO) import Utilities (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator succeeds only if the redeemer is 42 --              Datum  Redeemer        ScriptContext mk42Validator :: () -> Integer -> PlutusV2.ScriptContext -> Bool mk42Validator _ r _ = traceIfFalse \"expected 42\" $ r == 42 {-# INLINABLE mk42Validator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrapValidator mk42Validator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/fortytwotyped.plutus\" validator"}
{"text": "<s>[INST] How does the Gift module's validator always succeed, and how can it be written to a file with writeValidatorToFile? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} module Gift where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- -------------------------------- ON-CHAIN CODE / VALIDATOR ---------------------------------------- -- This validator always succeeds --                    Datum         Redeemer     ScriptContext mkGiftValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkGiftValidator _ _ _ = () {-# INLINABLE mkGiftValidator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkGiftValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/gift.plutus\" validator"}
{"text": "<s>[INST] How does a validator determine if either beneficiary has signed the transaction at the correct time (before or after a deadline) using time checks on signatures and transaction details? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} {-# LANGUAGE TypeApplications  #-} {-# LANGUAGE TypeFamilies      #-} module Homework1 where import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts (txSignedBy) import Plutus.V1.Ledger.Interval import PlutusTx (compile, unstableMakeIsData) import PlutusTx.Prelude (traceIfFalse, Bool(..), (||), (&&), (+)) import Utilities (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingDatum = VestingDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime } unstableMakeIsData ''VestingDatum {-# INLINABLE mkVestingValidator #-} -- This should validate if either beneficiary1 has signed the transaction and the current slot is before or at the deadline -- or if beneficiary2 has signed the transaction and the deadline has passed. mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool mkVestingValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE  mkWrappedVestingValidator #-} mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedVestingValidator = wrapValidator mkVestingValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||])"}
{"text": "<s>[INST] How does a validator check if a transaction has a signature from a specified beneficiary and if a deadline has passed, using checks on signatures and transaction details? [/INST] {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module Homework2 where import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts import Plutus.V1.Ledger.Interval import PlutusTx (applyCode, compile, liftCode) import PlutusTx.Prelude (Bool(..), (.), traceIfFalse, (&&)) import Utilities (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkParameterizedVestingValidator #-} -- This should validate if the transaction has a signature from the parameterized beneficiary and the deadline has passed. mkParameterizedVestingValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkParameterizedVestingValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkSig :: Bool checkSig = txSignedBy txInfo beneficiary checkDeadline :: Bool checkDeadline = contains (from deadline) txValidRange {-# INLINABLE  mkWrappedParameterizedVestingValidator #-} mkWrappedParameterizedVestingValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator validator :: PubKeyHash -> Validator validator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode beneficiary)"}
{"text": "<s>[INST] How does a validator determine if a specific beneficiary has signed a transaction and if the deadline for that beneficiary has passed, using checks on the transaction and its parameters? [/INST] {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module ParameterizedVesting where import           Plutus.V1.Ledger.Interval (contains) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (applyCode, compile, liftCode, makeLift) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (.) ) import           Prelude                   (IO) import           Utilities                 (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingParams = VestingParams { beneficiary :: PubKeyHash , deadline    :: POSIXTime } makeLift ''VestingParams {-# INLINABLE mkParameterizedVestingValidator #-} mkParameterizedVestingValidator :: VestingParams -> () -> () -> ScriptContext -> Bool mkParameterizedVestingValidator params () () ctx = traceIfFalse \"beneficiary's signature missing\" signedByBeneficiary && traceIfFalse \"deadline not reached\" deadlineReached where info :: TxInfo info = scriptContextTxInfo ctx signedByBeneficiary :: Bool signedByBeneficiary = txSignedBy info $ beneficiary params deadlineReached :: Bool deadlineReached = contains (from $ deadline params) $ txInfoValidRange info {-# INLINABLE  mkWrappedParameterizedVestingValidator #-} mkWrappedParameterizedVestingValidator :: VestingParams -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator validator :: VestingParams -> Validator validator params = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode params) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: VestingParams -> IO () saveVal = writeValidatorToFile \"./assets/parameterized-vesting.plutus\" . validator"}
{"text": "<s>[INST] How does the Vesting Validator check if a specific beneficiary has signed a transaction and if the deadline for that beneficiary has passed, using checks on signatures and transaction details, and how can the validator be written to a file or be displayed in JSON format using the writeValidatorToFile and printDataToJSON functions? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module Vesting where import           Data.Maybe                (fromJust) import           Plutus.V1.Ledger.Interval (contains) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (compile, unstableMakeIsData) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&)) import           Prelude                   (IO, String) import           Utilities                 (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingDatum = VestingDatum { beneficiary :: PubKeyHash , deadline    :: POSIXTime } unstableMakeIsData ''VestingDatum {-# INLINABLE mkVestingValidator #-} mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool mkVestingValidator dat () ctx = traceIfFalse \"beneficiary's signature missing\" signedByBeneficiary && traceIfFalse \"deadline not reached\" deadlineReached where info :: TxInfo info = scriptContextTxInfo ctx signedByBeneficiary :: Bool signedByBeneficiary = txSignedBy info $ beneficiary dat deadlineReached :: Bool deadlineReached = contains (from $ deadline dat) $ txInfoValidRange info {-# INLINABLE  mkWrappedVestingValidator #-} mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedVestingValidator = wrapValidator mkVestingValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/vesting.plutus\" validator vestingAddressBech32 :: Network -> String vestingAddressBech32 network = validatorAddressBech32 network validator printVestingDatumJSON :: PubKeyHash -> String -> IO () printVestingDatumJSON pkh time = printDataToJSON $ VestingDatum { beneficiary = pkh , deadline    = fromJust $ posixTimeFromIso8601 time }"}
{"text": "<s>[INST] How does the Mistery Validator ensure that two signatures are received from different beneficiaries, one of which can be late while the other must be timely, and how can the validator be saved to a file or display the data in JSON format? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} {-# LANGUAGE TypeApplications  #-} {-# LANGUAGE TypeFamilies      #-} module Homework1 where import           Data.Maybe                (fromJust) import           Plutus.V1.Ledger.Interval (contains, to) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, POSIXTimeRange, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (compile, unstableMakeIsData) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (+), (||)) import           Prelude                   (IO, String) import           Utilities                 (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MisteryDatum = MisteryDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime } unstableMakeIsData ''MisteryDatum {-# INLINABLE mkMisteryValidator #-} mkMisteryValidator :: MisteryDatum -> () -> ScriptContext -> Bool mkMisteryValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE  mkWrappedMisteryValidator #-} mkWrappedMisteryValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedMisteryValidator = wrapValidator mkMisteryValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedMisteryValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/mistery1.plutus\" validator misteryAddressBech32 :: Network -> String misteryAddressBech32 network = validatorAddressBech32 network validator printMisteryDatumJSON :: PubKeyHash -> PubKeyHash -> String -> IO () printMisteryDatumJSON pkh1 pkh2 time = printDataToJSON $ MisteryDatum { beneficiary1 = pkh1 , beneficiary2 = pkh2 , deadline    = fromJust $ posixTimeFromIso8601 time }"}
{"text": "<s>[INST] How does the Parameterized Mistery Validator ensure that a specified beneficiary has signed a transaction and that the deadline for that beneficiary has passed, using checks on the transaction and its parameters, and how can the validator be written to a file with different beneficiaries? [/INST] {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module Homework2 where import           Plutus.V1.Ledger.Interval (contains) import           Plutus.V2.Ledger.Api import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (applyCode, compile, liftCode) import           PlutusTx.Prelude          (Bool (..), traceIfFalse, (&&), (.) ) import           Prelude                   (IO) import           Utilities                 (wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkParameterizedMisteryValidator #-} mkParameterizedMisteryValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkParameterizedMisteryValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkSig :: Bool checkSig = txSignedBy txInfo beneficiary checkDeadline :: Bool checkDeadline = contains (from deadline) txValidRange {-# INLINABLE  mkWrappedParameterizedMisteryValidator #-} mkWrappedParameterizedMisteryValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedMisteryValidator = wrapValidator . mkParameterizedMisteryValidator validator :: PubKeyHash -> Validator validator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedMisteryValidator ||]) `applyCode` liftCode beneficiary) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: PubKeyHash -> IO () saveVal = writeValidatorToFile \"./assets/parameterized-Mistery.plutus\" . validator"}
{"text": "<s>[INST] How can I use Lucid and Blockfrost to implement vesting and claim funds on the Cardano blockchain? [/INST] The provided code demonstrates using Lucid and Blockfrost to create and manage a vesting contract on the Cardano blockchain. It involves setting up the necessary tools, defining the vesting logic, and implementing functions to vest and claim funds. The following steps outline the process: [Steps: Initialize Lucid and Blockfrost: Create a Lucid instance with Blockfrost to interact with the Cardano blockchain. Provide the Blockfrost API endpoint and your API key. Load Wallet: Load your wallet using a seed phrase to manage your Cardano assets. Define the Vesting Script: Define the Plutus smart contract script for the vesting logic. This script will handle the vesting and claim logic. Set Vesting Datum: Create a datum that includes the beneficiary's payment credential and the vesting deadline. Vest Funds: Implement the `vestFunds` function to send Lovelace to the vesting contract with the specified datum. Claim Vested Funds: Implement the `claimVestedFunds` function to collect UTxOs from the vesting contract and claim the funds if the vesting deadline has passed. ]","code":"import { Data, Lucid, Blockfrost, getAddressDetails, SpendingValidator, TxHash, Datum, UTxO, Address, AddressDetails } from 'https://deno.land/x/lucid@0.9.1/mod.ts'; import { secretSeed } from './seed.ts'; const lucid = await Lucid.new(new Blockfrost('https://cardano-preprod.blockfrost.io/api/v0', 'insert your own api key here'), 'Preprod'); lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(addr); const vestingScript: SpendingValidator = { type: 'PlutusV2',     script: "590b30590b2d0100003232323322323233223232323232323233223233223232323232323232333222323232322323222323253353232323253355335323235002222222222222533533355301a12001321233001225335002210031001002502c25335333573466e3c0380040ec0e84d40b8004540b4010840ec40e4d401488009400440b04cd5ce2491f62656e65666963696172792773207369676e6174757265206d697373696e670002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b00300735500322222222222200533501433501635029350052200102d335015502802d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce248114646561646c696e65206e6f7420726561636865640002b102b135001220023333573466e1cd55cea80224000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a008603e6ae84d5d1280211931901519ab9c02d02c0283333573466e1cd55ce9baa0054800080ac8c98c80a4cd5ce0160158139999ab9a3370e6aae7540192000233221233001003002375c6ae854018dd69aba135744a00c464c6405066ae700ac0a809840a44c98c809ccd5ce2490350543500029135573ca00226ea80044d55cf280089baa00132001355023221122253350011350032200122133350052200230040023335530071200100500400112223500222350032253335333500800700400215335003100110261025102612223232323253335006215333500621533350082130044984c00d261533350072130044984c00d26100d100b1533350072130044984c00d261533350062130044984c00d26100c1533350052100a100b100915333500521533350072130054984c011261533350062130054984c01126100c100a1533350062130054984c011261533350052130054984c01126100b2533350052153335007215333500721333500b00a002001161616100b153335006215333500621333500a009002001161616100a10092533350042153335006215333500621333500a009002001161616100a1533350052153335005213335009008002001161616100910082533350032153335005215333500521333500900800200116161610091533350042153335004213335008007002001161616100810072533350022153335004215333500421333500800700200116161610081533350032153335003213335007006002001161616100710061235001222222220071222003122200212220011221233001003002122123300100300212212330010030021232230023758002640026aa034446666aae7c004940288cd4024c010d5d080118019aba200201a232323333573466e1cd55cea80124000466442466002006004601c6ae854008c014d5d09aba2500223263201833573803603402c26aae7940044dd50009191919191999ab9a3370e6aae75401120002333322221233330010050040030023232323333573466e1cd55cea80124000466442466002006004602e6ae854008cd403c058d5d09aba2500223263201d33573804003e03626aae7940044dd50009aba150043335500875ca00e6ae85400cc8c8c8cccd5cd19b875001480108c84888c008010d5d09aab9e500323333573466e1d4009200223212223001004375c6ae84d55cf280211999ab9a3370ea00690001091100191931900f99ab9c02202101d01c01b135573aa00226ea8004d5d0a80119a805bae357426ae8940088c98c8064cd5ce00e00d80b89aba25001135744a00226aae7940044dd5000899aa800bae75a224464460046eac004c8004d5405c88c8cccd55cf80112804119a8039991091980080180118031aab9d5002300535573ca00460086ae8800c0604d5d080088910010910911980080200189119191999ab9a3370ea002900011a80398029aba135573ca00646666ae68cdc3a801240044a00e464c6402866ae7005c0580480444d55cea80089baa0011212230020031122001232323333573466e1d400520062321222230040053007357426aae79400c8cccd5cd19b875002480108c848888c008014c024d5d09aab9e500423333573466e1d400d20022321222230010053007357426aae7940148cccd5cd19b875004480008c848888c00c014dd71aba135573ca00c464c6402466ae7005405004003c0380344d55cea80089baa001232323333573466e1cd55cea80124000466442466002006004600a6ae854008dd69aba135744a004464c6401c66ae700440400304d55cf280089baa0012323333573466e1cd55cea800a400046eb8d5d09aab9e500223263200c33573801e01c01426ea80048c8c8c8c8c8cccd5cd19b8750014803084888888800c8cccd5cd19b875002480288488888880108cccd5cd19b875003480208cc8848888888cc004024020dd71aba15005375a6ae84d5d1280291999ab9a3370ea00890031199109111111198010048041bae35742a00e6eb8d5d09aba2500723333573466e1d40152004233221222222233006009008300c35742a0126eb8d5d09aba2500923333573466e1d40192002232122222223007008300d357426aae79402c8cccd5cd19b875007480008c848888888c014020c038d5d09aab9e500c23263201533573803002e02602402202001e01c01a26aae7540104d55cf280189aab9e5002135573ca00226ea80048c8c8c8c8cccd5cd19b875001480088ccc888488ccc00401401000cdd69aba15004375a6ae85400cdd69aba135744a00646666ae68cdc3a80124000464244600400660106ae84d55cf280311931900719ab9c01101000c00b135573aa00626ae8940044d55cf280089baa001232323333573466e1d400520022321223001003375c6ae84d55cf280191999ab9a3370ea004900011909118010019bae357426aae7940108c98c802ccd5ce00700680480409aab9d50011375400224464646666ae68cdc3a800a40084a00c46666ae68cdc3a8012400446a010600c6ae84d55cf280211999ab9a3370ea00690001091100111931900619ab9c00f00e00a009008135573aa00226ea8004484888c00c010448880048c8cccd5cd19b8750014800880188cccd5cd19b8750024800080188c98c8018cd5ce00480400200189aab9d37540029309100109100089000a490350543100112323001001223300330020020011", }; const vestingAddress: Address = lucid.utils.validatorToAddress(vestingScript); const VestingDatum = Data.Object({ beneficiary: Data.String, deadline: Data.BigInt }); type VestingDatum = Data.Static<typeof VestingDatum>; const deadlineDate: Date = new Date('2023-03-19T00:00:00Z'); const deadlinePosIx = BigInt(deadlineDate.getTime()); const details: AddressDetails = getAddressDetails(addr); const beneficiaryPKH: string = details.paymentCredential.hash; const datum: VestingDatum = { beneficiary: beneficiaryPKH, deadline: deadlinePosIx }; async function vestFunds(amount: bigint): Promise<TxHash> { const dtm: Datum = Data.to<VestingDatum>(datum, VestingDatum); const tx = await lucid.newTx().payToContract(vestingAddress, { inline: dtm }, { lovelace: amount }).complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); return txHash; } async function claimVestedFunds(): Promise<TxHash> { const dtm: Datum = Data.to<VestingDatum>(datum, VestingDatum); const utxoAtScript: UTxO[] = await lucid.utxosAt(vestingAddress); const ourUTxO: UTxO[] = utxoAtScript.filter((utxo) => utxo.datum == dtm); if (ourUTxO && ourUTxO.length > 0) { const tx = await lucid.newTx().collectFrom(ourUTxO, Data.void()).addSignerKey(beneficiaryPKH).attachSpendingValidator(vestingScript).validFrom(Date.now()-100000).complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); return txHash; } else return 'No UTxO\'s found that can be claimed'; } //console.log(await vestFunds(100000000n)); //console.log(await claimVestedFunds();"}
{"text": "<s>[INST] How does the Vesting Validator ensure that the specified beneficiary has signed a transaction and that the deadline has been reached, using checks on the transaction and its parameters, and how can the validator be saved to a file or display the datum in JSON format? [/INST] {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell #-} module Vesting where import Data.Maybe (fromJust) import Plutus.V1.Ledger.Interval (contains) import Plutus.V2.Ledger.Api (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import Plutus.V2.Ledger.Contexts (txSignedBy) import PlutusTx (compile, unstableMakeIsData) import PlutusTx.Prelude (Bool, traceIfFalse, ($), (&&)) import Prelude (IO, String) import Utilities (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingDatum = VestingDatum { beneficiary :: PubKeyHash , deadline :: POSIXTime } unstableMakeIsData ''VestingDatum {-# INLINABLE mkVestingValidator #-} mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool mkVestingValidator dat () ctx = traceIfFalse "beneficiary's signature missing" signedByBeneficiary && traceIfFalse "deadline not reached" deadlineReached where info :: TxInfo info = scriptContextTxInfo ctx signedByBeneficiary :: Bool signedByBeneficiary = txSignedBy info $ beneficiary dat deadlineReached :: Bool deadlineReached = contains (from $ deadline dat) $ txInfoValidRange info {-# INLINABLE mkWrappedVestingValidator #-} mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedVestingValidator = wrapValidator mkVestingValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile "./assets/vesting.plutus" validator vestingAddressBech32 :: Network -> String vestingAddressBech32 network = validatorAddressBech32 network validator printVestingDatumJSON :: PubKeyHash -> String -> IO () printVestingDatumJSON pkh time = printDataToJSON $ VestingDatum { beneficiary = pkh , deadline = fromJust $ posixTimeFromIso8601 time } <s>"}
{"text": "<s>[inst] What is the purpose of this validator and how does it work? It looks like the validator checks whether a transaction has been signed by a particular beneficiary within a specified time range (deadline) and whether another beneficiary signed or is too early, using functions to check conditions based on transaction information and parameters. It appears that the validator can be saved to a file, and the MisteryDatum can be displayed in JSON format. What are the possible use cases for such a validator? [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell #-} {-# LANGUAGE TypeApplications #-} {-# LANGUAGE TypeFamilies #-} module Homework1 where import Data.Maybe (fromJust) import Plutus.V1.Ledger.Interval (contains, to) import Plutus.V2.Ledger.Api (BuiltinData, POSIXTime, POSIXTimeRange, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import Plutus.V2.Ledger.Contexts (txSignedBy) import PlutusTx (compile, unstableMakeIsData) import PlutusTx.Prelude (Bool, traceIfFalse, ($), (&&), (+), (||)) import Prelude (IO, String) import Utilities (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MisteryDatum = MisteryDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline :: POSIXTime } unstableMakeIsData ''MisteryDatum {-# INLINABLE mkMisteryValidator #-} mkMisteryValidator :: MisteryDatum -> () -> ScriptContext -> Bool mkMisteryValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE mkWrappedMisteryValidator #-} mkWrappedMisteryValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedMisteryValidator = wrapValidator mkMisteryValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedMisteryValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/mistery1.plutus\" validator misteryAddressBech32 :: Network -> String misteryAddressBech32 network = validatorAddressBech32 network validator printMisteryDatumJSON :: PubKeyHash -> PubKeyHash -> String -> IO () printMisteryDatumJSON pkh1 pkh2 time = printDataToJSON $ MisteryDatum { beneficiary1 = pkh1 , beneficiary2 = pkh2 , deadline = fromJust $ posixTimeFromIso8601 time } <s>"}
{"text": "<s>[inst] What are the benefits of having a parameterized validator, and what are some use cases for this type of validator? [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TemplateHaskell #-} module Homework2 where import Plutus.V1.Ledger.Interval (contains) import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts (txSignedBy) import PlutusTx (applyCode, compile, liftCode) import PlutusTx.Prelude (Bool (..), traceIfFalse, (&&), (.)) import Prelude (IO) import Utilities (wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkParameterizedMisteryValidator #-} mkParameterizedMisteryValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkParameterizedMisteryValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange = txInfoValidRange txInfo checkSig :: Bool checkSig = txSignedBy txInfo beneficiary checkDeadline :: Bool checkDeadline = contains (from deadline) txValidRange {-# INLINABLE mkWrappedParameterizedMisteryValidator #-} mkWrappedParameterizedMisteryValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedMisteryValidator = wrapValidator . mkParameterizedMisteryValidator validator :: PubKeyHash -> Validator validator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedMisteryValidator ||]) `applyCode` liftCode beneficiary) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: PubKeyHash -> IO () saveVal = writeValidatorToFile \"./assets/parameterized-Mistery.plutus\" . validator <s>"}
{"text": "<s>[inst] Write a Plutus smart contract that implements a token burning mechanism. The contract should allow token holders to submit token burning transactions. When the transactions are received, they should be verified to ensure that the sender owns the tokens and that the tokens have not been previously burned. The contract should then update the token ledger and mint a new token with an increased supply. [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TemplateHaskell #-} module Homework1 where import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts import Plutus.V1.Ledger.Interval import qualified PlutusTx import PlutusTx.Prelude (Bool (..), ($), traceIfFalse, (&&)) import Utilities (wrapPolicy, writeCodeToFile, currencySymbol, writePolicyToFile) import Prelude (IO, Show (show)) import Text.Printf (printf) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkDeadlinePolicy #-} -- This policy should only allow minting (or burning) of tokens if the owner of the specified PubKeyHash -- has signed the transaction and if the specified deadline has not passed. mkDeadlinePolicy :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkDeadlinePolicy owner deadline () ctx = traceIfFalse \"not signed by owner\" checkSig && traceIfFalse \"too late: deadline has allready passed\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx checkSig :: Bool checkSig = txSignedBy txInfo owner txValidRange :: POSIXTimeRange txValidRange = txInfoValidRange txInfo checkDeadline :: Bool checkDeadline = contains (to deadline) txValidRange {-# INLINABLE mkWrappedDeadlinePolicy #-} mkWrappedDeadlinePolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedDeadlinePolicy pkh deadline = wrapPolicy $ mkDeadlinePolicy pkh' deadline' where pkh' :: PubKeyHash pkh' = PlutusTx.unsafeFromBuiltinData pkh deadline' :: POSIXTime deadline' = PlutusTx.unsafeFromBuiltinData deadline deadlineCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()) deadlineCode = $$(PlutusTx.compile [|| mkWrappedDeadlinePolicy ||]) deadlinePolicy :: PubKeyHash -> POSIXTime -> MintingPolicy deadlinePolicy pkh deadline = mkMintingPolicyScript $ deadlineCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData pkh) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData deadline) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveDeadlineCode :: IO () saveDeadlineCode = writeCodeToFile \"assets/deadline.plutus\" deadlineCode saveDeadlinePolicy :: PubKeyHash -> POSIXTime -> IO () saveDeadlinePolicy pkh deadline = writePolicyToFile (printf \"assets/deadline-%s.plutus\" $ show pkh) $ deadlinePolicy pkh deadline deadlineCurrencySymbol :: PubKeyHash -> POSIXTime -> CurrencySymbol deadlineCurrencySymbol pkh deadline = currencySymbol $ deadlinePolicy pkh deadline <s>"}
{"text": "<s>[inst] Implement a Plutus smart contract that allows for minting of a collection of NFTs based on a date. The contract should accept a list of UTxO references and a date, and should allow the UTxOs to be minted after the specified date. The minting should be limited to one NFT per UTxO, and each minted NFT should have a unique identifier (e.g., a random number). [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TemplateHaskell #-} module Homework2 where import Plutus.V2.Ledger.Api import Plutus.V1.Ledger.Value (flattenValue) import Plutus.V2.Ledger.Contexts (ownCurrencySymbol) import qualified PlutusTx import PlutusTx.Builtins.Internal (emptyByteString) import PlutusTx.Prelude (Bool (..), ($), (.), (&&), (==), any, traceIfFalse) import Utilities (wrapPolicy, writeCodeToFile) import Prelude (IO) {-# INLINABLE tn #-} tn :: TokenName tn = TokenName emptyByteString {-# INLINABLE mkEmptyNFTPolicy #-} -- Minting policy for an NFT, where the minting transaction must consume the given UTxO as input -- and where the TokenName will be the empty ByteString. mkEmptyNFTPolicy :: TxOutRef -> () -> ScriptContext -> Bool mkEmptyNFTPolicy oref () ctx = traceIfFalse \"UTxO not consumed\" hasUTxO && traceIfFalse \"wrong amount minted\" checkMintedAmount where info :: TxInfo info = scriptContextTxInfo ctx hasUTxO :: Bool hasUTxO = any (\\i -> txInInfoOutRef i == oref) $ txInfoInputs info checkMintedAmount :: Bool checkMintedAmount = case flattenValue (txInfoMint info) of [(cs, tn', amt)] -> cs == ownCurrencySymbol ctx && tn' == tn && amt == 1 _ -> False {-# INLINABLE mkWrappedEmptyNFTPolicy #-} mkWrappedEmptyNFTPolicy :: TxOutRef -> BuiltinData -> BuiltinData -> () mkWrappedEmptyNFTPolicy = wrapPolicy . mkEmptyNFTPolicy nftCode :: PlutusTx.CompiledCode (TxOutRef -> BuiltinData -> BuiltinData -> ()) nftCode = $$(PlutusTx.compile [|| mkWrappedEmptyNFTPolicy ||]) nftPolicy :: TxOutRef -> MintingPolicy nftPolicy oref = mkMintingPolicyScript $ $$(PlutusTx.compile [|| mkWrappedEmptyNFTPolicy ||]) `PlutusTx.applyCode` PlutusTx.liftCode oref --------------------------------------------------------------------------------- --------------------------------- HELPER FUNCTIONS ------------------------------ saveNFTCode :: IO () saveNFTCode = writeCodeToFile \"assets/nftPolicyH2_typed.plutus\" nftCode <s>"}
{"text": "<s>[inst] How do I create a Plutus smart contract that allows for minting assets without restrictions? [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE TemplateHaskell #-} module Free where import Plutus.V2.Ledger.Api (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext, mkMintingPolicyScript) import qualified PlutusTx import PlutusTx.Prelude (Bool (True)) import Prelude (IO) import Utilities (currencySymbol, wrapPolicy, writePolicyToFile) {-# INLINABLE mkFreePolicy #-} mkFreePolicy :: () -> ScriptContext -> Bool mkFreePolicy () _ = True {-# INLINABLE mkWrappedFreePolicy #-} mkWrappedFreePolicy :: BuiltinData -> BuiltinData -> () mkWrappedFreePolicy = wrapPolicy mkFreePolicy freePolicy :: MintingPolicy freePolicy = mkMintingPolicyScript $$(PlutusTx.compile [|| mkWrappedFreePolicy ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveFreePolicy :: IO () saveFreePolicy = writePolicyToFile \"assets/free.plutus\" freePolicy freeCurrencySymbol :: CurrencySymbol freeCurrencySymbol = currencySymbol freePolicy <s>"}
{"text": "<s>[inst] How do I mint a non-fungible token (NFT) using the Plutus code snippet for the NFT minting policy? What are the steps and inputs required to mint a unique and verifiable NFT on the Cardano blockchain? [/inst] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module NFT where import qualified Data.ByteString.Char8      as BS8 import Plutus.V1.Ledger.Value     (flattenValue) import Plutus.V2.Ledger.Api       (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext (scriptContextTxInfo), TokenName (unTokenName), TxId (TxId, getTxId), TxInInfo (txInInfoOutRef), TxInfo (txInfoInputs, txInfoMint), TxOutRef (TxOutRef, txOutRefId, txOutRefIdx), mkMintingPolicyScript) import qualified PlutusTx import PlutusTx.Builtins.Internal (BuiltinByteString (BuiltinByteString)) import PlutusTx.Prelude           (Bool (False), Eq ((==)), any, traceIfFalse, ($), (&&)) import Prelude                    (IO, Show (show), String) import Text.Printf                (printf) import Utilities                  (bytesToHex, currencySymbol, wrapPolicy, writeCodeToFile, writePolicyToFile) {-# INLINABLE mkNFTPolicy #-} mkNFTPolicy :: TxOutRef -> TokenName -> () -> ScriptContext -> Bool mkNFTPolicy oref tn () ctx = traceIfFalse \"UTxO not consumed\" hasUTxO && traceIfFalse \"wrong amount minted\" checkMintedAmount where info :: TxInfo info = scriptContextTxInfo ctx hasUTxO :: Bool hasUTxO = any (\\i -> txInInfoOutRef i == oref) $ txInfoInputs info checkMintedAmount :: Bool checkMintedAmount = case flattenValue (txInfoMint info) of [(_, tn'', amt)] -> tn'' == tn && amt == 1 _ -> False {-# INLINABLE mkWrappedNFTPolicy #-} mkWrappedNFTPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedNFTPolicy tid ix tn' = wrapPolicy $ mkNFTPolicy oref tn where oref :: TxOutRef oref = TxOutRef (TxId $ PlutusTx.unsafeFromBuiltinData tid) (PlutusTx.unsafeFromBuiltinData ix) tn :: TokenName tn = PlutusTx.unsafeFromBuiltinData tn' nftCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()) nftCode = $$(PlutusTx.compile [|| mkWrappedNFTPolicy ||]) nftPolicy :: TxOutRef -> TokenName -> MintingPolicy nftPolicy oref tn = mkMintingPolicyScript $ nftCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ getTxId $ txOutRefId oref) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ txOutRefIdx oref) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData tn) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveNFTCode :: IO () saveNFTCode = writeCodeToFile \"assets/nft.plutus\" nftCode saveNFTPolicy :: TxOutRef -> TokenName -> IO () saveNFTPolicy oref tn = writePolicyToFile (printf \"assets/nft-%s#%d-%s.plutus\" (show $ txOutRefId oref) (txOutRefIdx oref) $ tn') $ nftPolicy oref tn where tn' :: String tn' = case unTokenName tn of (BuiltinByteString bs) -> BS8.unpack $ bytesToHex bs nftCurrencySymbol :: TxOutRef -> TokenName -> CurrencySymbol nftCurrencySymbol oref tn = currencySymbol $ nftPolicy oref tn <s>"}
{"text": "<s>[inst] How do I create a Plutus smart contract that allows minting of assets only if a specific PubKeyHash signs the transaction? What are the steps to set up the smart contract and what will be the behavior when a user attempts to mint an asset without the correct signature? [/inst] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module Signed where import           Plutus.V2.Ledger.Api      (BuiltinData, CurrencySymbol, MintingPolicy, PubKeyHash, ScriptContext (scriptContextTxInfo), mkMintingPolicyScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import qualified PlutusTx import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (.)) import           Prelude                   (IO, Show (show)) import           Text.Printf               (printf) import           Utilities                 (currencySymbol, wrapPolicy, writeCodeToFile, writePolicyToFile) {-# INLINABLE mkSignedPolicy #-} mkSignedPolicy :: PubKeyHash -> () -> ScriptContext -> Bool mkSignedPolicy pkh () ctx = traceIfFalse \"missing signature\" $ txSignedBy (scriptContextTxInfo ctx) pkh {-# INLINABLE mkWrappedSignedPolicy #-} mkWrappedSignedPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedSignedPolicy pkh = wrapPolicy (mkSignedPolicy $ PlutusTx.unsafeFromBuiltinData pkh) signedCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ()) signedCode = $$(PlutusTx.compile [|| mkWrappedSignedPolicy ||]) signedPolicy :: PubKeyHash -> MintingPolicy signedPolicy pkh = mkMintingPolicyScript $ signedCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData pkh) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveSignedCode :: IO () saveSignedCode = writeCodeToFile \"assets/signed.plutus\" signedCode saveSignedPolicy :: PubKeyHash -> IO () saveSignedPolicy pkh = writePolicyToFile (printf \"assets/signed-%s.plutus\" $ show pkh) $ signedPolicy pkh signedCurrencySymbol :: PubKeyHash -> CurrencySymbol signedCurrencySymbol = currencySymbol . signedPolicy <s>"}
{"text": "<s>[inst] How do I use Lucid and Blockfrost to mint assets on the Cardano blockchain using a free minting policy? What is the process to connect to the Cardano preprod network, select a local wallet, generate the minting policy ID, and mint the desired amount of assets using the mintAssets and submit functions? [/inst] import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data } from \"https://deno.land/x/lucid@0.9.1/mod.ts\" import { blockfrostKey, secretSeed } from \"./secret.ts\" function readAmount(): bigint { const input = prompt(\"amount: \"); return input ? BigInt(Number.parseInt(input)) : 1000000n; } const freePolicy: MintingPolicy = { type: \"PlutusV2\", script: \"5830582e010000323222320053333573466e1cd55ce9baa0024800080148c98c8014cd5ce249035054310000500349848005\" }; // set blockfrost endpoint const lucid = await Lucid.new( new Blockfrost( \"https://cardano-preprod.blockfrost.io/api/v0\", blockfrostKey ), \"Preprod\" ); // load local stored seed as a wallet into lucid lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(\"own address: \" + addr); const policyId: PolicyId = lucid.utils.mintingPolicyToId(freePolicy); console.log(\"minting policy: \" + policyId); const unit: Unit = policyId + fromText(\"PPP Free\"); const amount: bigint = readAmount(); const tx = await lucid .newTx() .mintAssets({[unit]: amount}, Data.void()) .attachMintingPolicy(freePolicy) .complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log(\"tid: \" + txHash); <s>"}
{"text": "<s>[inst] How do I use Lucid, Blockfrost, and a collected UTXO to mint a non-fungible token (NFT) on the Cardano blockchain? What are the steps to retrieve the user's wallet and address, select a UTXO, and apply the UTXO's transaction hash, output index, and token name to generate the minting policy script and mint the NFT? [/inst] import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, applyParamsToScript } from \"https://deno.land/x/lucid@0.9.1/mod.ts\" import { blockfrostKey, secretSeed } from \"./secret.ts\" // set blockfrost endpoint const lucid = await Lucid.new( new Blockfrost( \"https://cardano-preprod.blockfrost.io/api/v0\", blockfrostKey ), \"Preprod\" ); // load local stored seed as a wallet into lucid lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(\"own address: \" + addr); const utxos = await lucid.utxosAt(addr); const utxo = utxos[0]; console.log(\"utxo: \" + utxo.txHash + \"#\" + utxo.outputIndex); const tn = fromText(\"PPP NFT\"); const Params = Data.Tuple([Data.String, Data.BigInt, Data.String]); type Params = Data.Static<typeof Params>; const nftPolicy: MintingPolicy = { type: \"PlutusV2\", script: applyParamsToScript<Params>( \        "5909065909030100003233223322323232323232323232323232323232323232323232222223232533532323232325335533533355300d12001323212330012233350052200200200100235001220011233001225335002102610010232325335333573466e3cd400488008d401c880080940904ccd5cd19b87350012200135007220010250241024350012200235500122222222222200c10231335738921115554784f206e6f7420636f6e73756d65640002215335533532330215026001355001222222222222008102222135002222533500415335333573466e3c0080240a009c4ccd5cd19b87001480080a009c409c8840a4408c4cd5ce24811377726f6e6720616d6f756e74206d696e746564000221022135001220023333573466e1cd55cea802a4000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd406c070d5d0a80619a80d80e1aba1500b33501b01d35742a014666aa03eeb94078d5d0a804999aa80fbae501e35742a01066a03604a6ae85401cccd5407c099d69aba150063232323333573466e1cd55cea801240004664424660020060046464646666ae68cdc39aab9d5002480008cc8848cc00400c008cd40c1d69aba150023031357426ae8940088c98c80cccd5ce01a01981889aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa004900011991091980080180119a8183ad35742a00460626ae84d5d1280111931901999ab9c034033031135573ca00226ea8004d5d09aba2500223263202f33573806005e05a26aae7940044dd50009aba1500533501b75c6ae854010ccd5407c0848004d5d0a801999aa80fbae200135742a00460486ae84d5d1280111931901599ab9c02c02b029135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00a60266ae84d5d1280291931900e99ab9c01e01d01b3333573466e1cd55ce9baa0064800080708c98c8070cd5ce00e80e00d1bae00633011375c00e6eb401840644c98c8064cd5ce2490350543500019135573ca00226ea8004c8004d5406488448894cd40044d400c88004884ccd401488008c010008ccd54c01c4800401401000448c88c008dd6000990009aa80c911999aab9f0012501b233501a30043574200460066ae8800804c8c8c8cccd5cd19b8735573aa004900011991091980080180118051aba150023005357426ae8940088c98c804ccd5ce00a00980889aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180a1aba1500233500d013357426ae8940088c98c8060cd5ce00c80c00b09aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403466ae7006c06806005c0584d55cea80089baa00135742a00466a012eb8d5d09aba2500223263201433573802a02802426ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355016223233335573e0044a032466a03066442466002006004600c6aae754008c014d55cf280118021aba200301113574200224464646666ae68cdc3a800a40004642446004006600a6ae84d55cf280191999ab9a3370ea0049001109100091931900899ab9c01201100f00e135573aa00226ea80048c8c8cccd5cd19b875001480188c848888c010014c020d5d09aab9e500323333573466e1d40092004232122223002005300a357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900899ab9c01201100f00e00d00c135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011980298031aba15002375a6ae84d5d1280111931900699ab9c00e00d00b135573ca00226ea80048848cc00400c0088c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8028cd5ce00580500409baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c804ccd5ce00a00980880800780700680600589aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401866ae700340300280244d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200933573801401200e00c26aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea00490011190911180180218031aba135573ca00846666ae68cdc3a801a400042444004464c6401466ae7002c02802001c0184d55cea80089baa0012323333573466e1d40052002200a23333573466e1d40092000200a23263200633573800e00c00800626aae74dd5000a4c24002921035054310032001355006222533500110022213500222330073330080020060010033200135500522225335001100222135002225335333573466e1c005200000a0091333008007006003133300800733500b12333001008003002006003122002122001112200212212233001004003112323001001223300330020020011",\", [utxo.txHash, BigInt(utxo.outputIndex), tn], Params) }; const policyId: PolicyId = lucid.utils.mintingPolicyToId(nftPolicy); console.log(\"minting policy: \" + policyId); const unit: Unit = policyId + tn; const tx = await lucid .newTx() .mintAssets({[unit]: 1n}, Data.void()) .attachMintingPolicy(nftPolicy) .collectFrom([utxo]) .complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log(\"tid: \" + txHash); <s>"}
{"text": "<s>[inst] How do I use Lucid, Blockfrost, and a locally stored seed to mint a signed token on the Cardano blockchain? What steps should I follow to retrieve my public key hash, generate a policy requiring my signature, create a new transaction, mint the asset, add my key as a signer, and sign and submit the transaction? [/inst] import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, getAddressDetails, applyParamsToScript } from \"https://deno.land/x/lucid@0.9.1/mod.ts\" import { blockfrostKey, secretSeed } from \"./secret.ts\" function readAmount(): bigint { const input = prompt(\"amount: \"); return input ? BigInt(Number.parseInt(input)) : 1000000n; } // set blockfrost endpoint const lucid = await Lucid.new( new Blockfrost( \"https://cardano-preprod.blockfrost.io/api/v0\", blockfrostKey ), \"Preprod\" ); // load local stored seed as a wallet into lucid lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(\"own address: \" + addr); const pkh: string = getAddressDetails(addr).paymentCredential?.hash || \"\"; console.log(\"own pubkey hash: \" + pkh); const Params = Data.Tuple([Data.String]); type Params = Data.Static<typeof Params>; const signedPolicy: MintingPolicy = { type: \"PlutusV2\", script: applyParamsToScript<Params>( \59081a590817010000323232332232323232323232323233223233223232323232322223232533532323253353235001222222222222533533355301612001321233001225335002210031001002501f25335333573466e3c0440040b00ac4d408400454080010840b040a8d40048800840784cd5ce249116d697373696e67207369676e61747572650001d3333573466e1cd55cea80224000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd4060064d5d0a80619a80c00c9aba1500b33501801a35742a014666aa038eb9406cd5d0a804999aa80e3ae501b35742a01066a03004a6ae85401cccd54070099d69aba150063232323333573466e1cd55cea801240004664424660020060046464646666ae68cdc39aab9d5002480008cc8848cc00400c008cd40c1d69aba150023031357426ae8940088c98c80cccd5ce01b01a81889aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa004900011991091980080180119a8183ad35742a00460626ae84d5d1280111931901999ab9c036035031135573ca00226ea8004d5d09aba2500223263202f33573806406205a26aae7940044dd50009aba1500533501875c6ae854010ccd540700888004d5d0a801999aa80e3ae200135742a00460486ae84d5d1280111931901599ab9c02e02d029135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00860286ae84d5d1280211931900e99ab9c02001f01b3333573466e1cd55ce9baa0054800080788c98c8070cd5ce00f80f00d1bae005101c13263201a3357389201035054350001c135573ca00226ea8004c8004d5406088448894cd40044d400c88004884ccd401488008c010008ccd54c01c4800401401000448c88c008dd6000990009aa80c111999aab9f0012500a233500930043574200460066ae880080608c8c8cccd5cd19b8735573aa004900011991091980080180118071aba150023005357426ae8940088c98c8058cd5ce00c80c00a09aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180b9aba1500233500f016357426ae8940088c98c806ccd5ce00f00e80c89aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403a66ae7008007c06c0680644d55cea80089baa00135742a00466a016eb8d5d09aba2500223263201733573803403202a26ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355015223233335573e0044a010466a00e66442466002006004600c6aae754008c014d55cf280118021aba200301613574200222440042442446600200800624464646666ae68cdc3a800a400046a00e600a6ae84d55cf280191999ab9a3370ea00490011280391931900919ab9c01501401000f135573aa00226ea800448488c00800c44880048c8c8cccd5cd19b875001480188c848888c010014c01cd5d09aab9e500323333573466e1d400920042321222230020053009357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900819ab9c01301200e00d00c00b135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011991091980080180118029aba15002375a6ae84d5d1280111931900619ab9c00f00e00a135573ca00226ea80048c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8028cd5ce00680600409baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c804ccd5ce00b00a80880800780700680600589aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401866ae7003c0380280244d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200933573801801600e00c26aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea00490011190911180180218031aba135573ca00846666ae68cdc3a801a400042444004464c6401466ae7003403002001c0184d55cea80089baa0012323333573466e1d40052002200623333573466e1d40092000200623263200633573801201000800626aae74dd5000a4c2440042440022400292010350543100112323001001223300330020020011",\" [pkh], Params) }; const policyId: PolicyId = lucid.utils.mintingPolicyToId(signedPolicy); console.log(\"minting policy: \" + policyId); const unit: Unit = policyId + fromText(\"PPP Signed\"); const amount: bigint = readAmount(); const tx = await lucid .newTx() .mintAssets({[unit]: amount}, Data.void()) .attachMintingPolicy(signedPolicy) .addSignerKey(pkh) .complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log(\"tid: \" + txHash); <s>"}
