{"text": "What does the following Haskell Plutus smart contract code implement, and how does it work? [/INST]This Haskell Plutus smart contract implements an n-out-of-m multisig (multi-signature) scheme that allows multiple participants (m signatories) to propose and authorize payments, where at least n participants' signatures are required to release the funds. The contract manages state transitions through a state machine, tracking when a payment proposal is made, when signatures are added, and when payments are executed. The contract uses off-chain and on-chain code to achieve this."
    "detailed_explanation": {
      "language_extensions": [
        "{-# LANGUAGE DeriveGeneric #-}",
        "{-# LANGUAGE MultiParamTypeClasses #-}"
      ],
      "imports": [
        "Control.Lens (makeClassyPrisms)",
        "qualified Ledger.Interval as Interval",
        "GHC.Generics (Generic)",
        "Ledger.Validation (PendingTx, PendingTx'(..))",
        "qualified Ledger.Validation as Validation",
        "qualified Ledger.Typed.Scripts as Scripts",
        "Ledger.Value (Value)",
        "qualified Ledger.Value as Value",
        "Ledger (PubKey, Slot)",
        "Playground.Contract (printSchemas, ensureIotsDefinitions, ensureKnownCurrencies, KnownCurrency, mkSchemaDefinitions, ToSchema)",
        "qualified Language.PlutusTx as PlutusTx",
        "Language.Plutus.Contract",
        "Language.Plutus.Contract.StateMachine (ValueAllocation(..), AsSMContractError, StateMachine(..))",
        "qualified Language.Plutus.Contract.StateMachine as SM",
        "qualified Language.Plutus.Contract.Tx as Tx",
        "Language.PlutusTx.Prelude hiding (check, Applicative (..), (<>))",
        "qualified Prelude as Haskell"
      ],
      "concepts_implemented": [
        {
          "concept": "Payment Structure",
          "description": "Defines a `Payment` structure that holds the amount to be paid, the recipient's public key, and the deadline by which signatures must be collected."
        },
        {
          "concept": "State Transitions",
          "description": "The smart contract transitions between states (such as Holding and CollectingSignatures) depending on whether a payment has been proposed or signatures are being collected."
        },
        {
          "concept": "Multisig Scheme",
          "description": "The contract checks whether a minimum number of required signatures have been collected, and only allows the transaction to proceed if the required signatories agree."
        },
        {
          "concept": "State Machine Logic",
          "description": "The contract operates as a state machine where actions like proposing payments, adding signatures, canceling payments, and making payments all trigger state transitions."
        },
        {
          "concept": "Input and Output Validation",
          "description": "The contract ensures that the funds are preserved correctly and paid to the right addresses by verifying signatures and checking the validity of payment proposals."
        },
        {
          "concept": "Error Handling",
          "description": "Defines custom error types (`MultiSigError`) and uses lenses (`makeClassyPrisms`) for extensibility and error handling."
        }
      ],
      "data_types": [
        {
          "type": "Payment",
          "fields": {
            "paymentAmount": "Value",
            "paymentRecipient": "PubKey",
            "paymentDeadline": "Slot"
          },
          "description": "Represents a payment proposal including amount, recipient, and deadline."
        },
        {
          "type": "Params",
          "fields": {
            "mspSignatories": "[PubKey]",
            "mspRequiredSigs": "Integer"
          },
          "description": "Represents the parameters of the multisig contract, including the list of signatories and the required number of signatures."
        },
        {
          "type": "State",
          "variants": [
            "Holding Value",
            "CollectingSignatures Value Payment [PubKey]"
          ],
          "description": "The state of the contract, either holding funds or collecting signatures for a proposed payment."
        },
        {
          "type": "Input",
          "variants": [
            "ProposePayment Payment",
            "AddSignature PubKey",
            "Cancel",
            "Pay"
          ],
          "description": "Represents the inputs to the state machine, including proposing payments, adding signatures, canceling, and paying."
        }
      ],
      "core_functions": [
        {
          "function": "isSignatory",
          "description": "Checks if a given public key is one of the authorized signatories."
        },
        {
          "function": "isValidProposal",
          "description": "Validates whether a proposed payment can be made with the current locked funds."
        },
        {
          "function": "proposalExpired",
          "description": "Checks if the deadline for a proposed payment has passed."
        },
        {
          "function": "step",
          "description": "Defines the state transitions based on inputs like proposing a payment, adding a signature, or making the payment."
        },
        {
          "function": "check",
          "description": "Ensures that inputs and transactions are valid by checking conditions such as whether enough signatures are collected and whether the funds are preserved."
        }
      ],
      "smart_contract_flow": {
        "initial_state": "Holding funds",
        "transitions": [
          "ProposePayment: Transitions to CollectingSignatures with the proposed payment and an empty signature list.",
          "AddSignature: Adds the signer's public key to the list of collected signatures.",
          "Cancel: Cancels the current proposal if the deadline is passed, returning to the Holding state.",
          "Pay: Moves to the Holding state after transferring the value to the recipient."
        ]
      },
      "onchain_validation": {
        "mkValidator": "This function checks whether the transaction complies with the contract's logic (valid signatures, valid proposals, etc.)",
        "validatorCode": "Compiles the validation logic into Plutus Core, the low-level language of the Plutus platform."
      },
      "schema_definitions": [
        {
          "name": "MultiSigSchema",
          "endpoints": [
            "propose-payment",
            "add-signature",
            "cancel-payment",
            "pay",
            "lock"
          ],
          "description": "The schema defines the endpoints for proposing a payment, adding a signature, canceling, making a payment, and locking funds."
        }
      ],
      "full_code": "```haskell\n{-# LANGUAGE DeriveGeneric #-}{-# LANGUAGE MultiParamTypeClasses #-}import Control.Lens (makeClassyPrisms)import qualified Ledger.Interval as Intervalimport GHC.Generics (Generic)import Ledger.Validation (PendingTx, PendingTx'(..))import qualified Ledger.Validation as Validationimport qualified Ledger.Typed.Scripts as Scriptsimport Ledger.Value (Value)import qualified Ledger.Value as Valueimport Ledger (PubKey, Slot)import Playground.Contract (printSchemas, ensureIotsDefinitions, ensureKnownCurrencies, KnownCurrency, mkSchemaDefinitions, ToSchema)import qualified Language.PlutusTx as PlutusTximport Language.Plutus.Contractimport Language.Plutus.Contract.StateMachine (ValueAllocation(..), AsSMContractError, StateMachine(..))import qualified Language.Plutus.Contract.StateMachine as SMimport qualified Language.Plutus.Contract.Tx as Tximport Language.PlutusTx.Prelude hiding (check, Applicative (..), (<>))import qualified Prelude as Haskell --   $multisig --   The n-out-of-m multisig contract works like a joint account of --   m people, requiring the consent of n people for any payments. --   In the smart contract the signatories are represented by public keys, --   and approval takes the form of signatures on transactions. -- --   The multisig contract in --   'Language.PlutusTx.Coordination.Contracts.MultiSig' expects n signatures on --   a single transaction. This requires an off-chain communication channel. The --   multisig contract implemented in this module uses a proposal system that --   allows participants to propose payments and attach their signatures to --   proposals over a period of time, using separate transactions. All contract --   state is kept on the chain so there is no need for off-chain communication. -- | A proposal for making a payment under the multisig scheme. data Payment = Payment { paymentAmount :: Value , paymentRecipient :: PubKey , paymentDeadline :: Slot } deriving stock (Show, Generic) deriving anyclass (ToSchema)instance Eq Payment where {-# INLINABLE (==) #-}(Payment vl pk sl) == (Payment vl' pk' sl') = vl == vl' && pk == pk' && sl == sl' data Params = Params { mspSignatories :: [PubKey] , mspRequiredSigs :: Integer } -- | State of the multisig contract. data State = Holding Value | CollectingSignatures Value Payment [PubKey] deriving (Show)instance Eq State where {-# INLINABLE (==) #-}(Holding v) == (Holding v') = v == v'(CollectingSignatures vl pmt pks) == (CollectingSignatures vl' pmt' pks') = vl == vl' && pmt == pmt' && pks == pks' _ == _ = False data Input = ProposePayment Payment | AddSignature PubKey | Cancel | Pay deriving Show data MultiSigError = MSContractError ContractError | MSStateMachineError (SM.SMContractError State Input) deriving Show makeClassyPrisms ''MultiSigErrorinstance AsContractError MultiSigError where _ContractError = _MSContractErrorinstance AsSMContractError MultiSigError State Input where _SMContractError = _MSStateMachineError type MultiSigSchema = BlockchainActions .\/ Endpoint "propose-payment" Payment .\/ Endpoint "add-signature" () .\/ Endpoint "cancel-payment" () .\/ Endpoint "pay" () .\/ Endpoint "lock" Value{-# INLINABLE isSignatory #-}isSignatory :: PubKey -> Params -> BoolisSignatory pk (Params sigs _) = any (\pk' -> pk == pk') sigs{-# INLINABLE containsPk #-}containsPk :: PubKey -> [PubKey] -> BoolcontainsPk pk = any (\pk' -> pk' == pk){-# INLINABLE isValidProposal #-}isValidProposal :: Value -> Payment -> BoolisValidProposal vl (Payment amt _ _) = amt `Value.leq` vl{-# INLINABLE proposalExpired #-}proposalExpired :: PendingTx -> Payment -> BoolproposalExpired PendingTx{pendingTxValidRange} Payment{paymentDeadline} = paymentDeadline `Interval.before` pendingTxValidRange{-# INLINABLE proposalAccepted #-}proposalAccepted :: Params -> [PubKey] -> BoolproposalAccepted (Params signatories numReq) pks = let numSigned = length (filter (\pk -> containsPk pk pks) signatories) in numSigned >= numReq{-# INLINABLE valuePreserved #-}valuePreserved :: Value -> PendingTx -> BoolvaluePreserved vl ptx = vl == Validation.valueLockedBy ptx (Validation.ownHash ptx){-# INLINABLE valuePaid #-}valuePaid :: Payment -> PendingTx -> BoolvaluePaid (Payment vl pk _) ptx = vl == (Validation.valuePaidTo ptx pk){-# INLINABLE step #-}step :: State -> Input -> Maybe Statestep s i = case (s, i) of (Holding vl, ProposePayment pmt) -> Just $ CollectingSignatures vl pmt [] (CollectingSignatures vl pmt pks, AddSignature pk) -> Just $ CollectingSignatures vl pmt (pk:pks) (CollectingSignatures vl _ _, Cancel) -> Just $ Holding vl (CollectingSignatures vl (Payment vp _ _) _, Pay) -> let vl' = vl - vp in Just $ Holding vl' _ -> Nothing{-# INLINABLE check #-}check :: Params -> State -> Input -> PendingTx -> Boolcheck p s i ptx = case (s, i) of (Holding vl, ProposePayment pmt) -> isValidProposal vl pmt && valuePreserved vl ptx (CollectingSignatures vl _ pks, AddSignature pk) -> Validation.txSignedBy ptx pk && isSignatory pk p && not (containsPk pk pks) && valuePreserved vl ptx (CollectingSignatures vl pmt _, Cancel) -> proposalExpired ptx pmt && valuePreserved vl ptx (CollectingSignatures vl pmt@(Payment vp _ _) pks, Pay) -> let vl' = vl - vp in not (proposalExpired ptx pmt) && proposalAccepted p pks && valuePreserved vl' ptx && valuePaid pmt ptx _ -> False{-# INLINABLE final #-}final :: State -> Boolfinal (Holding v) = Value.isZero vfinal _ = False{-# INLINABLE mkValidator #-}mkValidator :: Params -> Scripts.ValidatorType MultiSigSymmkValidator p = SM.mkValidator $ StateMachine step (check p) final validatorCode :: Params -> PlutusTx.CompiledCode (Scripts.ValidatorType MultiSigSym)validatorCode params = $$(PlutusTx.compile [|| mkValidator ||]) `PlutusTx.applyCode` PlutusTx.liftCode params type MultiSigSym = StateMachine State Input scriptInstance :: Params -> Scripts.ScriptInstance MultiSigSymscriptInstance params = Scripts.validator @MultiSigSym (validatorCode params) $$(PlutusTx.compile [|| wrap ||]) where wrap = Scripts.wrapValidator @State @Input machineInstance :: Params -> SM.StateMachineInstance State InputmachineInstance params = SM.StateMachineInstance (StateMachine step (check params) final) (scriptInstance params) allocate :: State -> Input -> Value -> ValueAllocationallocate (CollectingSignatures _ (Payment vp pk _) _) Pay vl = let vl' = vl - vp in ValueAllocation{vaOwnAddress=vl', vaOtherPayments=Tx.payToPubKey vp pk}allocate _ _ vl = ValueAllocation{vaOwnAddress = vl, vaOtherPayments = Haskell.mempty} client :: Params -> SM.StateMachineClient State Inputclient p = SM.mkStateMachineClient (machineInstance p) allocate contract :: ( AsContractError e , AsSMContractError e State Input ) => Params -> Contract MultiSigSchema e ()contract params = go where theClient = client params go = endpoints >> go endpoints = lock <|> propose <|> cancel <|> addSignature <|> pay propose = endpoint @"propose-payment" >>= SM.runStep theClient . ProposePayment cancel = endpoint @"cancel-payment" >> SM.runStep theClient Cancel addSignature = endpoint @"add-signature" >> ownPubKey >>= SM.runStep theClient . AddSignature lock = do value <- endpoint @"lock" SM.runInitialise theClient (Holding value) value pay = endpoint @"pay" >> SM.runStep theClient Pay PlutusTx.makeIsData ''Payment PlutusTx.makeLift ''Payment PlutusTx.makeIsData ''State PlutusTx.makeLift ''State PlutusTx.makeLift ''Params PlutusTx.makeIsData ''Input PlutusTx.makeLift ''Input mkSchemaDefinitions ''MultiSigSchema
  }
  }
{"text": "<s>[INST] What is the purpose of the `collect-gift.sh` script, and how does it handle the process of submitting a Cardano transaction on a testnet? [/INST] The `collect-gift.sh` script is designed to automate the process of submitting a Cardano transaction on a testnet. It handles querying protocol parameters, building a transaction, signing it, and submitting it to the network. After submission, it retrieves and prints the transaction ID and provides a link to view the transaction on CardanoScan. The script first queries the protocol parameters and saves them to `protocol-parameters.json`. It then builds the transaction by specifying the input, script file, datum, redeemer, collateral, change address, and protocol parameters, saving the transaction body to `collect-gift.txbody`. Next, it signs the transaction using the signing key and saves it to `collect-gift.tx`. Finally, it submits the transaction to the testnet and prints the transaction ID along with a CardanoScan link for viewing the transaction status. #!/bin/bash assets=/workspaces/plutus-pioneer-program/code/Week02/assets keypath=/workspaces/plutus-pioneer-program/keys name=\"$1\" collateral=\"$2\" txin=\"$3\" pp=\"$assets/protocol-parameters.json\" body=\"$assets/collect-gift.txbody\" tx=\"$assets/collect-gift.tx\" # Query the protocol parameters \\ cardano-cli query protocol-parameters \\ --testnet-magic 2 \\ --out-file \"$pp\" # Build the transaction cardano-cli transaction build \\ --babbage-era \\ --testnet-magic 2 \\ --tx-in \"$txin\" \\ --tx-in-script-file \"$assets/gift.plutus\" \\ --tx-in-inline-datum-present \\ --tx-in-redeemer-file \"$assets/unit.json\" \\ --tx-in-collateral \"$collateral\" \\ --change-address \"$(cat \"$keypath/$name.addr\")\" \\ --protocol-params-file \"$pp\" \\ --out-file \"$body\" # Sign the transaction cardano-cli transaction sign \\ --tx-body-file \"$body\" \\ --signing-key-file \"$keypath/$name.skey\" \\ --testnet-magic 2 \\ --out-file \"$tx\" # Submit the transaction cardano-cli transaction submit \\ --testnet-magic 2 \\ --tx-file \"$tx\" tid=$(cardano-cli transaction txid --tx-file \"$tx\") echo \"transaction id: $tid\" echo \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\" </s>"}
{"text": "<s>[INST] What does the `make-gift.sh` script do and how does it manage Cardano transactions on a testnet? [/INST] The `make-gift.sh` script is used to automate the process of building, signing, and submitting a Cardano transaction on a testnet. It starts by building a gift address from a payment script file and saving it to `gift.addr`. Then, it constructs a transaction by specifying inputs, outputs, inline datum, and change address, saving the transaction body to `gift.txbody`. The script signs the transaction with the provided signing key and saves the signed transaction to `gift.tx`. Finally, it submits the transaction to the testnet and prints the transaction ID along with a CardanoScan link to view the transaction status. #!/bin/bash assets=/workspaces/plutus-pioneer-program/code/Week02/assets keypath=/workspaces/plutus-pioneer-program/keys name=\"$1\" txin=\"$2\" body=\"$assets/gift.txbody\" tx=\"$assets/gift.tx\" # Build gift address cardano-cli address build \\ --payment-script-file \"$assets/gift.plutus\" \\ --testnet-magic 2 \\ --out-file \"$assets/gift.addr\" # Build the transaction cardano-cli transaction build \\ --babbage-era \\ --testnet-magic 2 \\ --tx-in \"$txin\" \\ --tx-out \"$(cat \"$assets/gift.addr\") + 3000000 lovelace\" \\ --tx-out-inline-datum-file \"$assets/unit.json\" \\ --change-address \"$(cat \"$keypath/$name.addr\")\" \\ --out-file \"$body\" # Sign the transaction cardano-cli transaction sign \\ --tx-body-file \"$body\" \\ --signing-key-file \"$keypath/$name.skey\" \\ --testnet-magic 2 \\ --out-file \"$tx\" # Submit the transaction cardano-cli transaction submit \\ --testnet-magic 2 \\ --tx-file \"$tx\" tid=$(cardano-cli transaction txid --tx-file \"$tx\") echo \"transaction id: $tid\" echo \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\" </s>"}
{"text": "<s>[INST] What functionality does the `Homework.hs` module provide in the context of Plutus smart contracts? [/INST] The `Homework.hs` module includes Haskell code for testing two Plutus smart contracts (`Homework1` and `Homework2`) using the `Tasty` testing framework. It defines scripts and validators for each homework assignment, sets up users with initial balances, and tests various cases of transactions involving gift transfers. The module performs the following: it builds and submits transactions, checks balances, and verifies that transactions have the desired effects on user balances. It uses different redeemer values to test the behavior of the contracts and reports errors if final balances are not as expected. The code is organized into functions for setting up transactions (`giveTx`, `takeTx`, `giveTx'`, `takeTx'`) and validating results against expected outcomes. {-# LANGUAGE NumericUnderscores #-} module Main where import Control.Monad (replicateM, unless) import Plutus.Model import Plutus.V2.Ledger.Api import Prelude import Test.Tasty import qualified Homework1 as H1 import qualified Homework2 as H2 type Homework1Script = TypedValidator () (Bool, Bool) script1 :: Homework1Script script1 = TypedValidator $ toV2 H1.validator type Homework2Script = TypedValidator () H2.MyRedeemer script2 :: Homework2Script script2 = TypedValidator $ toV2 H2.validator setupUsers :: Run [PubKeyHash] setupUsers = replicateM 3 $ newUser $ ada (Lovelace 1000) main :: IO () main = do defaultMain $ do testGroup \"Homework tests\" [ homework1 defaultBabbage , homework2 defaultBabbage ] homework1 :: MockConfig -> TestTree homework1 cfg = do testGroup \"Testing Homework1\" [ good \"Case: (True, True)\" $ giveGift (True, True) , bad \"Case: (True, False)\" $ giveGift (True, False) , bad \"Case: (False, True)\" $ giveGift (False, True) , bad \"Case: (False, False)\" $ giveGift (False, False) ] where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000) cfg giveGift :: (Bool, Bool) -> Run () giveGift redeemer = do users <- setupUsers let [u1, u2, _u3] = users val = adaValue 100 checkBalance (gives u1 val script1) $ do sp <- spend u1 val submitTx u1 $ giveTx sp val utxos <- utxoAt script1 let [(giftRef, giftOut)] = utxos checkBalance (gives script1 (txOutValue giftOut) u2) $ do submitTx u2 $ takeTx u2 redeemer giftRef (txOutValue giftOut) vals <- mapM valueAt users let [v1, v2, _] = vals unless (v1 == adaValue 900 && v2 == adaValue 1100) $ logError \"Final balances are incorrect\" giveTx :: UserSpend -> Value -> Tx giveTx usp val = mconcat [ userSpend usp , payToScript script1 (HashDatum ()) val ] takeTx :: PubKeyHash -> (Bool, Bool) -> TxOutRef -> Value -> Tx takeTx pkh redeemer giftRef giftVal = mconcat [ spendScript script1 giftRef redeemer () , payToKey pkh giftVal ] homework2 :: MockConfig -> TestTree homework2 cfg = do testGroup \"Testing Homework2\" [ bad \"Case: MyRedeemer True True\" $ giveGift' (H2.MyRedeemer True True) , good \"Case: MyRedeemer True False\" $ giveGift' (H2.MyRedeemer True False) , good \"Case: MyRedeemer False True\" $ giveGift' (H2.MyRedeemer False True) , bad \"Case: MyRedeemer False False\" $ giveGift' (H2.MyRedeemer False False) ] where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000) cfg giveGift' :: H2.MyRedeemer -> Run () giveGift' redeemer = do users <- setupUsers let [u1, u2, _u3] = users val = adaValue 100 checkBalance (gives u1 val script2) $ do sp <- spend u1 val submitTx u1 $ giveTx' sp val utxos <- utxoAt script2 let [(giftRef, giftOut)] = utxos checkBalance (gives script2 (txOutValue giftOut) u2) $ do submitTx u2 $ takeTx' u2 redeemer giftRef (txOutValue giftOut) vals <- mapM valueAt users let [v1, v2, _] = vals unless (v1 == adaValue 900 && v2 == adaValue 1100) $ logError \"Final balances are incorrect\" giveTx' :: UserSpend -> Value -> Tx giveTx' usp val = mconcat [ userSpend usp , payToScript script2 (HashDatum ()) val ] takeTx' :: PubKeyHash -> H2.MyRedeemer -> TxOutRef -> Value -> Tx takeTx' pkh redeemer giftRef giftVal = mconcat [ spendScript script2 giftRef redeemer () , payToKey pkh giftVal ] </s>"}
