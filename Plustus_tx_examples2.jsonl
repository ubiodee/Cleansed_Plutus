[
  {
  "prompt": "Write a script that is designed to automate the process of submitting a Cardano transaction on a Testnet.",
  "response": "bash\n#!/bin/bash\n\n# Define paths and parameters\nassets=/workspaces/plutus-pioneer-program/code/Week02/assets\nkeypath=/workspaces/plutus-pioneer-program/keys\nname=\"$1\"\ncollateral=\"$2\"\ntxin=\"$3\"\n\npp=\"$assets/protocol-parameters.json\"\nbody=\"$assets/collect-gift.txbody\"\ntx=\"$assets/collect-gift.tx\"\n\n# Step 1: Query the protocol parameters and save to JSON file\ncardano-cli query protocol-parameters \\\n  --testnet-magic 2 \\\n  --out-file \"$pp\"\n\n# Step 2: Build the transaction with necessary parameters\ncardano-cli transaction build \\\n  --babbage-era \\\n  --testnet-magic 2 \\\n  --tx-in \"$txin\" \\\n  --tx-in-script-file \"$assets/gift.plutus\" \\\n  --tx-in-inline-datum-present \\\n  --tx-in-redeemer-file \"$assets/unit.json\" \\\n  --tx-in-collateral \"$collateral\" \\\n  --change-address \"$(cat \"$keypath/$name.addr\")\" \\\n  --protocol-params-file \"$pp\" \\\n  --out-file \"$body\"\n\n# Step 3: Sign the transaction\ncardano-cli transaction sign \\\n  --tx-body-file \"$body\" \\\n  --signing-key-file \"$keypath/$name.skey\" \\\n  --testnet-magic 2 \\\n  --out-file \"$tx\"\n\n# Step 4: Submit the transaction\ncardano-cli transaction submit \\\n  --testnet-magic 2 \\\n  --tx-file \"$tx\"\n\ntid=$(cardano-cli transaction txid --tx-file \"$tx\")\necho \"transaction id: $tid\"\necho \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\"\n```"
}, 
{
  "prompt": "Write a script that is used to automate the process of building, signing, and submitting a Cardano transaction on a testnet.",
  "response": "#!/bin/bash\n\n# Define paths and parameters\nassets=/workspaces/plutus-pioneer-program/code/Week02/assets\nkeypath=/workspaces/plutus-pioneer-program/keys\nname=\"$1\"\ntxin=\"$2\"\n\nbody=\"$assets/gift.txbody\"\ntx=\"$assets/gift.tx\"\n\n# Step 1: Build the gift address\ncardano-cli address build \\\n  --payment-script-file \"$assets/gift.plutus\" \\\n  --testnet-magic 2 \\\n  --out-file \"$assets/gift.addr\"\n\n# Step 2: Build the transaction with specified inputs and outputs\ncardano-cli transaction build \\\n  --babbage-era \\\n  --testnet-magic 2 \\\n  --tx-in \"$txin\" \\\n  --tx-out \"$(cat \"$assets/gift.addr\") + 3000000 lovelace\" \\\n  --tx-out-inline-datum-file \"$assets/unit.json\" \\\n  --change-address \"$(cat \"$keypath/$name.addr\")\" \\\n  --out-file \"$body\"\n\n# Step 3: Sign the transaction\ncardano-cli transaction sign \\\n  --tx-body-file \"$body\" \\\n  --signing-key-file \"$keypath/$name.skey\" \\\n  --testnet-magic 2 \\\n  --out-file \"$tx\"\n\n# Step 4: Submit the transaction\ncardano-cli transaction submit \\\n  --testnet-magic 2 \\\n  --tx-file \"$tx\"\n\ntid=$(cardano-cli transaction txid --tx-file \"$tx\")\necho \"transaction id: $tid\"\necho \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\"\n"
},
{
  "prompt": "Write a script that validates if and only if the two Booleans in the redeemer are True.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Homework1 where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (compile)\nimport PlutusTx.Prelude (Bool(..), BuiltinData, traceIfFalse, ($), (&&))\nimport Utilities (wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n{-# INLINABLE mkValidator #-}\n\n-- This should validate if and only if the two Booleans in the redeemer are True!\nmkValidator :: () -> (Bool, Bool) -> PlutusV2.ScriptContext -> Bool\nmkValidator _ (a, b) _ = traceIfFalse \"One or more bools are not true\" $ a && b\n\nwrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nwrappedVal = wrapValidator mkValidator\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||])\n"
},
{
  "prompt": "Write a script that creates a validator that unlocks the funds if MyRedeemer's flags are different.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Homework2 where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (unstableMakeIsData, compile)\nimport PlutusTx.Prelude (Bool, BuiltinData, traceIfFalse, ($), (/=))\nimport Utilities (wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\ndata MyRedeemer = MyRedeemer {\n    flag1 :: Bool,\n    flag2 :: Bool\n}\n\nPlutusTx.unstableMakeIsData ''MyRedeemer\n\n{-# INLINABLE mkValidator #-}\n\n-- Create a validator that unlocks the funds if MyRedeemer's flags are different\nmkValidator :: () -> MyRedeemer -> PlutusV2.ScriptContext -> Bool\nmkValidator _ myRed _ = traceIfFalse \"flags are not different\" $ flag1 myRed /= flag2 myRed\n\nwrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nwrappedVal = wrapValidator mkValidator\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||])\n"
},
{
  "prompt": "Write a script that is used to automate the process of building, signing, and submitting a Cardano transaction on a testnet.",
  "response": "#!/bin/bash\n\nassets=/workspaces/plutus-pioneer-program/code/Week02/assets\nkeypath=/workspaces/plutus-pioneer-program/keys\nname=\"$1\"\ntxin=\"$2\"\nbody=\"$assets/gift.txbody\"\ntx=\"$assets/gift.tx\"\n\n# Build gift address\ncardano-cli address build \\\n  --payment-script-file \"$assets/gift.plutus\" \\\n  --testnet-magic 2 \\\n  --out-file \"$assets/gift.addr\"\n\n# Build the transaction\ncardano-cli transaction build \\\n  --babbage-era \\\n  --testnet-magic 2 \\\n  --tx-in \"$txin\" \\\n  --tx-out \"$(cat \"$assets/gift.addr\") + 3000000 lovelace\" \\\n  --tx-out-inline-datum-file \"$assets/unit.json\" \\\n  --change-address \"$(cat \"$keypath/$name.addr\")\" \\\n  --out-file \"$body\"\n\n# Sign the transaction\ncardano-cli transaction sign \\\n  --tx-body-file \"$body\" \\\n  --signing-key-file \"$keypath/$name.skey\" \\\n  --testnet-magic 2 \\\n  --out-file \"$tx\"\n\n# Submit the transaction\ncardano-cli transaction submit \\\n  --testnet-magic 2 \\\n  --tx-file \"$tx\"\n\ntid=$(cardano-cli transaction txid --tx-file \"$tx\")\necho \"transaction id: $tid\"\necho \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\"\n"
},
{
  "prompt": "Write a script validator that always fails.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Burn where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (BuiltinData, compile)\nimport PlutusTx.Prelude (traceError)\nimport Prelude (IO)\nimport Utilities (writeValidatorToFile)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n-- This validator always fails\n--                    Datum         Redeemer     ScriptContext\nmkBurnValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkBurnValidator _ _ _ = traceError \"it burns!!!\"\n\n{-# INLINABLE mkBurnValidator #-}\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkBurnValidator ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveVal :: IO ()\nsaveVal = writeValidatorToFile \"./assets/burn.plutus\" validator\n"
},
{
  "prompt": "Write a script validator that succeeds only if the redeemer is `MkMySillyRedeemer 42`",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule CustomTypes where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (BuiltinData, compile, unstableMakeIsData)\nimport PlutusTx.Prelude (Bool, Eq ((==)), Integer, traceIfFalse, ($))\nimport Prelude (IO)\nimport Utilities (writeValidatorToFile, wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n-- We can create custom data types for our datum and redeemer like this:\nnewtype MySillyRedeemer = MkMySillyRedeemer Integer\nPlutusTx.unstableMakeIsData ''MySillyRedeemer\n\n-- Use TH to create an instance for IsData.\n-- This validator succeeds only if the redeemer is `MkMySillyRedeemer 42`\n--              Datum     Redeemer            ScriptContext\nmkCTValidator :: () -> MySillyRedeemer -> PlutusV2.ScriptContext -> Bool\nmkCTValidator _ (MkMySillyRedeemer r) _ = traceIfFalse \"expected 42\" $ r == 42\n\n{-# INLINABLE mkCTValidator #-}\n\nwrappedMkVal :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nwrappedMkVal = wrapValidator mkCTValidator\n\n{-# INLINABLE wrappedMkVal #-}\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedMkVal ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\nsaveVal :: IO ()\nsaveVal = writeValidatorToFile \"./assets/customtypes.plutus\" validator"
},
{
  "prompt": "Write a script validator that succeeds only if the redeemer is 42.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule FortyTwo where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (BuiltinData, compile)\nimport PlutusTx.Builtins as Builtins (mkI)\nimport PlutusTx.Prelude (otherwise, traceError, (==))\nimport Prelude (IO)\nimport Utilities (writeValidatorToFile)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n-- This validator succeeds only if the redeemer is 42\n--                  Datum         Redeemer     ScriptContext\nmk42Validator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nmk42Validator _ r _ | r == Builtins.mkI 42 = () | otherwise            = traceError \"expected 42\"\n\n{-# INLINABLE mk42Validator #-}\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mk42Validator ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\nsaveVal :: IO ()\nsaveVal = writeValidatorToFile \"./assets/fortytwo.plutus\" validator"
},
{
  "prompt": "Write a script validator that always succeeds.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Gift where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (BuiltinData, compile)\nimport Prelude (IO)\nimport Utilities (writeValidatorToFile)\n\n---------------------------------------------------------------------------------------------------\n-------------------------------- ON-CHAIN CODE / VALIDATOR ----------------------------------------\n\n-- This validator always succeeds\n--                    Datum         Redeemer     ScriptContext\nmkGiftValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkGiftValidator _ _ _ = ()\n\n{-# INLINABLE mkGiftValidator #-}\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkGiftValidator ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\nsaveVal :: IO ()\nsaveVal = writeValidatorToFile \"./assets/gift.plutus\" validator"
},
{
  "prompt": "Write a script that validates if either beneficiary1 has signed the transaction and the current slot is before or at the deadline or if beneficiary2 has signed the transaction and the deadline has passed.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications  #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Homework1 where\n\nimport Plutus.V2.Ledger.Api\nimport Plutus.V2.Ledger.Contexts (txSignedBy)\nimport Plutus.V1.Ledger.Interval\nimport PlutusTx (compile, unstableMakeIsData)\nimport PlutusTx.Prelude (traceIfFalse, Bool(..), (||), (&&), (+))\nimport Utilities (wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\ndata VestingDatum = VestingDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime }\n\nunstableMakeIsData ''VestingDatum\n\n{-# INLINABLE mkVestingValidator #-}\n\n-- This should validate if either beneficiary1 has signed the transaction and the current slot is before or at the deadline\n-- or if beneficiary2 has signed the transaction and the deadline has passed.\nmkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool\nmkVestingValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2\n  where\n    txInfo :: TxInfo\n    txInfo = scriptContextTxInfo ctx\n    txValidRange :: POSIXTimeRange\n    txValidRange  = txInfoValidRange txInfo\n\n    checkCondition1 :: Bool\n    checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange\n\n    checkCondition2 :: Bool\n    checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange\n\n{-# INLINABLE  mkWrappedVestingValidator #-}\n\nmkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedVestingValidator = wrapValidator mkVestingValidator\n\nvalidator :: Validator\nvalidator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||])"
},
{
  "prompt": "Write a script that validates if the transaction has a signature from the parameterized beneficiary and the deadline has passed.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Homework2 where\n\nimport Plutus.V2.Ledger.Api\nimport Plutus.V2.Ledger.Contexts\nimport Plutus.V1.Ledger.Interval\nimport PlutusTx (applyCode, compile, liftCode)\nimport PlutusTx.Prelude (Bool(..), (.), traceIfFalse, (&&))\nimport Utilities (wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n{-# INLINABLE mkParameterizedVestingValidator #-}\n\n-- This should validate if the transaction has a signature from the parameterized beneficiary and the deadline has passed.\nmkParameterizedVestingValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool\nmkParameterizedVestingValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline\n  where\n    txInfo :: TxInfo\n    txInfo = scriptContextTxInfo ctx\n    txValidRange :: POSIXTimeRange\n    txValidRange  = txInfoValidRange txInfo\n\n    checkSig :: Bool\n    checkSig = txSignedBy txInfo beneficiary\n\n    checkDeadline :: Bool\n    checkDeadline = contains (from deadline) txValidRange\n\n{-# INLINABLE  mkWrappedParameterizedVestingValidator #-}\n\nmkWrappedParameterizedVestingValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator\n\nvalidator :: PubKeyHash -> Validator\nvalidator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode beneficiary)"
},
{
  "prompt": "Write a script validator that determines if a transaction has been signed by a specific beneficiary and if the deadline for that beneficiary has passed.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule ParameterizedVesting where\n\nimport           Plutus.V1.Ledger.Interval (contains)\nimport           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript)\nimport           Plutus.V2.Ledger.Contexts (txSignedBy)\nimport           PlutusTx                  (applyCode, compile, liftCode, makeLift)\nimport           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (.) )\nimport           Prelude                   (IO)\nimport           Utilities                 (writeValidatorToFile, wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\ndata VestingParams = VestingParams { beneficiary :: PubKeyHash , deadline    :: POSIXTime }\n\nmakeLift ''VestingParams\n\n{-# INLINABLE mkParameterizedVestingValidator #-}\nmkParameterizedVestingValidator :: VestingParams -> () -> () -> ScriptContext -> Bool\nmkParameterizedVestingValidator params () () ctx = traceIfFalse \"beneficiary's signature missing\" signedByBeneficiary && traceIfFalse \"deadline not reached\" deadlineReached\n  where\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n\n    signedByBeneficiary :: Bool\n    signedByBeneficiary = txSignedBy info $ beneficiary params\n\n    deadlineReached :: Bool\n    deadlineReached = contains (from $ deadline params) $ txInfoValidRange info\n\n{-# INLINABLE  mkWrappedParameterizedVestingValidator #-}\nmkWrappedParameterizedVestingValidator :: VestingParams -> BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator\n\nvalidator :: VestingParams -> Validator\nvalidator params = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode params)\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\nsaveVal :: VestingParams -> IO ()\nsaveVal = writeValidatorToFile \"./assets/parameterized-vesting.plutus\" . validator"
},
{
  "prompt": "Write a script validator that provides a comprehensive testing framework for two vesting smart contracts built on the Plutus platform.",
  "response": "{-# LANGUAGE NumericUnderscores #-}\n\nmodule Main where\n\nimport Control.Monad (replicateM)\nimport Plutus.Model\nimport Plutus.Model.Fork.Ledger.Slot (Slot)\nimport Plutus.V2.Ledger.Api\nimport Prelude\nimport Test.Tasty\nimport qualified Homework1 as H1\nimport qualified Homework2 as H2\n\ntype Homework1Script = TypedValidator H1.VestingDatum ()\n\nscript1 :: Homework1Script\nscript1 = TypedValidator $ toV2 H1.validator\n\ntype Homework2Script = TypedValidator POSIXTime ()\n\nscript2 :: PubKeyHash -> Homework2Script\nscript2 = TypedValidator . toV2 . H2.validator\n\nsetupUsers :: Run [PubKeyHash]\nsetupUsers = replicateM 3 $ newUser $ ada (Lovelace 1000)\n\nmain :: IO ()\nmain = do\n  defaultMain $ do\n    testGroup \"Homework tests\" [\n      testGroup \"All times are in POSIXTime (Not slots)\" [\n        homework1 defaultBabbage,\n        homework2 defaultBabbage\n      ]\n    ]\n\nhomework1 :: MockConfig -> TestTree\nhomework1 cfg = testGroup \"Testing Homework1\" [\n  testGroup \"Beneficiary 1 signing\" [\n    good \"Deadline: 6000; TxValidRange (5000, 5999)\" $ testBeneficiary1 6000 (-999) 0 0,\n    good \"Deadline: 6000; TxValidRange (5000, 6000)\" $ testBeneficiary1 6000 (-999) 1 0,\n    good \"Deadline: 6000; TxValidRange (5000, 6999)\" $ testBeneficiary1 6000 (-999) 1000 0,\n    good \"Deadline: 6000; TxValidRange (5999, 6001)\" $ testBeneficiary1 6000 0 2 0,\n    good \"Deadline: 6000; TxValidRange (6999, 6999)\" $ testBeneficiary1 6000 0 0 1,\n    bad \"Deadline: 6000; TxValidRange (7000, 8000)\" $ testBeneficiary1 6000 1 1001 1,\n    bad \"Deadline: 6000; TxValidRange (5000, 7000)\" $ testBeneficiary1 6000 (-999) 1001 0,\n    bad \"Deadline: 6000; TxValidRange (6000, 7000)\" $ testBeneficiary1 6000 (-999) 1 1,\n    bad \"Deadline: 6000; TxValidRange (6999, 7000)\" $ testBeneficiary1 6000 0 1 1\n  ],\n  testGroup \"Beneficiary 2 signing\" [\n    good \"Deadline: 5000; TxValidRange (6000, 7000)\" $ testBeneficiary2 5000 (-999) 1 1,\n    good \"Deadline: 4999; TxValidRange (5000, 6000)\" $ testBeneficiary2 4999 (-999) 1 0,\n    bad \"Deadline: 6000; TxValidRange (5000, 5999)\" $ testBeneficiary2 6000 (-999) 0 0,\n    bad \"Deadline: 5000; TxValidRange (5000, 6000)\" $ testBeneficiary2 5000 (-999) 1 0,\n    bad \"Deadline: 5000; TxValidRange (5001, 6000)\" $ testBeneficiary2 5000 (-998) 1 0,\n    bad \"Deadline: 5000; TxValidRange (5999, 6000)\" $ testBeneficiary2 5000 0 1 0\n  ],\n  bad \"None signing\" $ testNoSigning 5000 0 0 0\n] where\n  bad msg = good msg . mustFail\n  good = testNoErrors (adaValue 10_000_000) cfg\n\n  testBeneficiary1 :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run ()\n  testBeneficiary1 deadline curMinT curMaxT wSlot = do\n    users <- setupUsers\n    let [u1, u2, u3] = users\n        dat = H1.VestingDatum u1 u2 deadline\n    testHomework1 u1 u3 dat curMinT curMaxT wSlot\n\n  testBeneficiary2 :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run ()\n  testBeneficiary2 deadline curMinT curMaxT wSlot = do\n    users <- setupUsers\n    let [u1, u2, u3] = users\n        dat = H1.VestingDatum u1 u2 deadline\n    testHomework1 u2 u3 dat curMinT curMaxT wSlot\n\n  testNoSigning :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run ()\n  testNoSigning deadline curMinT curMaxT wSlot = do\n    users <- setupUsers\n    let [u1, u2, u3] = users\n        dat = H1.VestingDatum u1 u2 deadline\n    testHomework1 u3 u3 dat curMinT curMaxT wSlot\n\n  testHomework1 :: PubKeyHash -> PubKeyHash -> H1.VestingDatum -> POSIXTime -> POSIXTime -> Slot -> Run ()\n  testHomework1 sigUser receiver dat curMinT curMaxT wSlot = do\n    let val = adaValue 100\n    checkBalance (gives sigUser val script1) $ do\n      sp <- spend sigUser val\n      submitTx sigUser $ vestingTx1 dat sp val\n      waitNSlots wSlot\n      utxos <- utxoAt script1\n      let [(vestRef, vestOut)] = utxos\n      checkBalance (gives script1 (txOutValue vestOut) receiver) $ do\n        range <- currentTimeInterval curMinT curMaxT\n        tx <- validateIn range $ claimingTx1 receiver dat vestRef (txOutValue vestOut)\n        submitTx sigUser tx\n\n  vestingTx1 :: H1.VestingDatum -> UserSpend -> Value -> Tx\n  vestingTx1 dat usp val = mconcat [ userSpend usp , payToScript script1 (HashDatum dat) val ]\n\n  claimingTx1 :: PubKeyHash -> H1.VestingDatum -> TxOutRef -> Value -> Tx\n  claimingTx1 pkh dat vestRef vestVal = mconcat [ spendScript script1 vestRef () dat , payToKey pkh vestVal ]\n\nhomework2 :: MockConfig -> TestTree\nhomework2 cfg = testGroup \"Testing Homework2\" [\n  good \"Deadline: 5000; TxValidRange (6000, 7000)\" $ testHomework2 5000 (-999) 1 1,\n  good \"Deadline: 5000; TxValidRange (5000, 5000)\" $ testHomework2 5000 (-999) (-999) 0,\n  good \"Deadline: 5000; TxValidRange (5000, 6000)\" $ testHomework2 5000 (-999) 1 0,\n  good \"Deadline: 5000; TxValidRange (5001, 6000)\" $ testHomework2 5000 (-998) 1 0,\n  good \"Deadline: 5000; TxValidRange (5999, 6000)\" $ testHomework2 5000 0 1 0,\n  bad \"Deadline: 5000; TxValidRange (4000, 5000)\" $ testHomework2 5000 (-1999) (-999) 0,\n  bad \"Deadline: 5000; TxValidRange (4999, 5000)\" $ testHomework2 5000 (-1000) (-999) 0,\n  bad \"Deadline: 5000; TxValidRange (4999, 5999)\" $ testHomework2 5000 (-1000) 0 0\n] where\n  bad msg = good msg . mustFail\n  good = testNoErrors (adaValue 10_000_000) cfg\n\n  testHomework2 :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run ()\n  testHomework2 dat curMinT curMaxT wSlot = do\n    users <- setupUsers\n    let [u1, u2, _u3] = users\n        val = adaValue 100\n    checkBalance (gives u1 val $ script2 u2) $ do\n      sp <- spend u1 val\n      submitTx u1 $ vestingTx2 u2 dat sp val\n      waitNSlots wSlot\n      utxos <- utxoAt $ script2 u2\n      let [(vestRef, vestOut)] = utxos\n      checkBalance (gives (script2 u2) (txOutValue vestOut) u2) $ do\n        range <- currentTimeInterval curMinT curMaxT\n        tx <- validateIn range $ claimingTx2 u2 dat vestRef (txOutValue vestOut)\n        submitTx u2 tx\n\n  vestingTx2 :: PubKeyHash -> POSIXTime -> UserSpend -> Value -> Tx\n  vestingTx2 pkh dat usp val = mconcat [ userSpend usp , payToScript (script2 pkh) (HashDatum dat) val ]\n\n  claimingTx2 :: PubKeyHash -> POSIXTime -> TxOutRef -> Value -> Tx\n  claimingTx2 receiver dat vestRef vestVal = mconcat [ spendScript (script2 receiver) vestRef () dat , payToKey receiver vestVal ]"
},
{
  "prompt": "Write a script that figures out what this (already finished) validator does using all the tools at your disposal and also write off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing.",
  "response": "{-# LANGUAGE DataKinds         #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell   #-}\n{-# LANGUAGE TypeApplications  #-}\n{-# LANGUAGE TypeFamilies      #-}\n\nmodule Homework1 where\n\nimport           Data.Maybe                (fromJust)\nimport           Plutus.V1.Ledger.Interval (contains, to)\nimport           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, POSIXTimeRange, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript)\nimport           Plutus.V2.Ledger.Contexts (txSignedBy)\nimport           PlutusTx                  (compile, unstableMakeIsData)\nimport           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (+), (||))\nimport           Prelude                   (IO, String)\nimport           Utilities                 (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, wrapValidator, writeValidatorToFile)\n\n---------------------------------------------------------------------------------------------------\n------------------------------------------ PROMPT -------------------------------------------------\n{- 1- Figure out what this (already finished) validator does using all the tools at your disposal.\n   2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing.\n   HINT: If you get stuck, take a look at Week03's lecture -}\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\ndata MisteryDatum = MisteryDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime }\n\nunstableMakeIsData ''MisteryDatum\n\n{-# INLINABLE mkMisteryValidator #-}\nmkMisteryValidator :: MisteryDatum -> () -> ScriptContext -> Bool\nmkMisteryValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2\n  where\n    txInfo :: TxInfo\n    txInfo = scriptContextTxInfo ctx\n    txValidRange :: POSIXTimeRange\n    txValidRange  = txInfoValidRange txInfo\n\n    checkCondition1 :: Bool\n    checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange\n\n    checkCondition2 :: Bool\n    checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange\n\n{-# INLINABLE  mkWrappedMisteryValidator #-}\nmkWrappedMisteryValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedMisteryValidator = wrapValidator mkMisteryValidator\n\nvalidator :: Validator\nvalidator = mkValidatorScript $$(compile [|| mkWrappedMisteryValidator ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveVal :: IO ()\nsaveVal = writeValidatorToFile \"./assets/mistery1.plutus\" validator\n\nmisteryAddressBech32 :: Network -> String\nmisteryAddressBech32 network = validatorAddressBech32 network validator\n\nprintMisteryDatumJSON :: PubKeyHash -> PubKeyHash -> String -> IO ()\nprintMisteryDatumJSON pkh1 pkh2 time = printDataToJSON $ MisteryDatum { beneficiary1 = pkh1 , beneficiary2 = pkh2 , deadline    = fromJust $ posixTimeFromIso8601 time }"
},
{
  "prompt": "Write a script that sets blockfrost endpoint, loads local stored seed as a wallet into lucid, defines the vesting plutus script, creates the vesting datum type, sets the vesting deadline, sets the vesting beneficiary to our own key, creating a datum with a beneficiary and deadline, and asynchronous function that sends an amount of Lovelace to the script with the above datum.",
  "response": "import { Data, Lucid, Blockfrost, getAddressDetails, SpendingValidator, TxHash, Datum, UTxO, Address, AddressDetails, } from \"https://deno.land/x/lucid@0.9.1/mod.ts\"\n\nimport { secretSeed } from \"./seed.ts\"\n\nconst lucid = await Lucid.new(new Blockfrost(\"https://cardano-preprod.blockfrost.io/api/v0\", \"insert your own api key here\"), \"Preprod\");\nlucid.selectWalletFromSeed(secretSeed);\n\nconst addr: Address = await lucid.wallet.address();\nconsole.log(addr);\n\nconst vestingScript: SpendingValidator = {\n  type: \"PlutusV2\",\n  script: "590b30590b2d0100003232323322323233223232323232323233223233223232323232323232333222323232322323222323253353232323253355335323235002222222222222533533355301a12001321233001225335002210031001002502c25335333573466e3c0380040ec0e84d40b8004540b4010840ec40e4d401488009400440b04cd5ce2491f62656e65666963696172792773207369676e6174757265206d697373696e670002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b00300735500322222222222200533501433501635029350052200102d335015502802d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce248114646561646c696e65206e6f7420726561636865640002b102b135001220023333573466e1cd55cea80224000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a008603e6ae84d5d1280211931901519ab9c02d02c0283333573466e1cd55ce9baa0054800080ac8c98c80a4cd5ce0160158139999ab9a3370e6aae7540192000233221233001003002375c6ae854018dd69aba135744a00c464c6405066ae700ac0a809840a44c98c809ccd5ce2490350543500029135573ca00226ea80044d55cf280089baa00132001355023221122253350011350032200122133350052200230040023335530071200100500400112223500222350032253335333500800700400215335003100110261025102612223232323253335006215333500621533350082130044984c00d261533350072130044984c00d26100d100b1533350072130044984c00d261533350062130044984c00d26100c1533350052100a100b100915333500521533350072130054984c011261533350062130054984c01126100c100a1533350062130054984c011261533350052130054984c01126100b2533350052153335007215333500721333500b00a002001161616100b153335006215333500621333500a009002001161616100a10092533350042153335006215333500621333500a009002001161616100a1533350052153335005213335009008002001161616100910082533350032153335005215333500521333500900800200116161610091533350042153335004213335008007002001161616100810072533350022153335004215333500421333500800700200116161610081533350032153335003213335007006002001161616100710061235001222222220071222003122200212220011221233001003002122123300100300212212330010030021232230023758002640026aa034446666aae7c004940288cd4024c010d5d080118019aba200201a232323333573466e1cd55cea80124000466442466002006004601c6ae854008c014d5d09aba2500223263201833573803603402c26aae7940044dd50009191919191999ab9a3370e6aae75401120002333322221233330010050040030023232323333573466e1cd55cea80124000466442466002006004602e6ae854008cd403c058d5d09aba2500223263201d33573804003e03626aae7940044dd50009aba150043335500875ca00e6ae85400cc8c8c8cccd5cd19b875001480108c84888c008010d5d09aab9e500323333573466e1d4009200223212223001004375c6ae84d55cf280211999ab9a3370ea00690001091100191931900f99ab9c02202101d01c01b135573aa00226ea8004d5d0a80119a805bae357426ae8940088c98c8064cd5ce00e00d80b89aba25001135744a00226aae7940044dd5000899aa800bae75a224464460046eac004c8004d5405c88c8cccd55cf80112804119a8039991091980080180118031aab9d5002300535573ca00460086ae8800c0604d5d080088910010910911980080200189119191999ab9a3370ea002900011a80398029aba135573ca00646666ae68cdc3a801240044a00e464c6402866ae7005c0580480444d55cea80089baa0011212230020031122001232323333573466e1d400520062321222230040053007357426aae79400c8cccd5cd19b875002480108c848888c008014c024d5d09aab9e500423333573466e1d400d20022321222230010053007357426aae7940148cccd5cd19b875004480008c848888c00c014dd71aba135573ca00c464c6402466ae7005405004003c0380344d55cea80089baa001232323333573466e1cd55cea80124000466442466002006004600a6ae854008dd69aba135744a004464c6401c66ae700440400304d55cf280089baa0012323333573466e1cd55cea800a400046eb8d5d09aab9e500223263200c33573801e01c01426ea80048c8c8c8c8c8cccd5cd19b8750014803084888888800c8cccd5cd19b875002480288488888880108cccd5cd19b875003480208cc8848888888cc004024020dd71aba15005375a6ae84d5d1280291999ab9a3370ea00890031199109111111198010048041bae35742a00e6eb8d5d09aba2500723333573466e1d40152004233221222222233006009008300c35742a0126eb8d5d09aba2500923333573466e1d40192002232122222223007008300d357426aae79402c8cccd5cd19b875007480008c848888888c014020c038d5d09aab9e500c23263201533573803002e02602402202001e01c01a26aae7540104d55cf280189aab9e5002135573ca00226ea80048c8c8c8c8cccd5cd19b875001480088ccc888488ccc00401401000cdd69aba15004375a6ae85400cdd69aba135744a00646666ae68cdc3a80124000464244600400660106ae84d55cf280311931900719ab9c01101000c00b135573aa00626ae8940044d55cf280089baa001232323333573466e1d400520022321223001003375c6ae84d55cf280191999ab9a3370ea004900011909118010019bae357426aae7940108c98c802ccd5ce00700680480409aab9d50011375400224464646666ae68cdc3a800a40084a00c46666ae68cdc3a8012400446a010600c6ae84d55cf280211999ab9a3370ea00690001091100111931900619ab9c00f00e00a009008135573aa00226ea8004484888c00c010448880048c8cccd5cd19b8750014800880188cccd5cd19b8750024800080188c98c8018cd5ce00480400200189aab9d37540029309100109100089000a490350543100112323001001223300330020020011", };\n\nconst vestingAddress: Address = lucid.utils.validatorToAddress(vestingScript);\n\nconst VestingDatum = Data.Object({\n  beneficiary: Data.String,\n  deadline: Data.BigInt,\n});\n\ntype VestingDatum = Data.Static<typeof VestingDatum>;\n\nconst deadlineDate: Date = new Date(\"2023-03-19T00:00:00Z\")\nconst deadlinePosIx = BigInt(deadlineDate.getTime());\n\nconst details: AddressDetails = getAddressDetails(addr);\nconst beneficiaryPKH: string = details.paymentCredential.hash;\n\nconst datum: VestingDatum = {\n  beneficiary: beneficiaryPKH,\n  deadline: deadlinePosIx,\n};\n\nasync function vestFunds(amount: bigint): Promise<TxHash> {\n  const dtm: Datum = Data.to<VestingDatum>(datum, VestingDatum);\n  const tx = await lucid.newTx().payToContract(vestingAddress, { inline: dtm }, { lovelace: amount }).complete();\n  const signedTx = await tx.sign().complete();\n  const txHash = await signedTx.submit();\n  return txHash\n}\n\nasync function claimVestedFunds(): Promise<TxHash> {\n  const dtm: Datum = Data.to<VestingDatum>(datum, VestingDatum);\n  const utxoAtScript: UTxO[] = await lucid.utxosAt(vestingAddress);\n\n  const ourUTxO: UTxO[] = utxoAtScript.filter((utxo) => utxo.datum == dtm);\n\n  if (ourUTxO && ourUTxO.length > 0) {\n    const tx = await lucid.newTx().collectFrom(ourUTxO, Data.void()).addSignerKey(beneficiaryPKH).attachSpendingValidator(vestingScript).validFrom(Date.now()-100000).complete();\n    const signedTx = await tx.sign().complete();\n    const txHash = await signedTx.submit();\n    return txHash\n  } else\n    return \"No UTxO's found that can be claimed\"\n}\n\n//console.log(await vestFunds(100000000n));\n//console.log(await claimVestedFunds());"
}, 
{
  "prompt": "Write a script policy that should only allow minting (or burning) of tokens if the owner of the specified PubKeyHash has signed the transaction and if the specified deadline has not passed.",
  "response": "{-# LANGUAGE DataKinds             #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE TemplateHaskell       #-}\n\nmodule Homework1 where\n\nimport           Plutus.V2.Ledger.Api\nimport           Plutus.V2.Ledger.Contexts\nimport           Plutus.V1.Ledger.Interval\nimport qualified PlutusTx\nimport           PlutusTx.Prelude     (Bool (..), ($), traceIfFalse, (&&))\nimport           Utilities            (wrapPolicy, writeCodeToFile, currencySymbol, writePolicyToFile)\nimport           Prelude              (IO, Show (show))\nimport           Text.Printf          (printf)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n{-# INLINABLE mkDeadlinePolicy #-}\n\n-- This policy should only allow minting (or burning) of tokens if the owner of the specified PubKeyHash\n-- has signed the transaction and if the specified deadline has not passed.\nmkDeadlinePolicy :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool\nmkDeadlinePolicy owner deadline () ctx =\n    traceIfFalse \"not signed by owner\" checkSig &&\n    traceIfFalse \"too late: deadline has already passed\" checkDeadline\n  where\n    txInfo :: TxInfo\n    txInfo = scriptContextTxInfo ctx\n\n    checkSig :: Bool\n    checkSig = txSignedBy txInfo owner\n\n    txValidRange :: POSIXTimeRange\n    txValidRange = txInfoValidRange txInfo\n\n    checkDeadline :: Bool\n    checkDeadline = contains (to deadline) txValidRange\n\n{-# INLINABLE mkWrappedDeadlinePolicy #-}\nmkWrappedDeadlinePolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedDeadlinePolicy pkh deadline = wrapPolicy $ mkDeadlinePolicy pkh' deadline'\n  where\n    pkh' :: PubKeyHash\n    pkh' = PlutusTx.unsafeFromBuiltinData pkh\n\n    deadline' :: POSIXTime\n    deadline' = PlutusTx.unsafeFromBuiltinData deadline\n\n\ndeadlineCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())\ndeadlineCode = $$(PlutusTx.compile [|| mkWrappedDeadlinePolicy ||])\n\n\ndeadlinePolicy :: PubKeyHash -> POSIXTime -> MintingPolicy\ndeadlinePolicy pkh deadline = mkMintingPolicyScript $\n    deadlineCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData pkh)\n                                 `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData deadline)\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveDeadlineCode :: IO ()\nsaveDeadlineCode = writeCodeToFile \"assets/deadline.plutus\"\n\nsaveDeadlinePolicy :: PubKeyHash -> POSIXTime -> IO ()\nsaveDeadlinePolicy pkh deadline =\n    writePolicyToFile  (printf \"assets/deadline-%s.plutus\" $ show pkh)  $ deadlinePolicy pkh deadline\n\ndeadlineCurrencySymbol :: PubKeyHash -> POSIXTime -> CurrencySymbol\ndeadlineCurrencySymbol pkh deadline = currencySymbol $ deadlinePolicy pkh deadline\n"
},
{
  "prompt": "Write a script minting policy for an NFT, where the minting transaction must consume the given UTxO as input and where the TokenName will be the empty ByteString.",
  "response": "{-# LANGUAGE DataKinds             #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE TemplateHaskell       #-}\n\nmodule Homework2 where\n\nimport           Plutus.V2.Ledger.Api\nimport           Plutus.V1.Ledger.Value (flattenValue)\nimport           Plutus.V2.Ledger.Contexts (ownCurrencySymbol)\nimport qualified PlutusTx\nimport           PlutusTx.Builtins.Internal (emptyByteString)\nimport           PlutusTx.Prelude       (Bool (..), ($), (.), (&&),  (==), any, traceIfFalse)\nimport           Utilities              (wrapPolicy, writeCodeToFile)\nimport           Prelude (IO)\n\n{-# INLINABLE tn #-}\ntn :: TokenName\ntn = TokenName emptyByteString\n\n{-# INLINABLE mkEmptyNFTPolicy #-}\n\n-- Minting policy for an NFT, where the minting transaction must consume the given UTxO as input\n-- and where the TokenName will be the empty ByteString.\nmkEmptyNFTPolicy :: TxOutRef -> () -> ScriptContext -> Bool\nmkEmptyNFTPolicy oref () ctx =\n    traceIfFalse \"UTxO not consumed\"   hasUTxO           &&\n    traceIfFalse \"wrong amount minted\" checkMintedAmount\n  where\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n\n    hasUTxO :: Bool\n    hasUTxO = any (\\i -> txInInfoOutRef i == oref) $ txInfoInputs info\n\n    checkMintedAmount :: Bool\n    checkMintedAmount = case flattenValue (txInfoMint info) of\n        [(cs, tn', amt)] -> cs  == ownCurrencySymbol ctx && tn' == tn && amt == 1\n        _                -> False\n\n{-# INLINABLE mkWrappedEmptyNFTPolicy #-}\nmkWrappedEmptyNFTPolicy :: TxOutRef -> BuiltinData -> BuiltinData -> ()\nmkWrappedEmptyNFTPolicy = wrapPolicy . mkEmptyNFTPolicy\n\nnftCode :: PlutusTx.CompiledCode (TxOutRef -> BuiltinData -> BuiltinData -> ())\nnftCode = $$(PlutusTx.compile [|| mkWrappedEmptyNFTPolicy ||])\n\nnftPolicy :: TxOutRef -> MintingPolicy\nnftPolicy oref = mkMintingPolicyScript $ \n    $$(PlutusTx.compile [|| mkWrappedEmptyNFTPolicy ||])\n        `PlutusTx.applyCode` PlutusTx.liftCode oref\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveNFTCode :: IO ()\nsaveNFTCode = writeCodeToFile \"assets/nftPolicyH2_typed.plutus\" nftCode\n"
},
{
  "prompt": "Implement a simple escrow contract that holds funds until conditions are met in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-}\n\nmodule Escrow where\n\nimport PlutusTx\nimport PlutusTx.Prelude\nimport Plutus.V2.Ledger.Contexts (ScriptContext, txSignedBy)\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport qualified PlutusTx\n\n-- Data type for the escrow contract\n{-# INLINABLE mkEscrowValidator #-}\ndata Escrow = Escrow\n    { buyer       :: PubKeyHash\n    , seller      :: PubKeyHash\n    , amount      :: Integer\n    , isCompleted :: Bool\n    }\n\nPlutusTx.unstableMakeIsData ''Escrow\n\n-- Validator function that checks if conditions are met to release funds\nmkEscrowValidator :: Escrow -> () -> ScriptContext -> Bool\nmkEscrowValidator escrow _ ctx =\n    if isCompleted escrow\n        then traceIfFalse \"Seller must sign\" (txSignedBy (scriptContextTxInfo ctx) (seller escrow))\n        else traceIfFalse \"Buyer must sign\" (txSignedBy (scriptContextTxInfo ctx) (buyer escrow))\n\n-- Function to update escrow status after meeting conditions\nfinalize :: Escrow -> Bool -> Escrow\nfinalize escrow condition = escrow { isCompleted = condition }\n\n-- Wrapping the validator\nwrappedEscrowValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nwrappedEscrowValidator = wrapValidator mkEscrowValidator\n\n-- Compiled code\nvalidatorCode :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ())\nvalidatorCode = $$(compile [|| wrappedEscrowValidator ||])\n"
},
{
  "prompt": "Create a decentralized identity verification system in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-}\n\nmodule IdentityVerification where\n\nimport PlutusTx\nimport PlutusTx.Prelude\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport qualified PlutusTx\n\n-- Data type representing a user in the identity verification system\ndata User = User\n    { pubKey   :: PubKeyHash\n    , verified :: Bool\n    }\n\nPlutusTx.unstableMakeIsData ''User\n\n-- Function to verify user identity by matching provided public key with the stored key\nverifyIdentity :: PubKeyHash -> Bool -> User -> User\nverifyIdentity key status (User k v) =\n    if k == key then User k status else User k v\n\n-- Example usage (would be done off-chain) where a verifier sets the `verified` flag\nexampleVerify :: PubKeyHash -> Bool -> User -> User\nexampleVerify = verifyIdentity\n"
},
{
  "prompt": "Develop a simple NFT minting contract in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-}\n\nmodule NFTMinting where\n\nimport PlutusTx\nimport PlutusTx.Prelude\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport qualified PlutusTx\n\n-- Data type representing an NFT with an owner and unique token ID\ndata NFT = NFT\n    { owner   :: PubKeyHash\n    , tokenId :: Integer\n    }\n\nPlutusTx.unstableMakeIsData ''NFT\n\n-- Function to mint a new NFT by associating an owner's public key with a token ID\nmintNFT :: PubKeyHash -> Integer -> NFT\nmintNFT owner tokenId = NFT { owner = owner, tokenId = tokenId }\n\n-- Example NFT minting call (off-chain) to mint an NFT for the owner\nexampleMintNFT :: PubKeyHash -> Integer -> NFT\nexampleMintNFT = mintNFT\n"
},
{
  "prompt": "Build a decentralized crowdfunding platform in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-}\n\nmodule Crowdfunding where\n\nimport PlutusTx\nimport PlutusTx.Prelude\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport qualified PlutusTx\n\n-- Data type representing a crowdfunding project with total funds and a list of contributors\ndata Project = Project\n    { totalFunds    :: Integer\n    , contributors  :: [PubKeyHash]\n    }\n\nPlutusTx.unstableMakeIsData ''Project\n\n-- Function to contribute to a project by adding funds and recording the contributor\ncontribute :: Project -> Integer -> PubKeyHash -> Project\ncontribute project amount contributor =\n    project { totalFunds = totalFunds project + amount\n            , contributors = contributor : contributors project\n            }\n\n-- Example usage of the contribute function (off-chain) to simulate adding funds\nexampleContribution :: Project -> Integer -> PubKeyHash -> Project\nexampleContribution = contribute\n"
},
{
  "prompt": "Create a loyalty rewards contract that distributes points based on purchases in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-}\n\nmodule LoyaltyRewards where\n\nimport PlutusTx\nimport PlutusTx.Prelude\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport qualified PlutusTx\n\n-- Data type representing a loyalty reward with customer and points earned\ndata Reward = Reward\n    { customer :: PubKeyHash\n    , points   :: Integer\n    }\n\nPlutusTx.unstableMakeIsData ''Reward\n\n-- Function to update the rewards based on a purchase amount\ntrackPurchase :: PubKeyHash -> Integer -> Reward -> Reward\ntrackPurchase customer amount (Reward c p) =\n    Reward c (p + (amount `div` 10))\n\n-- Example usage of trackPurchase function (off-chain) for a purchase event\nexampleTrackPurchase :: PubKeyHash -> Integer -> Reward -> Reward\nexampleTrackPurchase = trackPurchase\n"
},
{
  "prompt": "Implement a multisignature wallet requiring multiple signatures to authorize a transaction in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule MultisigWallet where\n\nimport PlutusTx\nimport PlutusTx.Prelude\n\ndata MultisigWallet = MultisigWallet { owners :: [PubKeyHash], requiredSigs :: Integer }\n\nauthorizeTransaction :: MultisigWallet -> [PubKeyHash] -> Bool\nauthorizeTransaction wallet signers =\n    length (filter (`elem` owners wallet) signers) >= fromInteger (requiredSigs wallet)"
},
{
  "prompt": "Create a contract to mint a simple fungible token in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule TokenMinting where\n\nimport PlutusTx\nimport PlutusTx.Prelude\n\ndata Token = Token { owner :: PubKeyHash, amount :: Integer }\n\nmintToken :: PubKeyHash -> Integer -> Token\nmintToken owner amount = Token { owner = owner, amount = amount }"
},
{
  "prompt": "Implement a simple auction system using Plutus.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule SimpleAuction where\n\nimport PlutusTx\nimport PlutusTx.Prelude\n\ndata Auction = Auction { highestBid :: Integer, highestBidder :: PubKeyHash }\n\nplaceBid :: Auction -> Integer -> PubKeyHash -> Auction\nplaceBid auction newBid bidder = if newBid > highestBid auction then auction { highestBid = newBid, highestBidder = bidder } else auction"
},
{
  "prompt": "Build a smart contract for a voting system in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule VotingSystem where\n\nimport PlutusTx\nimport PlutusTx.Prelude\n\ndata Vote = Yes | No deriving (Show)\ntype Votes = [(Vote, Integer)]\n\ncastVote :: Vote -> Votes -> Votes\ncastVote vote votes = (vote, 1) : votes\n\ncountVotes :: Votes -> (Integer, Integer)\ncountVotes votes = foldr count (0, 0) votes\n  where\n    count (v, n) (yes, no) = case v of\n        Yes -> (yes + n, no)\n        No  -> (yes, no + n)"
},
{
  "prompt": "Write a script that performs basic arithmetic operations in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule SimpleCalculator where\n\nimport PlutusTx\nimport PlutusTx.Prelude\n\nadd :: Integer -> Integer -> Integer\nadd x y = x + y\n\nsubtract :: Integer -> Integer -> Integer\nsubtract x y = x - y\n\nmultiply :: Integer -> Integer -> Integer\nmultiply x y = x * y\n\ndivide :: Integer -> Integer -> Maybe Integer\ndivide _ 0 = Nothing\ndivide x y = Just (x `div` y)"
},
{
  "prompt": "Write a script that defines how to check if a given time has passed a specified end date in a Plutus smart contract, leveraging Haskell's type system and the capabilities of the Plutus library to safely compile and execute the logic on-chain.",
  "response": "makeLift ''EndDate;\npastEndAt :: EndDate -> Integer -> CompiledCode Bool;\npastEndAt end current = pastEnd `unsafeApplyCode` liftCode plcVersion100 end `unsafeApplyCode` liftCode plcVersion100 current\n\n{- | >>> let program = getPlc $ pastEndAt Never 5 >>> pretty $ unsafeEvaluateCk $ toTerm program (abs out_Bool (type) (lam case_True out_Bool (lam case_False out_Bool case_False))) -}"
},
{
  "prompt": "Write a script that defines the a function, which takes an integer and returns a compiled program that adds 1 to that integer.",
  "response": "addOneToN :: Integer -> CompiledCode Integer;\naddOneToN n = addOne `unsafeApplyCode` liftCode plcVersion100 n\n\n{- | >>> pretty $ getPlc addOne (program 1.0.0 [ (lam addInteger (fun (con integer) (fun (con integer) (con integer))) (lam ds (con integer) [ [ addInteger ds ] (con 1) ])) (lam arg (con integer) (lam arg (con integer) [ [ (builtin addInteger) arg ] arg ])) ]) >>> let program = getPlc $ addOneToN 4 >>> pretty program (program 1.0.0 [ [ (lam addInteger (fun (con integer) (fun (con integer) (con integer))) (lam ds (con integer) [ [ addInteger ds ] (con 1) ])) (lam arg (con integer) (lam arg (con integer) [ [ (builtin addInteger) arg ] arg ])) ] (con 4) ]) >>> pretty $ unsafeEvaluateCk $ toTerm program (con 5) -}"
},
{
  "prompt": "Write a script that sets blockfrost endpoint and loads local stored seed as a wallet into lucid.",
  "response": "import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, getAddressDetails, applyParamsToScript } from \"https://deno.land/x/lucid@0.9.1/mod.ts\"\nimport { blockfrostKey, secretSeed } from \"./secret.ts\"\n\nfunction readAmount(): bigint {\n  const input = prompt(\"amount: \");\n  return input ? BigInt(Number.parseInt(input)) : 1000000n;\n}\n\nconst lucid = await Lucid.new(\n  new Blockfrost(\n    \"https://cardano-preview.blockfrost.io/api/v0\",\n    blockfrostKey\n  ),\n  \"Preview\"\n);\n\nlucid.selectWalletFromSeed(secretSeed);\n\nconst addr: Address = await lucid.wallet.address();\nconsole.log(\"own address: \" + addr);\n\nconst pkh: string = getAddressDetails(addr).paymentCredential?.hash || \"\";\nconsole.log(\"own pubkey hash: \" + pkh);\n\nconst deadlineDate: Date = new Date(\"2023-12-21T00:00:00Z\");\nconst deadlinePosix = BigInt(deadlineDate.getTime());\n\nconst Params = Data.Tuple([Data.String, Data.BigInt]);\ntype Params = Data.Static<typeof Params>;\n\nconst signedPolicy: MintingPolicy = {\n  type: \"PlutusV2\",\n  script: applyParamsToScript<Params>("590af9590af60100003232323322323233223232323232323233223233223232323232323232333222323232322222323253353232323232533553353235001222222222222533533355301912001321233001225335002210031001002502b25335333573466e3c04c0040e80e44d40b4004540b0010840e840e1400440b04cd5ce2481136e6f74207369676e6564206279206f776e65720002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b003007355003222222222222005335014335016502802d3350153502900502d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce24926746f6f206c6174653a20646561646c696e652068617320616c6c7265616479207061737365640002b102b135001220023333573466e1cd55cea802a4000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00a603e6ae84d5d1280291931901519ab9c02d02c0283333573466e1cd55ce9baa0064800080ac8c98c80a4cd5ce0160158139bad006375c00c2050264c6404c66ae712410350543500028135573ca00226ea8004c8004d5408c88448894cd40044d400c88004884ccd401488008c010008ccd54c01c480040140100044888d400888d400c894ccd4ccd402001c01000854cd400c40044098409440984888c8c8c8c94ccd4018854ccd4018854ccd402084c011261300349854ccd401c84c01126130034984034402c54ccd401c84c011261300349854ccd401884c0112613003498403054ccd401484028402c402454ccd4014854ccd401c84c015261300449854ccd401884c01526130044984030402854ccd401884c015261300449854ccd401484c0152613004498402c94ccd4014854ccd401c854ccd401c84ccd402c028008004585858402c54ccd4018854ccd401884ccd40280240080045858584028402494ccd4010854ccd4018854ccd401884ccd4028024008004585858402854ccd4014854ccd401484ccd40240200080045858584024402094ccd400c854ccd4014854ccd401484ccd4024020008004585858402454ccd4010854ccd401084ccd402001c0080045858584020401c94ccd4008854ccd4010854ccd401084ccd402001c008004585858402054ccd400c854ccd400c84ccd401c018008004585858401c401848d40048888888801c488800c4888008488800448848cc00400c00848848cc00400c00848848cc00400c00848c88c008dd6000990009aa80d111999aab9f0012500a233500930043574200460066ae880080688c8c8cccd5cd19b8735573aa004900011991091980080180118071aba150023005357426ae8940088c98c8060cd5ce00d80d00b09aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180b9aba1500233500f016357426ae8940088c98c8074cd5ce01000f80d89aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403e66ae7008808407407006c4d55cea80089baa00135742a00466a016eb8d5d09aba2500223263201933573803803602e26ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355017223233335573e0044a010466a00e66442466002006004600c6aae754008c014d55cf280118021aba200301813574200222440042442446600200800624464646666ae68cdc3a800a400046a00e600a6ae84d55cf280191999ab9a3370ea00490011280391931900a19ab9c017016012011135573aa00226ea800448488c00800c44880048c8c8cccd5cd19b875001480188c848888c010014c01cd5d09aab9e500323333573466e1d400920042321222230020053009357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900919ab9c01501401000f00e00d135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011991091980080180118029aba15002375a6ae84d5d1280111931900719ab9c01101000c135573ca00226ea80048c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8030cd5ce00780700509baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c8054cd5ce00c00b80980900880800780700689aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401c66ae7004404003002c4d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200b33573801c01a01201026aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea004900111a80418031aba135573ca00846666ae68cdc3a801a40004a010464c6401866ae7003c0380280240204d55cea80089baa0011212223003004112220022323333573466e1d40052002200623333573466e1d40092000200623263200633573801201000800626aae74dd5000a4c244004244002240029210350543100112323001001223300330020020011", [pkh, deadlinePosix], Params)\n};\n\nconst policyId: PolicyId = lucid.utils.mintingPolicyToId(signedPolicy);\nconsole.log(\"minting policy: \" + policyId);\n\nconst unit: Unit = policyId + fromText(\"PPP signed and time checked\");\nconst amount: bigint = readAmount();\n\nconst tx = await lucid\n  .newTx()\n  .mintAssets({[unit]: amount}, Data.void())\n  .attachMintingPolicy(signedPolicy)\n  .addSignerKey(pkh)\n  .validTo(Date.now() + 60000)\n  .complete();\n\nconst signedTx = await tx.sign().complete();\nconst txHash = await signedTx.submit();\n\nconsole.log(\"tid: \" + txHash);"
},
{
  "prompt": "Write a script that is useful when you want to create a token minting policy that allows unrestricted minting.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Free where\n\nimport Plutus.V2.Ledger.Api (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext, mkMintingPolicyScript)\nimport qualified PlutusTx\nimport PlutusTx.Prelude (Bool (True))\nimport Prelude (IO)\nimport Utilities (currencySymbol, wrapPolicy, writePolicyToFile)\n\n{-# INLINABLE mkFreePolicy #-}\nmkFreePolicy :: () -> ScriptContext -> Bool\nmkFreePolicy () _ = True\n\n{-# INLINABLE mkWrappedFreePolicy #-}\nmkWrappedFreePolicy :: BuiltinData -> BuiltinData -> ()\nmkWrappedFreePolicy = wrapPolicy mkFreePolicy\n\nfreePolicy :: MintingPolicy\nfreePolicy = mkMintingPolicyScript $$(PlutusTx.compile [|| mkWrappedFreePolicy ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveFreePolicy :: IO ()\nsaveFreePolicy = writePolicyToFile \"assets/free.plutus\" freePolicy\n\nfreeCurrencySymbol :: CurrencySymbol\nfreeCurrencySymbol = currencySymbol freePolicy"
},
{
  "prompt": "Write a script that enables the creation and management of NFTs on the Cardano blockchain by defining the rules for minting them.",
  "response": "{-# LANGUAGE DataKinds         #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell   #-}\n\nmodule NFT where\n\nimport qualified Data.ByteString.Char8      as BS8\nimport Plutus.V1.Ledger.Value     (flattenValue)\nimport Plutus.V2.Ledger.Api       (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext (scriptContextTxInfo), TokenName (unTokenName), TxId (TxId, getTxId), TxInInfo (txInInfoOutRef), TxInfo (txInfoInputs, txInfoMint), TxOutRef (TxOutRef, txOutRefId, txOutRefIdx), mkMintingPolicyScript)\nimport qualified PlutusTx\nimport PlutusTx.Builtins.Internal (BuiltinByteString (BuiltinByteString))\nimport PlutusTx.Prelude           (Bool (False), Eq ((==)), any, traceIfFalse, ($), (&&))\nimport Prelude                    (IO, Show (show), String)\nimport Text.Printf                (printf)\nimport Utilities                  (bytesToHex, currencySymbol, wrapPolicy, writeCodeToFile, writePolicyToFile)\n\n{-# INLINABLE mkNFTPolicy #-}\nmkNFTPolicy :: TxOutRef -> TokenName -> () -> ScriptContext -> Bool\nmkNFTPolicy oref tn () ctx = traceIfFalse \"UTxO not consumed\"   hasUTxO           && traceIfFalse \"wrong amount minted\" checkMintedAmount\n  where\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n\n    hasUTxO :: Bool\n    hasUTxO = any (\\i -> txInInfoOutRef i == oref) $ txInfoInputs info\n\n    checkMintedAmount :: Bool\n    checkMintedAmount = case flattenValue (txInfoMint info) of\n        [(_, tn'', amt)] -> tn'' == tn && amt == 1\n        _                -> False\n\n{-# INLINABLE mkWrappedNFTPolicy #-}\nmkWrappedNFTPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedNFTPolicy tid ix tn' = wrapPolicy $ mkNFTPolicy oref tn\n  where\n    oref :: TxOutRef\n    oref = TxOutRef (TxId $ PlutusTx.unsafeFromBuiltinData tid) (PlutusTx.unsafeFromBuiltinData ix)\n\n    tn :: TokenName\n    tn = PlutusTx.unsafeFromBuiltinData tn'\n\nnftCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())\nnftCode = $$(PlutusTx.compile [|| mkWrappedNFTPolicy ||])\n\nnftPolicy :: TxOutRef -> TokenName -> MintingPolicy\nnftPolicy oref tn = mkMintingPolicyScript $ nftCode\n    `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ getTxId $ txOutRefId oref)\n    `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ txOutRefIdx oref)\n    `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData tn)\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveNFTCode :: IO ()\nsaveNFTCode = writeCodeToFile \"assets/nft.plutus\" nftCode\n\nsaveNFTPolicy :: TxOutRef -> TokenName -> IO ()\nsaveNFTPolicy oref tn = writePolicyToFile (printf \"assets/nft-%s#%d-%s.plutus\" (show $ txOutRefId oref) (txOutRefIdx oref) $ tn') $ nftPolicy oref tn\n  where\n    tn' :: String\n    tn' = case unTokenName tn of\n        (BuiltinByteString bs) -> BS8.unpack $ bytesToHex bs\n\nnftCurrencySymbol :: TxOutRef -> TokenName -> CurrencySymbol\nnftCurrencySymbol oref tn = currencySymbol $ nftPolicy oref tn."
},
{
  "prompt": "Write a script that is designed to implement a testing framework for a token swap mechanism in a smart contract.",
  "response": "{-# LANGUAGE DataKinds          #-}\n{-# LANGUAGE FlexibleInstances  #-}\n{-# LANGUAGE NoImplicitPrelude  #-}\n{-# LANGUAGE NumericUnderscores #-}\n{-# LANGUAGE OverloadedStrings  #-}\n\nmodule Main where\n\nimport           Plutus.Model         (Run, TypedValidator (TypedValidator), adaValue, defaultBabbage, mustFail, testNoErrors, toV2, FakeCoin (FakeCoin), fakeValue, UserSpend, Tx, DatumMode (HashDatum), userSpend, payToScript, spendScript, payToKey, newUser, spend, submitTx, utxoAt, valueAt, logError)\nimport           PlutusTx.Prelude     (($), Integer, Eq ((==)), (&&))\nimport           Prelude              (IO, (.), (<>), Monoid (mconcat), Traversable (mapM), Num ((-)))\nimport qualified ExploitableSwap      as OnChain\nimport qualified PatchedSwap          as PatchedOnChain (validator)\nimport           Test.Tasty           (defaultMain, testGroup)\nimport           Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut (txOutValue))\nimport           Control.Monad        (unless)\n\nmain :: IO ()\nmain = do\n  defaultMain $ do\n    testGroup\n      \"Catch double spend with testing\"\n      [ good \"Normal spending using vulnerable script succeeds\" $ normalSpending swapScript\n      , good \"Double spending using vulnerable script succeeds\" $ doubleSpending swapScript\n      , good \"Normal spending using patched script succeeds   \" $ normalSpending patchedSwapScript\n      , bad  \"Double spending using patched script fails      \" $ doubleSpending patchedSwapScript\n      ]\n  where\n    bad msg = good msg . mustFail\n    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage\n\nscToken :: FakeCoin\nscToken = FakeCoin \"Super-Cool-Token\"\n\ntype HomeworkScript = TypedValidator OnChain.DatumSwap ()\n\nswapScript :: HomeworkScript\nswapScript = TypedValidator $ toV2 OnChain.validator\n\npatchedSwapScript :: HomeworkScript\npatchedSwapScript = TypedValidator $ toV2 PatchedOnChain.validator\n\nlockingTx :: HomeworkScript -> PubKeyHash -> Integer -> UserSpend -> Value -> Tx\nlockingTx script benef price usp val =\n  mconcat\n    [ userSpend usp\n    , payToScript script (HashDatum (OnChain.DatumSwap benef price)) val\n    ]\n\nconsumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> Value -> Tx\nconsumingTx script benef price buyer sp2 ref token =\n  mconcat\n    [ spendScript script ref () (OnChain.DatumSwap benef price)\n    , payToKey buyer token\n    , payToKey benef $ adaValue price\n    , userSpend sp2\n    ]\n\ndoubleConsumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> TxOutRef -> Value -> Tx\ndoubleConsumingTx script benef price buyer sp2 ref1 ref2 token =\n  mconcat\n    [ spendScript script ref1 () (OnChain.DatumSwap benef price)\n    , spendScript script ref2 () (OnChain.DatumSwap benef price)\n    , payToKey buyer $ token <> token -- Two tokens to buyer\n    , payToKey benef $ adaValue price -- Payment for only one token to beneficiary\n    , userSpend sp2\n    ]\n\nnormalSpending :: HomeworkScript -> Run ()\nnormalSpending script = do\n  u1 <- newUser (adaValue 1000 <> fakeValue scToken 1)\n  u2 <- newUser (adaValue 1000)\n  let token = adaValue 1 <> fakeValue scToken 1\n      price = 350\n  sp1 <- spend u1 token\n  submitTx u1 $ lockingTx script u1 price sp1 token\n  utxos <- utxoAt script\n  let [(ref, out)] = utxos\n  sp2 <- spend u2 (adaValue price)\n  submitTx u2 $ consumingTx script u1 price u2 sp2 ref (txOutValue out)\n  [v1, v2] <- mapM valueAt [u1, u2]\n  let expectedV1 = adaValue 999 <> adaValue price\n      expectedV2 = adaValue (1000 - price) <> token\n  unless (v1 == expectedV1 && v2 == expectedV2) $\n    logError \"Final balances are incorrect\"\n\ndoubleSpending :: HomeworkScript -> Run ()\ndoubleSpending script = do\n  u1 <- newUser (adaValue 1000 <> fakeValue scToken 2)\n  u2 <- newUser (adaValue 1000)\n  let token = adaValue 1 <> fakeValue scToken 1\n      price = 350\n  sp1 <- spend u1 token\n  submitTx u1 $ lockingTx script u1 price sp1 token\n  sp1' <- spend u1 token\n  submitTx u1 $ lockingTx script u1 price sp1' token\n  utxos <- utxoAt script\n  let [(ref1, out),(ref2, _)] = utxos\n  sp2 <- spend u2 (adaValue price)\n  submitTx u2 $ doubleConsumingTx script u1 price u2 sp2 ref1 ref2 (txOutValue out)\n  [v1, v2] <- mapM valueAt [u1, u2]\n  let expectedV1 = adaValue 998 <> adaValue price\n      expectedV2 = adaValue (1000 - price) <> token <> token\n  unless (v1 == expectedV1 && v2 == expectedV2) $\n    logError \"Final balances are incorrect\""
},
{
  "prompt": "Write a script that ensures token sales occur correctly by verifying that the buyer pays the required amount to the seller (beneficiary) before completing the transaction.",
  "response": "languageExtensions:[\"DataKinds\",\"ImportQualifiedPost\",\"NoImplicitPrelude\",\"OverloadedStrings\",\"TemplateHaskell\"], module:\"ExploitableSwap\", imports:[\"Plutus.V2.Ledger.Api (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton)\",\"Plutus.V2.Ledger.Contexts (valuePaidTo, TxInfo)\",\"PlutusTx (compile, unstableMakeIsData)\",\"PlutusTx.Builtins (BuiltinData, Integer)\",\"PlutusTx.Prelude (Bool (..), (==), traceIfFalse)\",\"Utilities (wrapValidator)\"], dataTypes:[{\"name\":\"DatumSwap\",\"fields\":[{\"name\":\"beneficiary\",\"type\":\"PubKeyHash\"},{\"name\":\"price\",\"type\":\"Integer\"}]}], functions:[{\"name\":\"mkValidator\",\"description\":\"Validates if the correct amount is paid to the beneficiary.\",\"params\":[{\"name\":\"ds\",\"type\":\"DatumSwap\"},{\"name\":\"_\",\"type\":\"()\"},{\"name\":\"ctx\",\"type\":\"ScriptContext\"}],\"body\":\"traceIfFalse \\\"Hey! You have to pay the owner!\\\" outputToBeneficiary where txInfo = scriptContextTxInfo ctx; outputToBeneficiary = valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds)\"},{\"name\":\"mkWrappedValidator\",\"description\":\"Wraps the mkValidator function.\",\"params\":[{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"},{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"},{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"}],\"body\":\"wrapValidator mkValidator\"},{\"name\":\"validator\",\"description\":\"Compiles the wrapped validator for deployment.\",\"body\":\"mkValidatorScript $$(compile [|| mkWrappedValidator ||])\"}]"
},
{
  "prompt": "Write a script that checks the value paid to the beneficiary is equal to the price, check that the validator required to spend this output is the current one, and check that we're consuming exactly one script output.",
  "response": "languageExtensions:[\"DataKinds\",\"ImportQualifiedPost\",\"NoImplicitPrelude\",\"OverloadedStrings\",\"TemplateHaskell\",\"NamedFieldPuns\"], module:\"PatchedSwap\", imports:[\"Plutus.V2.Ledger.Api (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton, TxInfo (txInfoInputs), Credential (ScriptCredential), Address (addressCredential), TxOut (txOutAddress))\",\"Plutus.V2.Ledger.Contexts (valuePaidTo, TxInInfo, txInInfoResolved, ownHash)\",\"PlutusTx (compile, unstableMakeIsData)\",\"PlutusTx.Builtins (BuiltinData, Integer)\",\"PlutusTx.Prelude (Bool (..), (==), traceIfFalse, (&&), (.), filter, ($))\",\"Utilities (wrapValidator)\"], dataTypes:[{\"name\":\"DatumSwap\",\"fields\":[{\"name\":\"beneficiary\",\"type\":\"PubKeyHash\"},{\"name\":\"price\",\"type\":\"Integer\"}]}], functions:[{\"name\":\"mkValidator\",\"description\":\"Validates that correct amount is paid to beneficiary, only one script UTxO is consumed, and current validator is required.\",\"params\":[{\"name\":\"ds\",\"type\":\"DatumSwap\"},{\"name\":\"_\",\"type\":\"()\"},{\"name\":\"ctx\",\"type\":\"ScriptContext\"}],\"body\":\"traceIfFalse \\\"Hey! You have to pay the owner!\\\" outputToBeneficiary && traceIfFalse \\\"Hey! You can only consume one script UTxO per Tx!\\\" consumeOnlyOneOutput where txInfo = scriptContextTxInfo ctx; outputToBeneficiary = valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds); getScriptInputs = filter isScriptInput allInputs where allInputs = txInfoInputs txInfo; isScriptInput i = case addressCredential . txOutAddress . txInInfoResolved $ i of ScriptCredential vh -> vh == ownHash ctx; _ -> False; consumeOnlyOneOutput = case getScriptInputs of [_] -> True; _ -> False\"},{\"name\":\"mkWrappedValidator\",\"description\":\"Wraps the mkValidator function.\",\"params\":[{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"},{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"},{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"}],\"body\":\"wrapValidator mkValidator\"},{\"name\":\"validator\",\"description\":\"Compiles the wrapped validator for deployment.\",\"body\":\"mkValidatorScript $$(compile [|| mkWrappedValidator ||])\"}]"
},
{
  "prompt": "Write a script that defines data types and logic for an auction system on the Cardano blockchain, using the Plutus platform.",
  "response": "dataTypes:[{\"name\":\"AuctionParams\",\"fields\":[{\"name\":\"apSeller\",\"type\":\"PubKeyHash\",\"description\":\"Seller's wallet address. The highest bid (if it exists) will be sent to the seller. If there is no bid, the asset auctioned will be sent to the seller.\"},{\"name\":\"apAsset\",\"type\":\"Value\",\"description\":\"The asset being auctioned. It can be a single token, multiple tokens of the same kind, or tokens of different kinds, and the token(s) can be fungible or non-fungible.\"},{\"name\":\"apMinBid\",\"type\":\"Lovelace\",\"description\":\"The minimum bid in Lovelace.\"},{\"name\":\"apEndTime\",\"type\":\"POSIXTime\",\"description\":\"The deadline for placing a bid. This is the earliest time the auction can be closed.\"}]},{\"name\":\"Bid\",\"fields\":[{\"name\":\"bBidder\",\"type\":\"PubKeyHash\",\"description\":\"Bidder's wallet address.\"},{\"name\":\"bAmount\",\"type\":\"Lovelace\",\"description\":\"Bid amount in Lovelace.\"}]},{\"name\":\"AuctionDatum\",\"description\":\"Represents the state of a smart contract, containing the highest bid so far (if exists).\",\"fields\":[{\"name\":\"adHighestBid\",\"type\":\"Maybe Bid\"}]},{\"name\":\"AuctionRedeemer\",\"description\":\"Represents an action in the auction. In this case, it is either a new bid or a request to close the auction and pay out the seller and the highest bidder.\",\"fields\":[{\"name\":\"NewBid\",\"type\":\"Bid\"},{\"name\":\"Payout\",\"type\":\"()\"}]},\"functions\":[{\"name\":\"AuctionParams makeLift\",\"description\":\"Makes 'AuctionParams' compatible with on-chain code.\"},{\"name\":\"Bid deriveShow\",\"description\":\"Derives a show instance for 'Bid'.\"},{\"name\":\"Bid makeIsData\",\"description\":\"Allows 'Bid' to be used in on-chain code.\"},{\"name\":\"AuctionDatum makeIsData\",\"description\":\"Allows 'AuctionDatum' to be used in on-chain code.\"},{\"name\":\"AuctionRedeemer makeIsData\",\"description\":\"Allows 'AuctionRedeemer' to be used in on-chain code.\"},{\"name\":\"Eq Bid instance\",\"description\":\"Defines an equality instance for 'Bid' based on bidder address and bid amount.\"}]"
},
{
  "prompt": "Write a script that defines a validator function for an auction system, ensuring that certain rules are followed when processing bids and payouts.",
  "response": "{-# INLINEABLE auctionTypedValidator #-} -- | Given the auction parameters, determines whether the transaction is allowed to spend the UTXO.\nauctionTypedValidator :: AuctionParams -> AuctionDatum -> AuctionRedeemer -> ScriptContext -> Bool\nauctionTypedValidator params (AuctionDatum highestBid) redeemer ctx@(ScriptContext txInfo _) = PlutusTx.and conditions\n\nwhere\nconditions :: [Bool]\nconditions = case redeemer of\n  NewBid bid -> [\n    -- The new bid must be higher than the highest bid.\n    -- If this is the first bid, it must be at least as high as the minimum bid.\n    sufficientBid bid,\n    -- The bid is not too late.\n    validBidTime,\n    -- The previous highest bid should be refunded.\n    refundsPreviousHighestBid,\n    -- A correct new datum is produced, containing the new highest bid.\n    correctNewDatum bid\n  ]\n  Payout -> [\n    -- The payout is not too early.\n    validPayoutTime,\n    -- The seller gets the highest bid.\n    sellerGetsHighestBid,\n    -- The highest bidder gets the asset.\n    highestBidderGetsAsset\n  ]"
},
{
  "prompt": "Write a script that is a helper within the auction smart contract that checks whether a new bid is high enough to be accepted based on the current highest bid or the minimum bid requirement.",
  "response": "Bid -> Bool\nsufficientBid (Bid _ amt) = case highestBid of\n  Just (Bid _ amt') -> amt PlutusTx.> amt';\n  Nothing -> amt PlutusTx.>= apMinBid params"
}, 
{
  "prompt": "Write a script that checks whether the current time for placing a bid is still valid within the specified auction timeframe.",
  "response": "(validBidTime :: Bool)\nvalidBidTime = to (apEndTime params) `contains` txInfoValidRange txInfo"
},
{
  "prompt": "Write a script that checks whether the previous highest bid should be refunded.",
  "response": "Bool = case highestBid of Nothing -> True; Just (Bid bidder amt) -> case PlutusTx.find (\\o -> txOutAddress o PlutusTx.== pubKeyHashAddress bidder PlutusTx.&& txOutValue o PlutusTx.== lovelaceValue amt) (txInfoOutputs txInfo) of Just _ -> True; Nothing -> PlutusTx.traceError (\"Not found: refund output\")"
},
{
  "prompt": "Write a script that verifies whether a given Bid is correctly represented in the output datum of a transaction.",
  "response": "correctNewDatum bid = case getContinuingOutputs ctx of [o] -> case txOutDatum o of OutputDatum (Datum newDatum) -> case PlutusTx.fromBuiltinData newDatum of Just bid' -> PlutusTx.traceIfFalse ( \"Invalid output datum: expected \" PlutusTx.<> PlutusTx.show bid PlutusTx.<> \", but got \" PlutusTx.<> PlutusTx.show bid' ) (bid PlutusTx.== bid'); Nothing -> PlutusTx.traceError ( \"Failed to decode output datum: \" PlutusTx.<> PlutusTx.show newDatum ); OutputDatumHash _ -> PlutusTx.traceError \"Expected OutputDatum, got OutputDatumHash\"; NoOutputDatum -> PlutusTx.traceError \"Expected OutputDatum, got NoOutputDatum\"; os -> PlutusTx.traceError ( \"Expected exactly one continuing output, got \" PlutusTx.<> PlutusTx.show (PlutusTx.length os) )"
},
{
  "prompt": "Write a script that untyped validator function and a compiled validator script for an auction in the Plutus smart contract framework.",
  "response": "{-# INLINEABLE auctionUntypedValidator #-} auctionUntypedValidator :: AuctionParams -> BuiltinData -> BuiltinData -> BuiltinData -> PlutusTx.BuiltinUnit auctionUntypedValidator params datum redeemer ctx = PlutusTx.check ( auctionTypedValidator params (PlutusTx.unsafeFromBuiltinData datum) (PlutusTx.unsafeFromBuiltinData redeemer) (PlutusTx.unsafeFromBuiltinData ctx) ) auctionValidatorScript :: AuctionParams -> CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> PlutusTx.BuiltinUnit) auctionValidatorScript params = $$(PlutusTx.compile [||auctionUntypedValidator||]) `PlutusTx.unsafeApplyCode` PlutusTx.liftCode plcVersion100 params"
},
{
  "prompt": "Write a script that sets up the foundational elements for developing Plutus smart contracts. It imports necessary libraries and establishes the language extensions required for the Plutus Tx compiler to function correctly.",
  "response": "{-# LANGUAGE DataKinds             #-}{-# LANGUAGE MultiParamTypeClasses #-}{-# LANGUAGE NoImplicitPrelude     #-}{-# LANGUAGE ScopedTypeVariables   #-}{-# LANGUAGE TemplateHaskell       #-}{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:target-version=1.0.0 #-}module BasicPlutusTx where import PlutusCore.Version (plcVersion100) -- Main Plutus Tx module. import PlutusTx -- Builtin functions. import PlutusTx.Builtins -- The Plutus Tx Prelude, discussed further below. import PlutusTx.Prelude -- Setup for doctest examples. -- $setup -- >>> import Tutorial.PlutusTx -- >>> import PlutusTx -- >>> import PlutusCore -- >>> import PlutusCore.Evaluation.Machine.Ck -- >>> import Data.Text.Prettyprint.Doc"
},
{
  "prompt": "Write a script that defines a simple Plutus Tx compiled code for representing the integer value one. It demonstrates the use of the compile function to convert a Haskell expression into a format that can be used in Plutus smart contracts.",
  "response": "integerOne :: CompiledCode Integer {- 'compile' turns the 'TExpQ Integer' into a 'TExpQ (CompiledCode Integer)' and the splice inserts it into the program. -} integerOne = $$(compile {- The quote has type 'TExpQ Integer'. We always use unbounded integers in Plutus Core, so we have to pin down this numeric literal to an ``Integer`` rather than an ``Int``. -} [|| (1 :: Integer) ||]) {- | >>> pretty $ getPlc integerOne (program 1.0.0 (con 1) ) -}"
},
{
  "prompt": "Write a script that defines a simple identity function for integers in the Plutus Tx language. The identity function returns its input without any modification, which serves as a basic example of function compilation in Plutus.",
  "response": "integerIdentity :: CompiledCode (Integer -> Integer) integerIdentity = $$(compile [|| (x:: Integer) -> x ||]) {- | >>> pretty $ getPlc integerIdentity (program 1.0.0 (lam ds (con integer) ds) ) -}"
},
{
  "prompt": "Write a script that defines a simple Plutus program that demonstrates function definitions and their use within the Plutus Tx framework.",
  "response": "{- Functions which will be used in Plutus Tx programs should be marked with GHCs 'INLINABLE' pragma. This is usually necessary for non-local functions to be usable in Plutus Tx blocks, as it instructs GHC to keep the information that the Plutus Tx compiler needs. While you may be able to get away with omitting it, it is good practice to always include it. -} {-# INLINABLE plusOne #-} plusOne :: Integer -> Integer {- 'addInteger' comes from 'PlutusTx.Builtins', and is mapped to the builtin integer addition function in Plutus Core. -} plusOne x = x `addInteger` 1 {-# INLINABLE myProgram #-} myProgram :: Integer myProgram = let plusOneLocal :: Integer -> Integer plusOneLocal x = x `addInteger` 1 localTwo = plusOneLocal 1 externalTwo = plusOne 1 in localTwo `addInteger` externalTwo functions :: CompiledCode Integer functions = $$(compile [|| myProgram ||]) {- Weve used the CK evaluator for Plutus Core to evaluate the program and check that the result was what we expected. -} {- | >>> pretty $ unsafeEvaluateCk $ toTerm $ getPlc functions (con 4) -}"
},
{
  "prompt": "Write a script that defines a Plutus program that demonstrates how to work with the Maybe type in Haskell.",
  "response": "matchMaybe :: CompiledCode (Maybe Integer -> Integer) = $$(compile [|| \\(x:: Maybe Integer) -> case x of Just n  -> n; Nothing -> 0 ||])"
},
{
  "prompt": "Write a script that defines a data type and a function in Plutus that deals with end dates, either as a specific fixed date or an indication that there is no end date (i.e., 'never').",
  "response": "data EndDate = Fixed Integer | Never; pastEnd :: CompiledCode (EndDate -> Integer -> Bool) = $$(compile [|| \\(end::EndDate) (current::Integer) -> case end of Fixed n -> n `lessThanEqualsInteger` current; Never   -> False ||])"
},
{
  "prompt": "Write a script that checks whether a given time is past the end date.",
  "response": "'pastEnd' :: CompiledCode (EndDate -> Integer -> Bool) = $$(compile [|| \\(end::EndDate) (current::Integer) -> case end of Fixed n -> n < current; Never   -> False ||])"
},
]
