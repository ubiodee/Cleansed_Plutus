{"text": "<s>[INST] What does the following Haskell Plutus smart contract code implement, and how does it work? [/INST]This Haskell Plutus smart contract implements an n-out-of-m multisig (multi-signature) scheme that allows multiple participants (m signatories) to propose and authorize payments, where at least n participants' signatures are required to release the funds. The contract manages state transitions through a state machine, tracking when a payment proposal is made, when signatures are added, and when payments are executed. The contract uses off-chain and on-chain code to achieve this.","detailed_explanation": {"language_extensions": ["{-# LANGUAGE DeriveGeneric #-}","{-# LANGUAGE MultiParamTypeClasses #-}"],"imports": ["Control.Lens (makeClassyPrisms)","qualified Ledger.Interval as Interval","GHC.Generics (Generic)","Ledger.Validation (PendingTx, PendingTx'(..))","qualified Ledger.Validation as Validation","qualified Ledger.Typed.Scripts as Scripts","Ledger.Value (Value)","qualified Ledger.Value as Value","Ledger (PubKey, Slot)","Playground.Contract (printSchemas, ensureIotsDefinitions, ensureKnownCurrencies, KnownCurrency, mkSchemaDefinitions, ToSchema)","qualified Language.PlutusTx as PlutusTx","Language.Plutus.Contract","Language.Plutus.Contract.StateMachine (ValueAllocation(..), AsSMContractError, StateMachine(..))","qualified Language.Plutus.Contract.StateMachine as SM","qualified Language.Plutus.Contract.Tx as Tx","Language.PlutusTx.Prelude hiding (check, Applicative (..), (<>))","qualified Prelude as Haskell"],"concepts_implemented": [{"concept": "Payment Structure","description": "Defines a `Payment` structure that holds the amount to be paid, the recipient's public key, and the deadline by which signatures must be collected."},{"concept": "State Transitions","description": "The smart contract transitions between states (such as Holding and CollectingSignatures) depending on whether a payment has been proposed or signatures are being collected."},{"concept": "Multisig Scheme","description": "The contract checks whether a minimum number of required signatures have been collected, and only allows the transaction to proceed if the required signatories agree."},{"concept": "State Machine Logic","description": "The contract operates as a state machine where actions like proposing payments, adding signatures, canceling payments, and making payments all trigger state transitions."},{"concept": "Input and Output Validation","description": "The contract ensures that the funds are preserved correctly and paid to the right addresses by verifying signatures and checking the validity of payment proposals."},{"concept": "Error Handling","description": "Defines custom error types (`MultiSigError`) and uses lenses (`makeClassyPrisms`) for extensibility and error handling."}],"data_types": [{"type": "Payment","fields": {"paymentAmount": "Value","paymentRecipient": "PubKey","paymentDeadline": "Slot"},"description": "Represents a payment proposal including amount, recipient, and deadline."},{"type": "Params","fields": {"mspSignatories": "[PubKey]","mspRequiredSigs": "Integer"},"description": "Represents the parameters of the multisig contract, including the list of signatories and the required number of signatures."},{"type": "State","variants": ["Holding Value","CollectingSignatures Value Payment [PubKey]"],"description": "The state of the contract, either holding funds or collecting signatures for a proposed payment."},{"type": "Input","variants": ["ProposePayment Payment","AddSignature PubKey","Cancel","Pay"],"description": "Represents the inputs to the state machine, including proposing payments, adding signatures, canceling, and paying."}],"core_functions": [{"function": "isSignatory","description": "Checks if a given public key is one of the authorized signatories."},{"function": "isValidProposal","description": "Validates whether a proposed payment can be made with the current locked funds."},{"function": "proposalExpired","description": "Checks if the deadline for a proposed payment has passed."},{"function": "step","description": "Defines the state transitions based on inputs like proposing a payment, adding a signature, or making the payment."},{"function": "check","description": "Ensures that inputs and transactions are valid by checking conditions such as whether enough signatures are collected and whether the funds are preserved."}],"smart_contract_flow": {"initial_state": "Holding funds","transitions": ["ProposePayment: Transitions to CollectingSignatures with the proposed payment and an empty signature list.","AddSignature: Adds the signer's public key to the list of collected signatures.","Cancel: Cancels the current proposal if the deadline is passed, returning to the Holding state.","Pay: Moves to the Holding state after transferring the value to the recipient."]},"onchain_validation": {"mkValidator": "This function checks whether the transaction complies with the contract's logic (valid signatures, valid proposals, etc.)","validatorCode": "Compiles the validation logic into Plutus Core, the low-level language of the Plutus platform."},"schema_definitions": [{"name": "MultiSigSchema","endpoints": ["propose-payment","add-signature","cancel-payment","pay","lock"],"description": "The schema defines the endpoints for proposing a payment, adding a signature, canceling, making a payment, and locking funds."}],"full_code": "```haskell\n{-# LANGUAGE DeriveGeneric #-}{-# LANGUAGE MultiParamTypeClasses #-}import Control.Lens (makeClassyPrisms)import qualified Ledger.Interval as Intervalimport GHC.Generics (Generic)import Ledger.Validation (PendingTx, PendingTx'(..))import qualified Ledger.Validation as Validationimport qualified Ledger.Typed.Scripts as Scriptsimport Ledger.Value (Value)import qualified Ledger.Value as Valueimport Ledger (PubKey, Slot)import Playground.Contract (printSchemas, ensureIotsDefinitions, ensureKnownCurrencies, KnownCurrency, mkSchemaDefinitions, ToSchema)import qualified Language.PlutusTx as PlutusTximport Language.Plutus.Contractimport Language.Plutus.Contract.StateMachine (ValueAllocation(..), AsSMContractError, StateMachine(..))import qualified Language.Plutus.Contract.StateMachine as SMimport qualified Language.Plutus.Contract.Tx as Tximport Language.PlutusTx.Prelude hiding (check, Applicative (..), (<>))import qualified Prelude as Haskell --   $multisig --   The n-out-of-m multisig contract works like a joint account of --   m people, requiring the consent of n people for any payments. --   In the smart contract the signatories are represented by public keys, --   and approval takes the form of signatures on transactions. -- --   The multisig contract in --   'Language.PlutusTx.Coordination.Contracts.MultiSig' expects n signatures on --   a single transaction. This requires an off-chain communication channel. The --   multisig contract implemented in this module uses a proposal system that --   allows participants to propose payments and attach their signatures to --   proposals over a period of time, using separate transactions. All contract --   state is kept on the chain so there is no need for off-chain communication. -- | A proposal for making a payment under the multisig scheme. data Payment = Payment { paymentAmount :: Value , paymentRecipient :: PubKey , paymentDeadline :: Slot } deriving stock (Show, Generic) deriving anyclass (ToSchema)instance Eq Payment where {-# INLINABLE (==) #-}(Payment vl pk sl) == (Payment vl' pk' sl') = vl == vl' && pk == pk' && sl == sl' data Params = Params { mspSignatories :: [PubKey] , mspRequiredSigs :: Integer } -- | State of the multisig contract. data State = Holding Value | CollectingSignatures Value Payment [PubKey] deriving (Show)instance Eq State where {-# INLINABLE (==) #-}(Holding v) == (Holding v') = v == v'(CollectingSignatures vl pmt pks) == (CollectingSignatures vl' pmt' pks') = vl == vl' && pmt == pmt' && pks == pks' _ == _ = False data Input = ProposePayment Payment | AddSignature PubKey | Cancel | Pay deriving Show data MultiSigError = MSContractError ContractError | MSStateMachineError (SM.SMContractError State Input) deriving Show makeClassyPrisms ''MultiSigErrorinstance AsContractError MultiSigError where _ContractError = _MSContractErrorinstance AsSMContractError MultiSigError State Input where _SMContractError = _MSStateMachineError type MultiSigSchema = BlockchainActions .\/ Endpoint "propose-payment" Payment .\/ Endpoint "add-signature" () .\/ Endpoint "cancel-payment" () .\/ Endpoint "pay" () .\/ Endpoint "lock" Value{-# INLINABLE isSignatory #-}isSignatory :: PubKey -> Params -> BoolisSignatory pk (Params sigs _) = any (\pk' -> pk == pk') sigs{-# INLINABLE containsPk #-}containsPk :: PubKey -> [PubKey] -> BoolcontainsPk pk = any (\pk' -> pk' == pk'){-# INLINABLE isValidProposal #-}isValidProposal :: Value -> Payment -> BoolisValidProposal vl (Payment amt _ _) = amt `Value.leq` vl{-# INLINABLE proposalExpired #-}proposalExpired :: PendingTx -> Payment -> BoolproposalExpired PendingTx{pendingTxValidRange} Payment{paymentDeadline} = paymentDeadline `Interval.before` pendingTxValidRange{-# INLINABLE proposalAccepted #-}proposalAccepted :: Params -> [PubKey] -> BoolproposalAccepted (Params signatories numReq) pks = let numSigned = length (filter (\pk -> containsPk pk signatories) pks) in numSigned >= numReq{-# INLINABLE check #-}check :: Params -> Payment -> State -> [Input] -> Boolcheck params payment state inputs = case (state, inputs) of (Holding _, [ProposePayment pmt]) -> isValidProposal (valueLocked state) pmt && proposalExpired (PendingTx{..}) pmt (CollectingSignatures vl pmt pks, [AddSignature pk]) -> isSignatory pk params && not (containsPk pk pks) (CollectingSignatures vl pmt pks, [Cancel]) -> proposalExpired (PendingTx{..}) pmt (CollectingSignatures vl pmt pks, [Pay]) -> proposalAccepted params pks (CollectingSignatures vl pmt pks, [Cancel]) -> proposalExpired (PendingTx{..}) pmt _ -> False{-# INLINABLE step #-}step :: Params -> State -> Input -> Maybe Statestep params state input = case (state, input) of (Holding vl, ProposePayment pmt) -> Just (CollectingSignatures vl pmt []) (CollectingSignatures vl pmt pks, AddSignature pk) -> Just (CollectingSignatures vl pmt (pk : pks)) (CollectingSignatures vl pmt pks, Cancel) -> if proposalExpired (PendingTx{..}) pmt then Just (Holding vl) else Nothing (CollectingSignatures vl pmt pks, Pay) -> if proposalAccepted params pks then Just (Holding (valueLocked state - paymentAmount pmt)) else Nothing _ -> Nothing{-# INLINABLE mkValidator #-}mkValidator :: Params -> State -> Input -> Validation (MultiSigError) ()mkValidator params state input = let check' = check params payment state inputs step' = step params state input in if check' then Validation.valid else Validation.invalid (MSStateMachineError step'){-# INLINABLE mkSchemaDefinitions #-}mkSchemaDefinitions :: [TypeRep]mkSchemaDefinitions = [typeRep (Proxy :: Proxy MultiSigSchema)]{-# INLINABLE validatorCode #-}validatorCode :: Scripts.TypedValidator MultiSigValidator.validatorCode = Scripts.mkTypedValidator @MultiSigValidator $$(PlutusTx.compile [|| mkValidator ||]) $$(PlutusTx.compile [|| wrap ||]){-# INLINABLE wrap #-}wrap :: Scripts.ValidatorTypes MultiSigValidator.wrap = Scripts.wrapValidator @Params @State @Input{-# INLINABLE endPoints #-}endPoints :: Contract () MultiSigSchema Text ()endPoints = Contract.selectList [proposePayment, addSignature, cancelPayment, pay, lock] >>= \case (Left err) -> Contract.throwError err (Right _) -> Contract.logInfo @Text "No endpoint selected" .@endpoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endPoints .@ endpoints"}}<s>"},
{"text": "<s>[INST] Write a script that is designed to automate the process of submitting a Cardano transaction on a Testnet. [/INST] This script handles querying protocol parameters, building a transaction, signing it, and submitting it to the network. After submission, it retrieves and prints the transaction ID and provides a link to view the transaction on CardanoScan. The script first queries the protocol parameters and saves them to `protocol-parameters.json`. It then builds the transaction by specifying the input, script file, datum, redeemer, collateral, change address, and protocol parameters, saving the transaction body to `collect-gift.txbody`. Next, it signs the transaction using the signing key and saves it to `collect-gift.tx`. Finally, it submits the transaction to the testnet and prints the transaction ID and a CardanoScan link to view the transaction status. "Code": #!/bin/bash assets=/workspaces/plutus-pioneer-program/code/Week02/assets keypath=/workspaces/plutus-pioneer-program/keys name=\"$1\" collateral=\"$2\" txin=\"$3\" pp=\"$assets/protocol-parameters.json\" body=\"$assets/collect-gift.txbody\" tx=\"$assets/collect-gift.tx\" # Query the protocol parameters \\ cardano-cli query protocol-parameters \\ --testnet-magic 2 \\ --out-file \"$pp\" # Build the transaction cardano-cli transaction build \\ --babbage-era \\ --testnet-magic 2 \\ --tx-in \"$txin\" \\ --tx-in-script-file \"$assets/gift.plutus\" \\ --tx-in-inline-datum-present \\ --tx-in-redeemer-file \"$assets/unit.json\" \\ --tx-in-collateral \"$collateral\" \\ --change-address \"$(cat \"$keypath/$name.addr\")\" \\ --protocol-params-file \"$pp\" \\ --out-file \"$body\" # Sign the transaction cardano-cli transaction sign \\ --tx-body-file \"$body\" \\ --signing-key-file \"$keypath/$name.skey\" \\ --testnet-magic 2 \\ --out-file \"$tx\" # Submit the transaction cardano-cli transaction submit \\ --testnet-magic 2 \\ --tx-file \"$tx\" tid=$(cardano-cli transaction txid --tx-file \"$tx\") echo \"transaction id: $tid\" echo \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\" </s>"},
{"text": "<s>[INST] Write a script that is used to automate the process of building, signing, and submitting a Cardano transaction on a testnet. [/INST] The script starts by building a gift address from a payment script file and saving it to `gift.addr`. Then, it constructs a transaction by specifying inputs, outputs, inline datum, and change address, saving the transaction body to `gift.txbody`. The script signs the transaction with the provided signing key and saves the signed transaction to `gift.tx`. Finally, it submits the transaction to the testnet and prints the transaction ID and a CardanoScan link to view the transaction status."Code": #!/bin/bash assets=/workspaces/plutus-pioneer-program/code/Week02/assets keypath=/workspaces/plutus-pioneer-program/keys name=\"$1\" txin=\"$2\" body=\"$assets/gift.txbody\" tx=\"$assets/gift.tx\" # Build gift address cardano-cli address build \\ --payment-script-file \"$assets/gift.plutus\" \\ --testnet-magic 2 \\ --out-file \"$assets/gift.addr\" # Build the transaction cardano-cli transaction build \\ --babbage-era \\ --testnet-magic 2 \\ --tx-in \"$txin\" \\ --tx-out \"$(cat \"$assets/gift.addr\") + 3000000 lovelace\" \\ --tx-out-inline-datum-file \"$assets/unit.json\" \\ --change-address \"$(cat \"$keypath/$name.addr\")\" \\ --out-file \"$body\" # Sign the transaction cardano-cli transaction sign \\ --tx-body-file \"$body\" \\ --signing-key-file \"$keypath/$name.skey\" \\ --testnet-magic 2 \\ --out-file \"$tx\" # Submit the transaction cardano-cli transaction submit \\ --testnet-magic 2 \\ --tx-file \"$tx\" tid=$(cardano-cli transaction txid --tx-file \"$tx\") echo \"transaction id: $tid\" echo \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\" </s>"},
{"text": "<s>[INST] Write a script that validates if and only if the two Booleans in the redeemer are True. [/INST] This script is a Plutus on-chain validator that ensures two boolean values (redeemer inputs) are both True for the transaction to be considered valid. "Code": {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} {-# LANGUAGE OverloadedStrings   #-} module Homework1 where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (compile) import PlutusTx.Prelude (Bool (..), BuiltinData, traceIfFalse, ($), (&&)) import Utilities (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkValidator #-} -- This should validate if and only if the two Booleans in the redeemer are True! mkValidator :: () -> (Bool, Bool) -> PlutusV2.ScriptContext -> Bool mkValidator _ (a, b) _ = traceIfFalse \"One or more bools are not true\" $ a && b wrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedVal = wrapValidator mkValidator validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||]) </s>"},
{"text": "<s>[INST] Write a script that creates a validator that unlocks the funds if MyRedemeer's flags are different. [/INST] This script defines a validator that unlocks funds only if the two Boolean flags (flag1 and flag2) in the custom data type MyRedeemer are different. If the flags are the same, the validator will reject the transaction. "Code": {-# LANGUAGE DataKinds           #-} {-# LANGUAGE DeriveAnyClass      #-} {-# LANGUAGE DeriveGeneric       #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} {-# LANGUAGE OverloadedStrings   #-} module Homework2 where import qualified Plutus.V2.Ledger.Api as PlutusV2 import           PlutusTx             (unstableMakeIsData,compile) import           PlutusTx.Prelude     (Bool, BuiltinData, traceIfFalse, ($), (/=)) import           Utilities            (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MyRedeemer = MyRedeemer { flag1 :: Bool , flag2 :: Bool } PlutusTx.unstableMakeIsData ''MyRedeemer {-# INLINABLE mkValidator #-} -- Create a validator that unlocks the funds if MyRedemeer's flags are different mkValidator :: () -> MyRedeemer -> PlutusV2.ScriptContext -> Bool mkValidator _ myRed _ = traceIfFalse \"flags are not different\" $ flag1 myRed /= flag2 myRed wrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedVal = wrapValidator mkValidator validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||]) </s>"},
{"text": "<s>[INST] Write a script validator that always fails. [/INST] This script defines a validator that always fails, effectively preventing any transaction from succeeding when this validator is used. This kind of script is often referred to as a "burn" validator because it effectively locks funds permanently, making them unspendable. "Code": {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module Burn where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import PlutusTx.Prelude (traceError) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator always fails --                    Datum         Redeemer     ScriptContext mkBurnValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkBurnValidator _ _ _ = traceError \"it burns!!!\" {-# INLINABLE mkBurnValidator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkBurnValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/burn.plutus\" validator </s>"},
{"text": "<s>[INST] Write a script validator that succeeds only if the redeemer is `MkMySillyRedeemer 42 [/INST] This script defines a Plutus smart contract validator that only succeeds if the redeemer passed to it is exactly MkMySillyRedeemer 42. "Code": {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module CustomTypes where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile, unstableMakeIsData) import PlutusTx.Prelude (Bool, Eq ((==)), Integer, traceIfFalse, ($)) import Prelude (IO) import Utilities (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- We can create custom data types for our datum and redeemer like this: newtype MySillyRedeemer = MkMySillyRedeemer Integer PlutusTx.unstableMakeIsData ''MySillyRedeemer -- Use TH to create an instance for IsData. -- This validator succeeds only if the redeemer is `MkMySillyRedeemer 42` --              Datum     Redeemer            ScriptContext mkCTValidator :: () -> MySillyRedeemer -> PlutusV2.ScriptContext -> Bool mkCTValidator _ (MkMySillyRedeemer r) _ = traceIfFalse \"expected 42\" $ r == 42 {-# INLINABLE mkCTValidator #-} wrappedMkVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedMkVal = wrapValidator mkCTValidator {-# INLINABLE wrappedMkVal #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedMkVal ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/customtypes.plutus\" validator"<s>"},
{"text": "<s>[INST] Write a script validator that succeeds only if the redeemer is 42 [/INST] This script defines a simple Plutus validator that ensures a specific condition: it only succeeds if the redeemer passed to it equals 42. If any other value is provided, it returns an error, effectively locking the transaction. "Code": {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module FortyTwo where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import PlutusTx.Builtins as Builtins (mkI) import PlutusTx.Prelude (otherwise, traceError, (==)) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator succeeds only if the redeemer is 42 --                  Datum         Redeemer     ScriptContext mk42Validator :: BuiltinData -> BuiltinData -> BuiltinData -> () mk42Validator _ r _ | r == Builtins.mkI 42 = () | otherwise            = traceError \"expected 42\" {-# INLINABLE mk42Validator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mk42Validator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/fortytwo.plutus\" validator"<s>"},
{"text": "<s>[INST] Write a script validator that always succeeds [/INST] This script defines a very straightforward Plutus validator that always succeeds. It effectively allows any transaction that invokes it to go through without any conditions. This could be useful in scenarios where you want to create a simple, unconditional access point, such as in a gifting mechanism where anyone can claim a gift without any restrictions. "Code": {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} module Gift where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- -------------------------------- ON-CHAIN CODE / VALIDATOR ---------------------------------------- -- This validator always succeeds --                    Datum         Redeemer     ScriptContext mkGiftValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkGiftValidator _ _ _ = () {-# INLINABLE mkGiftValidator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkGiftValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/gift.plutus\" validator"<s>"},
{"text": "<s>[INST] Write a script that validates if either beneficiary1 has signed the transaction and the current slot is before or at the deadline or if beneficiary2 has signed the transaction and the deadline has passed. [/INST] This code implements a vesting validator that allows two beneficiaries to unlock funds based on specific timing conditions. Beneficiary 1 can unlock funds before or at a certain deadline, while Beneficiary 2 can do so only after the deadline has passed. This setup is commonly used in financial contracts to ensure that funds are released according to predefined conditions, enhancing security and trust in the transaction process. "Code": {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} {-# LANGUAGE TypeApplications  #-} {-# LANGUAGE TypeFamilies      #-} module Homework1 where import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts (txSignedBy) import Plutus.V1.Ledger.Interval import PlutusTx (compile, unstableMakeIsData) import PlutusTx.Prelude (traceIfFalse, Bool(..), (||), (&&), (+)) import Utilities (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingDatum = VestingDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime } unstableMakeIsData ''VestingDatum {-# INLINABLE mkVestingValidator #-} -- This should validate if either beneficiary1 has signed the transaction and the current slot is before or at the deadline -- or if beneficiary2 has signed the transaction and the deadline has passed. mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool mkVestingValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE  mkWrappedVestingValidator #-} mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedVestingValidator = wrapValidator mkVestingValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||])"<s>"},
{"text": "<s>[INST] Write a script that validates if the transaction has a signature from the parameterized beneficiary and the deadline has passed. [/INST] This code creates a parameterized vesting validator that allows a specified beneficiary to unlock funds only after a certain deadline. It provides flexibility by accepting different beneficiaries and deadlines, making it useful in various financial contracts. The use of trace messages aids in debugging by providing feedback when the validator's conditions are not met. "Code": {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module Homework2 where import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts import Plutus.V1.Ledger.Interval import PlutusTx (applyCode, compile, liftCode) import PlutusTx.Prelude (Bool(..), (.), traceIfFalse, (&&)) import Utilities (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkParameterizedVestingValidator #-} -- This should validate if the transaction has a signature from the parameterized beneficiary and the deadline has passed. mkParameterizedVestingValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkParameterizedVestingValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkSig :: Bool checkSig = txSignedBy txInfo beneficiary checkDeadline :: Bool checkDeadline = contains (from deadline) txValidRange {-# INLINABLE  mkWrappedParameterizedVestingValidator #-} mkWrappedParameterizedVestingValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator validator :: PubKeyHash -> Validator validator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode beneficiary)"<s>"},
{"text": "<s>[INST] Write a script validator that determines if a transaction has been signed by a specific beneficiary and if the deadline for that beneficiary has passed [/INST] This code implements a vesting mechanism that restricts access to funds until a specified deadline and verifies that only the intended beneficiary can access those funds. The use of trace messages aids in debugging and provides clear feedback in case of validation failures. The utility functions help manage the validator's deployment and user interactions, making it a practical implementation for decentralized finance applications. "Code": {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module ParameterizedVesting where import           Plutus.V1.Ledger.Interval (contains) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (applyCode, compile, liftCode, makeLift) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (.) ) import           Prelude                   (IO) import           Utilities                 (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingParams = VestingParams { beneficiary :: PubKeyHash , deadline    :: POSIXTime } makeLift ''VestingParams {-# INLINABLE mkParameterizedVestingValidator #-} mkParameterizedVestingValidator :: VestingParams -> () -> () -> ScriptContext -> Bool mkParameterizedVestingValidator params () () ctx = traceIfFalse \"beneficiary's signature missing\" signedByBeneficiary && traceIfFalse \"deadline not reached\" deadlineReached where info :: TxInfo info = scriptContextTxInfo ctx signedByBeneficiary :: Bool signedByBeneficiary = txSignedBy info $ beneficiary params deadlineReached :: Bool deadlineReached = contains (from $ deadline params) $ txInfoValidRange info {-# INLINABLE  mkWrappedParameterizedVestingValidator #-} mkWrappedParameterizedVestingValidator :: VestingParams -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator validator :: VestingParams -> Validator validator params = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode params) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: VestingParams -> IO () saveVal = writeValidatorToFile \"./assets/parameterized-vesting.plutus\" . validator"<s>"},
{"text": "<s>[INST] Write a script validator that provides a comprehensive testing framework for two vesting smart contracts built on the Plutus platform.[/INST] This code provides a comprehensive testing framework for two vesting smart contracts built on the Plutus platform. It systematically verifies that the contracts enforce the specified rules regarding beneficiary signatures and deadlines, ensuring correct behavior under various scenarios. The modular approach with separate test functions and a clear structure allows for easy understanding and maintenance of the tests. "Code":{-# LANGUAGE NumericUnderscores #-} module Main where import Control.Monad (replicateM) import Plutus.Model import Plutus.Model.Fork.Ledger.Slot (Slot) import Plutus.V2.Ledger.Api import Prelude import Test.Tasty import qualified Homework1 as H1 import qualified Homework2 as H2 type Homework1Script = TypedValidator H1.VestingDatum () script1 :: Homework1Script script1 = TypedValidator $ toV2 H1.validator type Homework2Script = TypedValidator POSIXTime () script2 :: PubKeyHash -> Homework2Script script2 = TypedValidator . toV2 . H2.validator setupUsers :: Run [PubKeyHash] setupUsers = replicateM 3 $ newUser $ ada (Lovelace 1000) main :: IO () main = do defaultMain $ do testGroup \"Homework tests\" [ testGroup \"All times are in POSIXTime (Not slots)\" [ homework1 defaultBabbage , homework2 defaultBabbage ] ] homework1 :: MockConfig -> TestTree homework1 cfg = testGroup \"Testing Homework1\" [ testGroup \"Beneficiary 1 signing\" [ good \"Deadline: 6000; TxValidRange (5000, 5999)\" $ testBeneficiary1 6000 (-999) 0 0 , good \"Deadline: 6000; TxValidRange (5000, 6000)\" $ testBeneficiary1 6000 (-999) 1 0 , good \"Deadline: 6000; TxValidRange (5000, 6999)\" $ testBeneficiary1 6000 (-999) 1000 0 , good \"Deadline: 6000; TxValidRange (5999, 6001)\" $ testBeneficiary1 6000 0 2 0 , good \"Deadline: 6000; TxValidRange (6999, 6999)\" $ testBeneficiary1 6000 0 0 1 , bad \"Deadline: 6000; TxValidRange (7000, 8000)\" $ testBeneficiary1 6000 1 1001 1 , bad \"Deadline: 6000; TxValidRange (5000, 7000)\" $ testBeneficiary1 6000 (-999) 1001 0 , bad \"Deadline: 6000; TxValidRange (6000, 7000)\" $ testBeneficiary1 6000 (-999) 1 1 , bad \"Deadline: 6000; TxValidRange (6999, 7000)\" $ testBeneficiary1 6000 0 1 1 ] , testGroup \"Beneficiary 2 signing\" [ good \"Deadline: 5000; TxValidRange (6000, 7000)\" $ testBeneficiary2 5000 (-999) 1 1 , good \"Deadline: 4999; TxValidRange (5000, 6000)\" $ testBeneficiary2 4999 (-999) 1 0 , bad \"Deadline: 6000; TxValidRange (5000, 5999)\" $ testBeneficiary2 6000 (-999) 0 0 , bad \"Deadline: 5000; TxValidRange (5000, 6000)\" $ testBeneficiary2 5000 (-999) 1 0 , bad \"Deadline: 5000; TxValidRange (5001, 6000)\" $ testBeneficiary2 5000 (-998) 1 0 , bad \"Deadline: 5000; TxValidRange (5999, 6000)\" $ testBeneficiary2 5000 0 1 0 ] , bad \"None signing\" $ testNoSigning 5000 0 0 0 ] where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000) cfg testBeneficiary1 :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run () testBeneficiary1 deadline curMinT curMaxT wSlot = do users <- setupUsers let [u1, u2, u3] = users dat = H1.VestingDatum u1 u2 deadline testHomework1 u1 u3 dat curMinT curMaxT wSlot testBeneficiary2 :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run () testBeneficiary2 deadline curMinT curMaxT wSlot = do users <- setupUsers let [u1, u2, u3] = users dat = H1.VestingDatum u1 u2 deadline testHomework1 u2 u3 dat curMinT curMaxT wSlot testNoSigning :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run () testNoSigning deadline curMinT curMaxT wSlot = do users <- setupUsers let [u1, u2, u3] = users dat = H1.VestingDatum u1 u2 deadline testHomework1 u3 u3 dat curMinT curMaxT wSlot testHomework1 :: PubKeyHash -> PubKeyHash -> H1.VestingDatum -> POSIXTime -> POSIXTime -> Slot -> Run () testHomework1 sigUser receiver dat curMinT curMaxT wSlot = do let val = adaValue 100 checkBalance (gives sigUser val script1) $ do sp <- spend sigUser val submitTx sigUser $ vestingTx1 dat sp val waitNSlots wSlot utxos <- utxoAt script1 let [(vestRef, vestOut)] = utxos checkBalance (gives script1 (txOutValue vestOut) receiver) $ do range <- currentTimeInterval curMinT curMaxT tx <- validateIn range $ claimingTx1 receiver dat vestRef (txOutValue vestOut) submitTx sigUser tx vestingTx1 :: H1.VestingDatum -> UserSpend -> Value -> Tx vestingTx1 dat usp val = mconcat [ userSpend usp , payToScript script1 (HashDatum dat) val ] claimingTx1 :: PubKeyHash -> H1.VestingDatum -> TxOutRef -> Value -> Tx claimingTx1 pkh dat vestRef vestVal = mconcat [ spendScript script1 vestRef () dat , payToKey pkh vestVal ] homework2 :: MockConfig -> TestTree homework2 cfg = testGroup \"Testing Homework2\" [ good \"Deadline: 5000; TxValidRange (6000, 7000)\" $ testHomework2 5000 (-999) 1 1 , good \"Deadline: 5000; TxValidRange (5000, 5000)\" $ testHomework2 5000 (-999) (-999) 0 , good \"Deadline: 5000; TxValidRange (5000, 6000)\" $ testHomework2 5000 (-999) 1 0 , good \"Deadline: 5000; TxValidRange (5001, 6000)\" $ testHomework2 5000 (-998) 1 0 , good \"Deadline: 5000; TxValidRange (5999, 6000)\" $ testHomework2 5000 0 1 0 , bad \"Deadline: 5000; TxValidRange (4000, 5000)\" $ testHomework2 5000 (-1999) (-999) 0 , bad \"Deadline: 5000; TxValidRange (4999, 5000)\" $ testHomework2 5000 (-1000) (-999) 0 , bad \"Deadline: 5000; TxValidRange (4999, 5999)\" $ testHomework2 5000 (-1000) 0 0 ] where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000) cfg testHomework2 :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run () testHomework2 dat curMinT curMaxT wSlot = do users <- setupUsers let [u1, u2, _u3] = users val = adaValue 100 checkBalance (gives u1 val $ script2 u2) $ do sp <- spend u1 val submitTx u1 $ vestingTx2 u2 dat sp val waitNSlots wSlot utxos <- utxoAt $ script2 u2 let [(vestRef, vestOut)] = utxos checkBalance (gives (script2 u2) (txOutValue vestOut) u2) $ do range <- currentTimeInterval curMinT curMaxT tx <- validateIn range $ claimingTx2 u2 dat vestRef (txOutValue vestOut) submitTx u2 tx vestingTx2 :: PubKeyHash -> POSIXTime -> UserSpend -> Value -> Tx vestingTx2 pkh dat usp val = mconcat [ userSpend usp , payToScript (script2 pkh) (HashDatum dat) val ] claimingTx2 :: PubKeyHash -> POSIXTime -> TxOutRef -> Value -> Tx claimingTx2 receiver dat vestRef vestVal = mconcat [ spendScript (script2 receiver) vestRef () dat , payToKey receiver vestVal ]<s>"},
{"text": "<s>[INST] Write a script that figures out what this (already finished) validator does using all the tools at your disposal and also write off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. [/INST] This code implements a simple vesting mechanism where two beneficiaries must sign a transaction within specified time frames, ensuring controlled access to funds based on their signatures and timing conditions. The provided helper functions facilitate saving the validator and outputting data in a user-friendly format. "Code":{-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} {-# LANGUAGE TypeApplications  #-} {-# LANGUAGE TypeFamilies      #-} module Homework1 where import           Data.Maybe                (fromJust) import           Plutus.V1.Ledger.Interval (contains, to) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, POSIXTimeRange, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (compile, unstableMakeIsData) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (+), (||)) import           Prelude                   (IO, String) import           Utilities                 (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MisteryDatum = MisteryDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime } unstableMakeIsData ''MisteryDatum {-# INLINABLE mkMisteryValidator #-} mkMisteryValidator :: MisteryDatum -> () -> ScriptContext -> Bool mkMisteryValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE  mkWrappedMisteryValidator #-} mkWrappedMisteryValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedMisteryValidator = wrapValidator mkMisteryValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedMisteryValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/mistery1.plutus\" validator misteryAddressBech32 :: Network -> String misteryAddressBech32 network = validatorAddressBech32 network validator printMisteryDatumJSON :: PubKeyHash -> PubKeyHash -> String -> IO () printMisteryDatumJSON pkh1 pkh2 time = printDataToJSON $ MisteryDatum { beneficiary1 = pkh1 , beneficiary2 = pkh2 , deadline    = fromJust $ posixTimeFromIso8601 time }<s>"},
{"text": "<s>[INST] Write a script that sets blockfrost endpoint, loads local stored seed as a wallet into lucid, defines the vesting plutus script, creates the vesting datum type, sets the vesting deadline, sets the vesting beneficiary to our own key, creating a datum with a beneficiary and deadline, and asynchronous function that sends an amount of Lovelace to the script with the above datum. [/INST] This code sets up a vesting mechanism on the Cardano blockchain, allowing a specified amount of cryptocurrency to be locked until a defined deadline, after which the designated beneficiary can claim the funds. "Code": import { Data, Lucid, Blockfrost, getAddressDetails, SpendingValidator, TxHash, Datum, UTxO, Address, AddressDetails, } from "https://deno.land/x/lucid@0.9.1/mod.ts" import { secretSeed } from "./seed.ts" const lucid = await Lucid.new(new Blockfrost("https://cardano-preprod.blockfrost.io/api/v0", "insert you own api key here"), "Preprod"); lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(addr); const vestingScript: SpendingValidator = { type: "PlutusV2", script: "590b30590b2d0100003232323322323233223232323232323233223233223232323232323232333222323232322323222323253353232323253355335323235002222222222222533533355301a12001321233001225335002210031001002502c25335333573466e3c0380040ec0e84d40b8004540b4010840ec40e4d401488009400440b04cd5ce2491f62656e65666963696172792773207369676e6174757265206d697373696e670002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b00300735500322222222222200533501433501635029350052200102d335015502802d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce248114646561646c696e65206e6f7420726561636865640002b102b135001220023333573466e1cd55cea80224000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a008603e6ae84d5d1280211931901519ab9c02d02c0283333573466e1cd55ce9baa0054800080ac8c98c80a4cd5ce0160158139999ab9a3370e6aae7540192000233221233001003002375c6ae854018dd69aba135744a00c464c6405066ae700ac0a809840a44c98c809ccd5ce2490350543500029135573ca00226ea80044d55cf280089baa00132001355023221122253350011350032200122133350052200230040023335530071200100500400112223500222350032253335333500800700400215335003100110261025102612223232323253335006215333500621533350082130044984c00d261533350072130044984c00d26100d100b1533350072130044984c00d261533350062130044984c00d26100c1533350052100a100b100915333500521533350072130054984c011261533350062130054984c01126100c100a1533350062130054984c011261533350052130054984c01126100b2533350052153335007215333500721333500b00a002001161616100b153335006215333500621333500a009002001161616100a10092533350042153335006215333500621333500a009002001161616100a1533350052153335005213335009008002001161616100910082533350032153335005215333500521333500900800200116161610091533350042153335004213335008007002001161616100810072533350022153335004215333500421333500800700200116161610081533350032153335003213335007006002001161616100710061235001222222220071222003122200212220011221233001003002122123300100300212212330010030021232230023758002640026aa034446666aae7c004940288cd4024c010d5d080118019aba200201a232323333573466e1cd55cea80124000466442466002006004601c6ae854008c014d5d09aba2500223263201833573803603402c26aae7940044dd50009191919191999ab9a3370e6aae75401120002333322221233330010050040030023232323333573466e1cd55cea80124000466442466002006004602e6ae854008cd403c058d5d09aba2500223263201d33573804003e03626aae7940044dd50009aba150043335500875ca00e6ae85400cc8c8c8cccd5cd19b875001480108c84888c008010d5d09aab9e500323333573466e1d4009200223212223001004375c6ae84d55cf280211999ab9a3370ea00690001091100191931900f99ab9c02202101d01c01b135573aa00226ea8004d5d0a80119a805bae357426ae8940088c98c8064cd5ce00e00d80b89aba25001135744a00226aae7940044dd5000899aa800bae75a224464460046eac004c8004d5405c88c8cccd55cf80112804119a8039991091980080180118031aab9d5002300535573ca00460086ae8800c0604d5d080088910010910911980080200189119191999ab9a3370ea002900011a80398029aba135573ca00646666ae68cdc3a801240044a00e464c6402866ae7005c0580480444d55cea80089baa0011212230020031122001232323333573466e1d400520062321222230040053007357426aae79400c8cccd5cd19b875002480108c848888c008014c024d5d09aab9e500423333573466e1d400d20022321222230010053007357426aae7940148cccd5cd19b875004480008c848888c00c014dd71aba135573ca00c464c6402466ae7005405004003c0380344d55cea80089baa001232323333573466e1cd55cea80124000466442466002006004600a6ae854008dd69aba135744a004464c6401c66ae700440400304d55cf280089baa0012323333573466e1cd55cea800a400046eb8d5d09aab9e500223263200c33573801e01c01426ea80048c8c8c8c8c8cccd5cd19b8750014803084888888800c8cccd5cd19b875002480288488888880108cccd5cd19b875003480208cc8848888888cc004024020dd71aba15005375a6ae84d5d1280291999ab9a3370ea00890031199109111111198010048041bae35742a00e6eb8d5d09aba2500723333573466e1d40152004233221222222233006009008300c35742a0126eb8d5d09aba2500923333573466e1d40192002232122222223007008300d357426aae79402c8cccd5cd19b875007480008c848888888c014020c038d5d09aab9e500c23263201533573803002e02602402202001e01c01a26aae7540104d55cf280189aab9e5002135573ca00226ea80048c8c8c8c8cccd5cd19b875001480088ccc888488ccc00401401000cdd69aba15004375a6ae85400cdd69aba135744a00646666ae68cdc3a80124000464244600400660106ae84d55cf280311931900719ab9c01101000c00b135573aa00626ae8940044d55cf280089baa001232323333573466e1d400520022321223001003375c6ae84d55cf280191999ab9a3370ea004900011909118010019bae357426aae7940108c98c802ccd5ce00700680480409aab9d50011375400224464646666ae68cdc3a800a40084a00c46666ae68cdc3a8012400446a010600c6ae84d55cf280211999ab9a3370ea00690001091100111931900619ab9c00f00e00a009008135573aa00226ea8004484888c00c010448880048c8cccd5cd19b8750014800880188cccd5cd19b8750024800080188c98c8018cd5ce00480400200189aab9d37540029309100109100089000a490350543100112323001001223300330020020011", }; const vestingAddress: Address = lucid.utils.validatorToAddress(vestingScript); const VestingDatum = Data.Object({ beneficiary: Data.String, deadline: Data.BigInt, }); type VestingDatum = Data.Static<typeof VestingDatum>; const deadlineDate: Date = new Date("2023-03-19T00:00:00Z") const deadlinePosIx = BigInt(deadlineDate.getTime()); const details: AddressDetails = getAddressDetails(addr); const beneficiaryPKH: string = details.paymentCredential.hash; const datum: VestingDatum = { beneficiary: beneficiaryPKH, deadline: deadlinePosIx, }; async function vestFunds(amount: bigint): Promise<TxHash> { const dtm: Datum = Data.to<VestingDatum>(datum, VestingDatum); const tx = await lucid.newTx().payToContract(vestingAddress, { inline: dtm }, { lovelace: amount }).complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); return txHash } async function claimVestedFunds(): Promise<TxHash> { const dtm: Datum = Data.to<VestingDatum>(datum, VestingDatum); const utxoAtScript: UTxO[] = await lucid.utxosAt(vestingAddress); const ourUTxO: UTxO[] = utxoAtScript.filter((utxo) => utxo.datum == dtm); if (ourUTxO && ourUTxO.length > 0) { const tx = await lucid.newTx().collectFrom(ourUTxO, Data.void()).addSignerKey(beneficiaryPKH).attachSpendingValidator(vestingScript).validFrom(Date.now()-100000).complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); return txHash } else return "No UTxO's found that can be claimed" } //console.log(await vestFunds(100000000n)); //console.log(await claimVestedFunds()); <s>"},
{"text": "<s>[INST] Write a script policy that should only allow minting (or burning) of tokens if the owner of the specified PubKeyHash has signed the transaction and if the specified deadline has not passed. [/INST] This script allows tokens to be minted (or burned) only if the specified owner signs the transaction and the deadline is still valid. This ensures that tokens can only be manipulated by the rightful owner within a specified timeframe, making it useful for scenarios like vesting or time-locked assets. "Code":{-# LANGUAGE DataKinds             #-}{-# LANGUAGE MultiParamTypeClasses #-}{-# LANGUAGE NoImplicitPrelude     #-}{-# LANGUAGE OverloadedStrings     #-}{-# LANGUAGE ScopedTypeVariables   #-}{-# LANGUAGE TemplateHaskell       #-}module Homework1 whereimport           Plutus.V2.Ledger.Api import           Plutus.V2.Ledger.Contexts import           Plutus.V1.Ledger.Interval import qualified PlutusTx import           PlutusTx.Prelude     (Bool (..), ($), traceIfFalse, (&&)) import           Utilities            (wrapPolicy, writeCodeToFile, currencySymbol, writePolicyToFile) import           Prelude              (IO, Show (show)) import           Text.Printf          (printf)-------------------------------------------------------------------------------------------------------------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------{-# INLINABLE mkDeadlinePolicy #-}-- This policy should only allow minting (or burning) of tokens if the owner of the specified PubKeyHash-- has signed the transaction and if the specified deadline has not passed.mkDeadlinePolicy :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> BoolmkDeadlinePolicy owner deadline () ctx = traceIfFalse "not signed by owner" checkSig && traceIfFalse "too late: deadline has allready passed" checkDeadline  where    txInfo :: TxInfo    txInfo = scriptContextTxInfo ctx    checkSig :: Bool    checkSig = txSignedBy txInfo owner    txValidRange :: POSIXTimeRange    txValidRange  = txInfoValidRange txInfo    checkDeadline :: Bool    checkDeadline = contains (to deadline) txValidRange{-# INLINABLE mkWrappedDeadlinePolicy #-}mkWrappedDeadlinePolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()mkWrappedDeadlinePolicy pkh deadline = wrapPolicy $ mkDeadlinePolicy pkh' deadline'  where     pkh' :: PubKeyHash    pkh' = PlutusTx.unsafeFromBuiltinData pkh    deadline' :: POSIXTime    deadline' = PlutusTx.unsafeFromBuiltinData deadlinedeadlineCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())deadlineCode = $$(PlutusTx.compile [|| mkWrappedDeadlinePolicy ||])deadlinePolicy :: PubKeyHash -> POSIXTime -> MintingPolicydeadlinePolicy pkh deadline = mkMintingPolicyScript $ deadlineCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData pkh) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData deadline)---------------------------------------------------------------------------------------------------------------------------------------- HELPER FUNCTIONS --------------------------------------------saveDeadlineCode :: IO ()saveDeadlineCode = writeCodeToFile "assets/deadline.plutus"saveDeadlinePolicy :: PubKeyHash -> POSIXTime -> IO ()saveDeadlinePolicy pkh deadline = writePolicyToFile  (printf "assets/deadline-%s.plutus" $ show pkh)  $ deadlinePolicy pkh deadlinedeadlineCurrencySymbol :: PubKeyHash -> POSIXTime -> CurrencySymboldeadlineCurrencySymbol pkh deadline = currencySymbol $ deadlinePolicy pkh deadline <s>"},
{"text": "<s>[INST] Write a script minting policy for an NFT, where the minting transaction must consume the given UTxO as input and where the TokenName will be the empty ByteString. [/INST] This code establishes a minting policy that restricts the creation of NFTs to transactions that consume a specific UTxO and mint exactly one token. It includes utilities for compiling and saving the policy for deployment in a Cardano smart contract. "Code": {-# LANGUAGE DataKinds             #-}{-# LANGUAGE MultiParamTypeClasses #-}{-# LANGUAGE NoImplicitPrelude     #-}{-# LANGUAGE OverloadedStrings     #-}{-# LANGUAGE ScopedTypeVariables   #-}{-# LANGUAGE TemplateHaskell       #-}module Homework2 whereimport           Plutus.V2.Ledger.Api import           Plutus.V1.Ledger.Value (flattenValue) import           Plutus.V2.Ledger.Contexts (ownCurrencySymbol) import qualified PlutusTx import           PlutusTx.Builtins.Internal (emptyByteString) import           PlutusTx.Prelude       (Bool (..), ($), (.), (&&),  (==), any, traceIfFalse) import           Utilities              (wrapPolicy, writeCodeToFile) import           Prelude (IO){-# INLINABLE tn #-}tn :: TokenName  tn = TokenName emptyByteString{-# INLINABLE mkEmptyNFTPolicy #-}-- Minting policy for an NFT, where the minting transaction must consume the given UTxO as input-- and where the TokenName will be the empty ByteString.mkEmptyNFTPolicy :: TxOutRef -> () -> ScriptContext -> BoolmkEmptyNFTPolicy oref () ctx = traceIfFalse "UTxO not consumed"   hasUTxO           &&                               traceIfFalse "wrong amount minted" checkMintedAmount  where    info :: TxInfo    info = scriptContextTxInfo ctx    hasUTxO :: Bool    hasUTxO = any (\i -> txInInfoOutRef i == oref) $ txInfoInputs info    checkMintedAmount :: Bool    checkMintedAmount = case flattenValue (txInfoMint info) of        [(cs, tn', amt)] -> cs  == ownCurrencySymbol ctx && tn' == tn && amt == 1        _                -> False{-# INLINABLE mkWrappedEmptyNFTPolicy #-}mkWrappedEmptyNFTPolicy :: TxOutRef -> BuiltinData -> BuiltinData -> ()mkWrappedEmptyNFTPolicy = wrapPolicy . mkEmptyNFTPolicynftCode :: PlutusTx.CompiledCode (TxOutRef -> BuiltinData -> BuiltinData -> ())nftCode = $$(PlutusTx.compile [|| mkWrappedEmptyNFTPolicy ||])nftPolicy :: TxOutRef -> MintingPolicynftPolicy oref = mkMintingPolicyScript $     $$(PlutusTx.compile [|| mkWrappedEmptyNFTPolicy ||])         `PlutusTx.applyCode` PlutusTx.liftCode oref------------------------------------------------------------------------------------------------------------------ HELPER FUNCTIONS ------------------------------saveNFTCode :: IO ()saveNFTCode = writeCodeToFile "assets/nftPolicyH2_typed.plutus" nftCode <s>"},
{"text": "<s>[INST] Write a script that sets blockfrost endpoint and loads local stored seed as a wallet into lucid. [/INST] This code allows a user to mint custom tokens on the Cardano blockchain, provided they meet the conditions defined by the minting policy: the correct public key must sign the transaction, and it must be done before the specified deadline. "Code": import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, getAddressDetails, applyParamsToScript } from \"https://deno.land/x/lucid@0.9.1/mod.ts\" import { blockfrostKey, secretSeed } from \"./secret.ts\" function readAmount(): bigint { const input = prompt(\"amount: \"); return input ? BigInt(Number.parseInt(input)) : 1000000n; } const lucid = await Lucid.new( new Blockfrost( \"https://cardano-preview.blockfrost.io/api/v0\", blockfrostKey ), \"Preview\" ); lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(\"own address: \" + addr); const pkh: string = getAddressDetails(addr).paymentCredential?.hash || \"\"; console.log(\"own pubkey hash: \" + pkh); const deadlineDate: Date = new Date(\"2023-12-21T00:00:00Z\"); const deadlinePosix = BigInt(deadlineDate.getTime()); const Params = Data.Tuple([Data.String, Data.BigInt]); type Params = Data.Static<typeof Params>; const signedPolicy: MintingPolicy = { type: \"PlutusV2\", script: applyParamsToScript<Params>("590af9590af60100003232323322323233223232323232323233223233223232323232323232333222323232322222323253353232323232533553353235001222222222222533533355301912001321233001225335002210031001002502b25335333573466e3c04c0040e80e44d40b4004540b0010840e840e1400440b04cd5ce2481136e6f74207369676e6564206279206f776e65720002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b003007355003222222222222005335014335016502802d3350153502900502d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce24926746f6f206c6174653a20646561646c696e652068617320616c6c7265616479207061737365640002b102b135001220023333573466e1cd55cea802a4000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00a603e6ae84d5d1280291931901519ab9c02d02c0283333573466e1cd55ce9baa0064800080ac8c98c80a4cd5ce0160158139bad006375c00c2050264c6404c66ae712410350543500028135573ca00226ea8004c8004d5408c88448894cd40044d400c88004884ccd401488008c010008ccd54c01c480040140100044888d400888d400c894ccd4ccd402001c01000854cd400c40044098409440984888c8c8c8c94ccd4018854ccd4018854ccd402084c011261300349854ccd401c84c01126130034984034402c54ccd401c84c011261300349854ccd401884c0112613003498403054ccd401484028402c402454ccd4014854ccd401c84c015261300449854ccd401884c01526130044984030402854ccd401884c015261300449854ccd401484c0152613004498402c94ccd4014854ccd401c854ccd401c84ccd402c028008004585858402c54ccd4018854ccd401884ccd40280240080045858584028402494ccd4010854ccd4018854ccd401884ccd4028024008004585858402854ccd4014854ccd401484ccd40240200080045858584024402094ccd400c854ccd4014854ccd401484ccd4024020008004585858402454ccd4010854ccd401084ccd402001c0080045858584020401c94ccd4008854ccd4010854ccd401084ccd402001c008004585858402054ccd400c854ccd400c84ccd401c018008004585858401c401848d40048888888801c488800c4888008488800448848cc00400c00848848cc00400c00848848cc00400c00848c88c008dd6000990009aa80d111999aab9f0012500a233500930043574200460066ae880080688c8c8cccd5cd19b8735573aa004900011991091980080180118071aba150023005357426ae8940088c98c8060cd5ce00d80d00b09aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180b9aba1500233500f016357426ae8940088c98c8074cd5ce01000f80d89aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403e66ae7008808407407006c4d55cea80089baa00135742a00466a016eb8d5d09aba2500223263201933573803803602e26ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355017223233335573e0044a010466a00e66442466002006004600c6aae754008c014d55cf280118021aba200301813574200222440042442446600200800624464646666ae68cdc3a800a400046a00e600a6ae84d55cf280191999ab9a3370ea00490011280391931900a19ab9c017016012011135573aa00226ea800448488c00800c44880048c8c8cccd5cd19b875001480188c848888c010014c01cd5d09aab9e500323333573466e1d400920042321222230020053009357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900919ab9c01501401000f00e00d135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011991091980080180118029aba15002375a6ae84d5d1280111931900719ab9c01101000c135573ca00226ea80048c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8030cd5ce00780700509baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c8054cd5ce00c00b80980900880800780700689aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401c66ae7004404003002c4d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200b33573801c01a01201026aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea004900111a80418031aba135573ca00846666ae68cdc3a801a40004a010464c6401866ae7003c0380280240204d55cea80089baa0011212223003004112220022323333573466e1d40052002200623333573466e1d40092000200623263200633573801201000800626aae74dd5000a4c244004244002240029210350543100112323001001223300330020020011", [pkh, deadlinePosix], Params) }; const policyId: PolicyId = lucid.utils.mintingPolicyToId(signedPolicy); console.log(\"minting policy: \" + policyId); const unit: Unit = policyId + fromText(\"PPP signed and time checked\"); const amount: bigint = readAmount(); const tx = await lucid .newTx() .mintAssets({[unit]: amount}, Data.void()) .attachMintingPolicy(signedPolicy) .addSignerKey(pkh) .validTo(Date.now()+60000) .complete(); const signedTx = await tx.sign().complete(); const txHash = await signedTx.submit(); console.log(\"tid: \" + txHash);<s>"},
{"text": "<s>[INST] Write a script that is useful when you want to create a token minting policy that allows unrestricted minting. [/INST] This code defines a minting policy for the Cardano blockchain using Plutus, which allows tokens to be minted freely without any conditions or restrictions. "Code": {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE TemplateHaskell #-} module Free where import Plutus.V2.Ledger.Api (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext, mkMintingPolicyScript) import qualified PlutusTx import PlutusTx.Prelude (Bool (True)) import Prelude (IO) import Utilities (currencySymbol, wrapPolicy, writePolicyToFile) {-# INLINABLE mkFreePolicy #-} mkFreePolicy :: () -> ScriptContext -> Bool mkFreePolicy () _ = True {-# INLINABLE mkWrappedFreePolicy #-} mkWrappedFreePolicy :: BuiltinData -> BuiltinData -> () mkWrappedFreePolicy = wrapPolicy mkFreePolicy freePolicy :: MintingPolicy freePolicy = mkMintingPolicyScript $$(PlutusTx.compile [|| mkWrappedFreePolicy ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveFreePolicy :: IO () saveFreePolicy = writePolicyToFile \"assets/free.plutus\" freePolicy freeCurrencySymbol :: CurrencySymbol freeCurrencySymbol = currencySymbol freePolicy. </s>"},
{"text": "<s>[INST] Write a script that enables the creation and management of NFTs on the Cardano blockchain by defining the rules for minting them. [/INST] This code defines a minting policy for a non-fungible token (NFT) on the Cardano blockchain using Plutus, the smart contract platform for Cardano. "Code": {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module NFT where import qualified Data.ByteString.Char8      as BS8 import Plutus.V1.Ledger.Value     (flattenValue) import Plutus.V2.Ledger.Api       (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext (scriptContextTxInfo), TokenName (unTokenName), TxId (TxId, getTxId), TxInInfo (txInInfoOutRef), TxInfo (txInfoInputs, txInfoMint), TxOutRef (TxOutRef, txOutRefId, txOutRefIdx), mkMintingPolicyScript) import qualified PlutusTx import PlutusTx.Builtins.Internal (BuiltinByteString (BuiltinByteString)) import PlutusTx.Prelude           (Bool (False), Eq ((==)), any, traceIfFalse, ($), (&&)) import Prelude                    (IO, Show (show), String) import Text.Printf                (printf) import Utilities                  (bytesToHex, currencySymbol, wrapPolicy, writeCodeToFile, writePolicyToFile) {-# INLINABLE mkNFTPolicy #-} mkNFTPolicy :: TxOutRef -> TokenName -> () -> ScriptContext -> Bool mkNFTPolicy oref tn () ctx = traceIfFalse \"UTxO not consumed\"   hasUTxO           && traceIfFalse \"wrong amount minted\" checkMintedAmount where info :: TxInfo info = scriptContextTxInfo ctx hasUTxO :: Bool hasUTxO = any (\\i -> txInInfoOutRef i == oref) $ txInfoInputs info checkMintedAmount :: Bool checkMintedAmount = case flattenValue (txInfoMint info) of [(_, tn'', amt)] -> tn'' == tn && amt == 1 _                -> False {-# INLINABLE mkWrappedNFTPolicy #-} mkWrappedNFTPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedNFTPolicy tid ix tn' = wrapPolicy $ mkNFTPolicy oref tn where oref :: TxOutRef oref = TxOutRef (TxId $ PlutusTx.unsafeFromBuiltinData tid) (PlutusTx.unsafeFromBuiltinData ix) tn :: TokenName tn = PlutusTx.unsafeFromBuiltinData tn' nftCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()) nftCode = $$(PlutusTx.compile [|| mkWrappedNFTPolicy ||]) nftPolicy :: TxOutRef -> TokenName -> MintingPolicy nftPolicy oref tn = mkMintingPolicyScript $ nftCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ getTxId $ txOutRefId oref) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ txOutRefIdx oref) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData tn) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveNFTCode :: IO () saveNFTCode = writeCodeToFile \"assets/nft.plutus\" nftCode saveNFTPolicy :: TxOutRef -> TokenName -> IO () saveNFTPolicy oref tn = writePolicyToFile (printf \"assets/nft-%s#%d-%s.plutus\" (show $ txOutRefId oref) (txOutRefIdx oref) $ tn') $ nftPolicy oref tn where tn' :: String tn' = case unTokenName tn of (BuiltinByteString bs) -> BS8.unpack $ bytesToHex bs nftCurrencySymbol :: TxOutRef -> TokenName -> CurrencySymbol nftCurrencySymbol oref tn = currencySymbol $ nftPolicy oref tn. </s>"},
{"text": "<s>[INST] Write a script that  defines a minting policy for signed transactions on the Cardano blockchain using Plutus. [/INST] This code facilitates the creation and management of a signed minting policy for NFTs, ensuring that only transactions signed by a specific public key can mint new tokens. "Code": {-# LANGUAGE DataKinds         #-}{-# LANGUAGE NoImplicitPrelude #-}{-# LANGUAGE OverloadedStrings #-}{-# LANGUAGE TemplateHaskell   #-}module Signed whereimport           Plutus.V2.Ledger.Api      (BuiltinData, CurrencySymbol, MintingPolicy, PubKeyHash, ScriptContext (scriptContextTxInfo), mkMintingPolicyScript)import           Plutus.V2.Ledger.Contexts (txSignedBy)import qualified PlutusTx import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (.) )import           Prelude                   (IO, Show (show))import           Text.Printf               (printf)import           Utilities                 (currencySymbol, wrapPolicy, writeCodeToFile, writePolicyToFile){-# INLINABLE mkSignedPolicy #-}mkSignedPolicy :: PubKeyHash -> () -> ScriptContext -> BoolmkSignedPolicy pkh () ctx = traceIfFalse \"missing signature\" $ txSignedBy (scriptContextTxInfo ctx) pkh{-# INLINABLE mkWrappedSignedPolicy #-}mkWrappedSignedPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> ()mkWrappedSignedPolicy pkh = wrapPolicy (mkSignedPolicy $ PlutusTx.unsafeFromBuiltinData pkh)signedCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ())signedCode = $$(PlutusTx.compile [|| mkWrappedSignedPolicy ||])signedPolicy :: PubKeyHash -> MintingPolicysignedPolicy pkh = mkMintingPolicyScript $ signedCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData pkh)---------------------------------------------------------------------------------------------------------------------------------------- HELPER FUNCTIONS --------------------------------------------saveSignedCode :: IOWriteCodeToFile \"assets/signed.plutus\" signedCodesaveSignedPolicy :: PubKeyHash -> IOWritePolicyToFile (printf \"assets/signed-%s.plutus\" $ show pkh) $ signedPolicy pkhsignedCurrencySymbol :: PubKeyHash -> CurrencySymbolsignedCurrencySymbol = currencySymbol . signedPolicy<s>"},
{"text": "<s>[INST] Write a script that is designed to implement a testing framework for a token swap mechanism in a smart contract. [/INST] This code specifically tests a swap mechanism, allowing users to trade tokens in a secure manner while preventing double-spending."Code": {-# LANGUAGE DataKinds          #-}{-# LANGUAGE FlexibleInstances  #-}{-# LANGUAGE NoImplicitPrelude  #-}{-# LANGUAGE NumericUnderscores #-}{-# LANGUAGE OverloadedStrings  #-}module Main where import           Plutus.Model         (Run, TypedValidator (TypedValidator), adaValue, defaultBabbage, mustFail, testNoErrors, toV2, FakeCoin (FakeCoin), fakeValue, UserSpend, Tx, DatumMode (HashDatum), userSpend, payToScript, spendScript, payToKey, newUser, spend, submitTx, utxoAt, valueAt, logError) import           PlutusTx.Prelude     (($), Integer, Eq ((==)), (&&)) import           Prelude              (IO, (.), (<>), Monoid (mconcat), Traversable (mapM), Num ((-))) import qualified ExploitableSwap      as OnChain import qualified PatchedSwap          as PatchedOnChain (validator) import           Test.Tasty           (defaultMain, testGroup) import           Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut (txOutValue)) import           Control.Monad        (unless) main :: IO () main = do  defaultMain $ do    testGroup      \"Catch double spend with testing\"      [ good \"Normal spending using vulnerable script succeeds\" $ normalSpending swapScript      , good \"Double spending using vulnerable script succeeds\" $ doubleSpending swapScript      , good \"Normal spending using patched script succeeds   \" $ normalSpending patchedSwapScript      , bad  \"Double spending using patched script fails      \" $ doubleSpending patchedSwapScript      ]  where     bad msg = good msg . mustFail     good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage scToken :: FakeCoin scToken = FakeCoin \"Super-Cool-Token\" type HomeworkScript = TypedValidator OnChain.DatumSwap () swapScript :: HomeworkScript swapScript = TypedValidator $ toV2 OnChain.validator patchedSwapScript :: HomeworkScript patchedSwapScript = TypedValidator $ toV2 PatchedOnChain.validator lockingTx :: HomeworkScript -> PubKeyHash -> Integer -> UserSpend -> Value -> Tx lockingTx script benef price usp val =  mconcat    [ userSpend usp    , payToScript script (HashDatum (OnChain.DatumSwap benef price)) val    ] consumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> Value -> Tx consumingTx script benef price buyer sp2 ref token =  mconcat    [ spendScript script ref () (OnChain.DatumSwap benef price)    , payToKey buyer token    , payToKey benef $ adaValue price    , userSpend sp2    ] doubleConsumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> TxOutRef -> Value -> Tx doubleConsumingTx script benef price buyer sp2 ref1 ref2 token =  mconcat    [ spendScript script ref1 () (OnChain.DatumSwap benef price)    , spendScript script ref2 () (OnChain.DatumSwap benef price)    , payToKey buyer $ token <> token -- Two tokens to buyer    , payToKey benef $ adaValue price -- Payment for only one token to beneficiary    , userSpend sp2    ] normalSpending :: HomeworkScript -> Run () normalSpending script = do  u1 <- newUser (adaValue 1000 <> fakeValue scToken 1)  u2 <- newUser (adaValue 1000)  let token = adaValue 1 <> fakeValue scToken 1      price = 350  sp1 <- spend u1 token                        submitTx u1 $ lockingTx script u1 price sp1 token  utxos <- utxoAt script  let [(ref, out)] = utxos                  sp2 <- spend u2 (adaValue price)                        submitTx u2 $ consumingTx script u1 price u2 sp2 ref (txOutValue out)  [v1, v2] <- mapM valueAt [u1, u2]          let expectedV1 = adaValue 999 <> adaValue price  let expectedV2 = adaValue (1000 - price) <> token  unless (v1 == expectedV1 && v2 == expectedV2) $    logError \"Final balances are incorrect\" doubleSpending :: HomeworkScript -> Run () doubleSpending script = do  u1 <- newUser (adaValue 1000 <> fakeValue scToken 2)  u2 <- newUser (adaValue 1000)  let token = adaValue 1 <> fakeValue scToken 1      price = 350  sp1 <- spend u1 token                        submitTx u1 $ lockingTx script u1 price sp1 token  sp1' <- spend u1 token                        submitTx u1 $ lockingTx script u1 price sp1' token  utxos <- utxoAt script  let [(ref1, out),(ref2, _)] = utxos                  sp2 <- spend u2 (adaValue price)                        submitTx u2 $ doubleConsumingTx script u1 price u2 sp2 ref1 ref2 (txOutValue out)  [v1, v2] <- mapM valueAt [u1, u2]          let expectedV1 = adaValue 998 <> adaValue price  let expectedV2 = adaValue (1000 - price) <> token <> token  unless (v1 == expectedV1 && v2 == expectedV2) $    logError "Final balances are incorrect". <s>"},
{"text": "<s>[INST] Write a script that ensures token sales occur correctly by verifying that the buyer pays the required amount to the seller (beneficiary) before completing the transaction. [/INST] This code ensures that token sales are conducted fairly by enforcing a strict requirement that the buyer must pay the exact price specified by the seller. This is done through a smart contract that verifies the transaction details before allowing it to be completed, safeguarding both parties in the transaction. "Code": "languageExtensions":["DataKinds","ImportQualifiedPost","NoImplicitPrelude","OverloadedStrings","TemplateHaskell"],"module":"ExploitableSwap","imports":["Plutus.V2.Ledger.Api (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton)","Plutus.V2.Ledger.Contexts (valuePaidTo, TxInfo)","PlutusTx (compile, unstableMakeIsData)","PlutusTx.Builtins (BuiltinData, Integer)","PlutusTx.Prelude (Bool (..), (==), traceIfFalse)","Utilities (wrapValidator)"],"dataTypes":[{"name":"DatumSwap","fields":[{"name":"beneficiary","type":"PubKeyHash"},{"name":"price","type":"Integer"}]}],"functions":[{"name":"mkValidator","description":"Validates if the correct amount is paid to the beneficiary.","params":[{"name":"ds","type":"DatumSwap"},{"name":"_","type":"()"},{"name":"ctx","type":"ScriptContext"}],"body":"traceIfFalse \"Hey! You have to pay the owner!\" outputToBeneficiary where txInfo = scriptContextTxInfo ctx; outputToBeneficiary = valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds)"},{"name":"mkWrappedValidator","description":"Wraps the mkValidator function.","params":[{"name":"BuiltinData","type":"BuiltinData"},{"name":"BuiltinData","type":"BuiltinData"},{"name":"BuiltinData","type":"BuiltinData"}],"body":"wrapValidator mkValidator"},{"name":"validator","description":"Compiles the wrapped validator for deployment.","body":"mkValidatorScript $$(compile [|| mkWrappedValidator ||])"}] <s>"},
{"text": "<s>[INST] Write a script that checks the value paid to the beneficiary is equal to the price, check that the validator required to spend this output is the current one, and check that we're consuming exactly one script output. [/INST] This code defines a validator for a token swap on the Cardano blockchain, ensuring that transactions adhere to specific rules before they are accepted. "Code": {-# LANGUAGE DataKinds           #-}{-# LANGUAGE ImportQualifiedPost #-}{-# LANGUAGE NoImplicitPrelude   #-}{-# LANGUAGE OverloadedStrings   #-}{-# LANGUAGE TemplateHaskell     #-}{-# LANGUAGE NamedFieldPuns #-}module PatchedSwap where import           Plutus.V2.Ledger.Api      (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton, TxInfo (txInfoInputs), Credential (ScriptCredential),  Address (addressCredential), TxOut (txOutAddress)) import           Plutus.V2.Ledger.Contexts (valuePaidTo, TxInInfo, txInInfoResolved, ownHash) import           PlutusTx                  (compile, unstableMakeIsData) import           PlutusTx.Builtins         (BuiltinData, Integer) import           PlutusTx.Prelude          (Bool (..), (==), traceIfFalse, (&&), (.), filter, ($)) import           Utilities                 (wrapValidator)-------------------------------------------------------------------------------------------------------------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------data DatumSwap = DatumSwap { beneficiary :: PubKeyHash , price       :: Integer } PlutusTx.unstableMakeIsData ''DatumSwap{-# INLINABLE mkValidator #-}mkValidator :: DatumSwap -> () -> ScriptContext -> Bool mkValidator ds _ ctx = traceIfFalse \"Hey! You have to pay the owner!\" outputToBeneficiary && traceIfFalse \"Hey! You can only consume one script UTxO per Tx!\" consumeOnlyOneOutput where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx outputToBeneficiary :: Bool outputToBeneficiary =  valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds) getScriptInputs :: [TxInInfo] getScriptInputs = filter isScriptInput allInputs where allInputs :: [TxInInfo] allInputs = txInfoInputs txInfo isScriptInput :: TxInInfo -> Bool isScriptInput i = case addressCredential . txOutAddress . txInInfoResolved $ i of ScriptCredential vh -> vh == ownHash ctx _                   -> False consumeOnlyOneOutput :: Bool consumeOnlyOneOutput = case getScriptInputs of [_] -> True _   -> False{-# INLINABLE  mkWrappedValidator #-}mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedValidator = wrapValidator mkValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedValidator ||])<s>"},
