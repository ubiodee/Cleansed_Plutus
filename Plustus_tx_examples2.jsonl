[
  {
  "prompt": "Write a script that is designed to automate the process of submitting a Cardano transaction on a Testnet.",
  "response": "bash\n#!/bin/bash\n\n# Define paths and parameters\nassets=/workspaces/plutus-pioneer-program/code/Week02/assets\nkeypath=/workspaces/plutus-pioneer-program/keys\nname=\"$1\"\ncollateral=\"$2\"\ntxin=\"$3\"\n\npp=\"$assets/protocol-parameters.json\"\nbody=\"$assets/collect-gift.txbody\"\ntx=\"$assets/collect-gift.tx\"\n\n# Step 1: Query the protocol parameters and save to JSON file\ncardano-cli query protocol-parameters \\\n  --testnet-magic 2 \\\n  --out-file \"$pp\"\n\n# Step 2: Build the transaction with necessary parameters\ncardano-cli transaction build \\\n  --babbage-era \\\n  --testnet-magic 2 \\\n  --tx-in \"$txin\" \\\n  --tx-in-script-file \"$assets/gift.plutus\" \\\n  --tx-in-inline-datum-present \\\n  --tx-in-redeemer-file \"$assets/unit.json\" \\\n  --tx-in-collateral \"$collateral\" \\\n  --change-address \"$(cat \"$keypath/$name.addr\")\" \\\n  --protocol-params-file \"$pp\" \\\n  --out-file \"$body\"\n\n# Step 3: Sign the transaction\ncardano-cli transaction sign \\\n  --tx-body-file \"$body\" \\\n  --signing-key-file \"$keypath/$name.skey\" \\\n  --testnet-magic 2 \\\n  --out-file \"$tx\"\n\n# Step 4: Submit the transaction\ncardano-cli transaction submit \\\n  --testnet-magic 2 \\\n  --tx-file \"$tx\"\n\ntid=$(cardano-cli transaction txid --tx-file \"$tx\")\necho \"transaction id: $tid\"\necho \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\"\n```"
}, 
{
  "prompt": "Write a script that is used to automate the process of building, signing, and submitting a Cardano transaction on a testnet.",
  "response": "#!/bin/bash\n\n# Define paths and parameters\nassets=/workspaces/plutus-pioneer-program/code/Week02/assets\nkeypath=/workspaces/plutus-pioneer-program/keys\nname=\"$1\"\ntxin=\"$2\"\n\nbody=\"$assets/gift.txbody\"\ntx=\"$assets/gift.tx\"\n\n# Step 1: Build the gift address\ncardano-cli address build \\\n  --payment-script-file \"$assets/gift.plutus\" \\\n  --testnet-magic 2 \\\n  --out-file \"$assets/gift.addr\"\n\n# Step 2: Build the transaction with specified inputs and outputs\ncardano-cli transaction build \\\n  --babbage-era \\\n  --testnet-magic 2 \\\n  --tx-in \"$txin\" \\\n  --tx-out \"$(cat \"$assets/gift.addr\") + 3000000 lovelace\" \\\n  --tx-out-inline-datum-file \"$assets/unit.json\" \\\n  --change-address \"$(cat \"$keypath/$name.addr\")\" \\\n  --out-file \"$body\"\n\n# Step 3: Sign the transaction\ncardano-cli transaction sign \\\n  --tx-body-file \"$body\" \\\n  --signing-key-file \"$keypath/$name.skey\" \\\n  --testnet-magic 2 \\\n  --out-file \"$tx\"\n\n# Step 4: Submit the transaction\ncardano-cli transaction submit \\\n  --testnet-magic 2 \\\n  --tx-file \"$tx\"\n\ntid=$(cardano-cli transaction txid --tx-file \"$tx\")\necho \"transaction id: $tid\"\necho \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\"\n"
},
{
  "prompt": "Write a script that validates if and only if the two Booleans in the redeemer are True.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Homework1 where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (compile)\nimport PlutusTx.Prelude (Bool(..), BuiltinData, traceIfFalse, ($), (&&))\nimport Utilities (wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n{-# INLINABLE mkValidator #-}\n\n-- This should validate if and only if the two Booleans in the redeemer are True!\nmkValidator :: () -> (Bool, Bool) -> PlutusV2.ScriptContext -> Bool\nmkValidator _ (a, b) _ = traceIfFalse \"One or more bools are not true\" $ a && b\n\nwrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nwrappedVal = wrapValidator mkValidator\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||])\n"
},
{
  "prompt": "Write a script that creates a validator that unlocks the funds if MyRedeemer's flags are different.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Homework2 where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (unstableMakeIsData, compile)\nimport PlutusTx.Prelude (Bool, BuiltinData, traceIfFalse, ($), (/=))\nimport Utilities (wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\ndata MyRedeemer = MyRedeemer {\n    flag1 :: Bool,\n    flag2 :: Bool\n}\n\nPlutusTx.unstableMakeIsData ''MyRedeemer\n\n{-# INLINABLE mkValidator #-}\n\n-- Create a validator that unlocks the funds if MyRedeemer's flags are different\nmkValidator :: () -> MyRedeemer -> PlutusV2.ScriptContext -> Bool\nmkValidator _ myRed _ = traceIfFalse \"flags are not different\" $ flag1 myRed /= flag2 myRed\n\nwrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nwrappedVal = wrapValidator mkValidator\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||])\n"
},
{
  "prompt": "Write a script that is used to automate the process of building, signing, and submitting a Cardano transaction on a testnet.",
  "response": "#!/bin/bash\n\nassets=/workspaces/plutus-pioneer-program/code/Week02/assets\nkeypath=/workspaces/plutus-pioneer-program/keys\nname=\"$1\"\ntxin=\"$2\"\nbody=\"$assets/gift.txbody\"\ntx=\"$assets/gift.tx\"\n\n# Build gift address\ncardano-cli address build \\\n  --payment-script-file \"$assets/gift.plutus\" \\\n  --testnet-magic 2 \\\n  --out-file \"$assets/gift.addr\"\n\n# Build the transaction\ncardano-cli transaction build \\\n  --babbage-era \\\n  --testnet-magic 2 \\\n  --tx-in \"$txin\" \\\n  --tx-out \"$(cat \"$assets/gift.addr\") + 3000000 lovelace\" \\\n  --tx-out-inline-datum-file \"$assets/unit.json\" \\\n  --change-address \"$(cat \"$keypath/$name.addr\")\" \\\n  --out-file \"$body\"\n\n# Sign the transaction\ncardano-cli transaction sign \\\n  --tx-body-file \"$body\" \\\n  --signing-key-file \"$keypath/$name.skey\" \\\n  --testnet-magic 2 \\\n  --out-file \"$tx\"\n\n# Submit the transaction\ncardano-cli transaction submit \\\n  --testnet-magic 2 \\\n  --tx-file \"$tx\"\n\ntid=$(cardano-cli transaction txid --tx-file \"$tx\")\necho \"transaction id: $tid\"\necho \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\"\n"
},
{
  "prompt": "Write a script validator that always fails.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Burn where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (BuiltinData, compile)\nimport PlutusTx.Prelude (traceError)\nimport Prelude (IO)\nimport Utilities (writeValidatorToFile)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n-- This validator always fails\n--                    Datum         Redeemer     ScriptContext\nmkBurnValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkBurnValidator _ _ _ = traceError \"it burns!!!\"\n\n{-# INLINABLE mkBurnValidator #-}\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkBurnValidator ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveVal :: IO ()\nsaveVal = writeValidatorToFile \"./assets/burn.plutus\" validator\n"
},
{
  "prompt": "Write a script validator that succeeds only if the redeemer is `MkMySillyRedeemer 42`",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule CustomTypes where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (BuiltinData, compile, unstableMakeIsData)\nimport PlutusTx.Prelude (Bool, Eq ((==)), Integer, traceIfFalse, ($))\nimport Prelude (IO)\nimport Utilities (writeValidatorToFile, wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n-- We can create custom data types for our datum and redeemer like this:\nnewtype MySillyRedeemer = MkMySillyRedeemer Integer\nPlutusTx.unstableMakeIsData ''MySillyRedeemer\n\n-- Use TH to create an instance for IsData.\n-- This validator succeeds only if the redeemer is `MkMySillyRedeemer 42`\n--              Datum     Redeemer            ScriptContext\nmkCTValidator :: () -> MySillyRedeemer -> PlutusV2.ScriptContext -> Bool\nmkCTValidator _ (MkMySillyRedeemer r) _ = traceIfFalse \"expected 42\" $ r == 42\n\n{-# INLINABLE mkCTValidator #-}\n\nwrappedMkVal :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nwrappedMkVal = wrapValidator mkCTValidator\n\n{-# INLINABLE wrappedMkVal #-}\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedMkVal ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\nsaveVal :: IO ()\nsaveVal = writeValidatorToFile \"./assets/customtypes.plutus\" validator"
},
{
  "prompt": "Write a script validator that succeeds only if the redeemer is 42.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule FortyTwo where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (BuiltinData, compile)\nimport PlutusTx.Builtins as Builtins (mkI)\nimport PlutusTx.Prelude (otherwise, traceError, (==))\nimport Prelude (IO)\nimport Utilities (writeValidatorToFile)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n-- This validator succeeds only if the redeemer is 42\n--                  Datum         Redeemer     ScriptContext\nmk42Validator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nmk42Validator _ r _ | r == Builtins.mkI 42 = () | otherwise            = traceError \"expected 42\"\n\n{-# INLINABLE mk42Validator #-}\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mk42Validator ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\nsaveVal :: IO ()\nsaveVal = writeValidatorToFile \"./assets/fortytwo.plutus\" validator"
},
{
  "prompt": "Write a script validator that always succeeds.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Gift where\n\nimport qualified Plutus.V2.Ledger.Api as PlutusV2\nimport PlutusTx (BuiltinData, compile)\nimport Prelude (IO)\nimport Utilities (writeValidatorToFile)\n\n---------------------------------------------------------------------------------------------------\n-------------------------------- ON-CHAIN CODE / VALIDATOR ----------------------------------------\n\n-- This validator always succeeds\n--                    Datum         Redeemer     ScriptContext\nmkGiftValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkGiftValidator _ _ _ = ()\n\n{-# INLINABLE mkGiftValidator #-}\n\nvalidator :: PlutusV2.Validator\nvalidator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkGiftValidator ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\nsaveVal :: IO ()\nsaveVal = writeValidatorToFile \"./assets/gift.plutus\" validator"
},
{
  "prompt": "Write a script that validates if either beneficiary1 has signed the transaction and the current slot is before or at the deadline or if beneficiary2 has signed the transaction and the deadline has passed.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeApplications  #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Homework1 where\n\nimport Plutus.V2.Ledger.Api\nimport Plutus.V2.Ledger.Contexts (txSignedBy)\nimport Plutus.V1.Ledger.Interval\nimport PlutusTx (compile, unstableMakeIsData)\nimport PlutusTx.Prelude (traceIfFalse, Bool(..), (||), (&&), (+))\nimport Utilities (wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\ndata VestingDatum = VestingDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime }\n\nunstableMakeIsData ''VestingDatum\n\n{-# INLINABLE mkVestingValidator #-}\n\n-- This should validate if either beneficiary1 has signed the transaction and the current slot is before or at the deadline\n-- or if beneficiary2 has signed the transaction and the deadline has passed.\nmkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool\nmkVestingValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2\n  where\n    txInfo :: TxInfo\n    txInfo = scriptContextTxInfo ctx\n    txValidRange :: POSIXTimeRange\n    txValidRange  = txInfoValidRange txInfo\n\n    checkCondition1 :: Bool\n    checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange\n\n    checkCondition2 :: Bool\n    checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange\n\n{-# INLINABLE  mkWrappedVestingValidator #-}\n\nmkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedVestingValidator = wrapValidator mkVestingValidator\n\nvalidator :: Validator\nvalidator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||])"
},
{
  "prompt": "Write a script that validates if the transaction has a signature from the parameterized beneficiary and the deadline has passed.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Homework2 where\n\nimport Plutus.V2.Ledger.Api\nimport Plutus.V2.Ledger.Contexts\nimport Plutus.V1.Ledger.Interval\nimport PlutusTx (applyCode, compile, liftCode)\nimport PlutusTx.Prelude (Bool(..), (.), traceIfFalse, (&&))\nimport Utilities (wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n{-# INLINABLE mkParameterizedVestingValidator #-}\n\n-- This should validate if the transaction has a signature from the parameterized beneficiary and the deadline has passed.\nmkParameterizedVestingValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool\nmkParameterizedVestingValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline\n  where\n    txInfo :: TxInfo\n    txInfo = scriptContextTxInfo ctx\n    txValidRange :: POSIXTimeRange\n    txValidRange  = txInfoValidRange txInfo\n\n    checkSig :: Bool\n    checkSig = txSignedBy txInfo beneficiary\n\n    checkDeadline :: Bool\n    checkDeadline = contains (from deadline) txValidRange\n\n{-# INLINABLE  mkWrappedParameterizedVestingValidator #-}\n\nmkWrappedParameterizedVestingValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator\n\nvalidator :: PubKeyHash -> Validator\nvalidator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode beneficiary)"
},
{
  "prompt": "Write a script validator that determines if a transaction has been signed by a specific beneficiary and if the deadline for that beneficiary has passed.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule ParameterizedVesting where\n\nimport           Plutus.V1.Ledger.Interval (contains)\nimport           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript)\nimport           Plutus.V2.Ledger.Contexts (txSignedBy)\nimport           PlutusTx                  (applyCode, compile, liftCode, makeLift)\nimport           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (.) )\nimport           Prelude                   (IO)\nimport           Utilities                 (writeValidatorToFile, wrapValidator)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\ndata VestingParams = VestingParams { beneficiary :: PubKeyHash , deadline    :: POSIXTime }\n\nmakeLift ''VestingParams\n\n{-# INLINABLE mkParameterizedVestingValidator #-}\nmkParameterizedVestingValidator :: VestingParams -> () -> () -> ScriptContext -> Bool\nmkParameterizedVestingValidator params () () ctx = traceIfFalse \"beneficiary's signature missing\" signedByBeneficiary && traceIfFalse \"deadline not reached\" deadlineReached\n  where\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n\n    signedByBeneficiary :: Bool\n    signedByBeneficiary = txSignedBy info $ beneficiary params\n\n    deadlineReached :: Bool\n    deadlineReached = contains (from $ deadline params) $ txInfoValidRange info\n\n{-# INLINABLE  mkWrappedParameterizedVestingValidator #-}\nmkWrappedParameterizedVestingValidator :: VestingParams -> BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator\n\nvalidator :: VestingParams -> Validator\nvalidator params = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode params)\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\nsaveVal :: VestingParams -> IO ()\nsaveVal = writeValidatorToFile \"./assets/parameterized-vesting.plutus\" . validator"
},
{
  "prompt": "Write a script validator that provides a comprehensive testing framework for two vesting smart contracts built on the Plutus platform.",
  "response": "{-# LANGUAGE NumericUnderscores #-}\n\nmodule Main where\n\nimport Control.Monad (replicateM)\nimport Plutus.Model\nimport Plutus.Model.Fork.Ledger.Slot (Slot)\nimport Plutus.V2.Ledger.Api\nimport Prelude\nimport Test.Tasty\nimport qualified Homework1 as H1\nimport qualified Homework2 as H2\n\ntype Homework1Script = TypedValidator H1.VestingDatum ()\n\nscript1 :: Homework1Script\nscript1 = TypedValidator $ toV2 H1.validator\n\ntype Homework2Script = TypedValidator POSIXTime ()\n\nscript2 :: PubKeyHash -> Homework2Script\nscript2 = TypedValidator . toV2 . H2.validator\n\nsetupUsers :: Run [PubKeyHash]\nsetupUsers = replicateM 3 $ newUser $ ada (Lovelace 1000)\n\nmain :: IO ()\nmain = do\n  defaultMain $ do\n    testGroup \"Homework tests\" [\n      testGroup \"All times are in POSIXTime (Not slots)\" [\n        homework1 defaultBabbage,\n        homework2 defaultBabbage\n      ]\n    ]\n\nhomework1 :: MockConfig -> TestTree\nhomework1 cfg = testGroup \"Testing Homework1\" [\n  testGroup \"Beneficiary 1 signing\" [\n    good \"Deadline: 6000; TxValidRange (5000, 5999)\" $ testBeneficiary1 6000 (-999) 0 0,\n    good \"Deadline: 6000; TxValidRange (5000, 6000)\" $ testBeneficiary1 6000 (-999) 1 0,\n    good \"Deadline: 6000; TxValidRange (5000, 6999)\" $ testBeneficiary1 6000 (-999) 1000 0,\n    good \"Deadline: 6000; TxValidRange (5999, 6001)\" $ testBeneficiary1 6000 0 2 0,\n    good \"Deadline: 6000; TxValidRange (6999, 6999)\" $ testBeneficiary1 6000 0 0 1,\n    bad \"Deadline: 6000; TxValidRange (7000, 8000)\" $ testBeneficiary1 6000 1 1001 1,\n    bad \"Deadline: 6000; TxValidRange (5000, 7000)\" $ testBeneficiary1 6000 (-999) 1001 0,\n    bad \"Deadline: 6000; TxValidRange (6000, 7000)\" $ testBeneficiary1 6000 (-999) 1 1,\n    bad \"Deadline: 6000; TxValidRange (6999, 7000)\" $ testBeneficiary1 6000 0 1 1\n  ],\n  testGroup \"Beneficiary 2 signing\" [\n    good \"Deadline: 5000; TxValidRange (6000, 7000)\" $ testBeneficiary2 5000 (-999) 1 1,\n    good \"Deadline: 4999; TxValidRange (5000, 6000)\" $ testBeneficiary2 4999 (-999) 1 0,\n    bad \"Deadline: 6000; TxValidRange (5000, 5999)\" $ testBeneficiary2 6000 (-999) 0 0,\n    bad \"Deadline: 5000; TxValidRange (5000, 6000)\" $ testBeneficiary2 5000 (-999) 1 0,\n    bad \"Deadline: 5000; TxValidRange (5001, 6000)\" $ testBeneficiary2 5000 (-998) 1 0,\n    bad \"Deadline: 5000; TxValidRange (5999, 6000)\" $ testBeneficiary2 5000 0 1 0\n  ],\n  bad \"None signing\" $ testNoSigning 5000 0 0 0\n] where\n  bad msg = good msg . mustFail\n  good = testNoErrors (adaValue 10_000_000) cfg\n\n  testBeneficiary1 :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run ()\n  testBeneficiary1 deadline curMinT curMaxT wSlot = do\n    users <- setupUsers\n    let [u1, u2, u3] = users\n        dat = H1.VestingDatum u1 u2 deadline\n    testHomework1 u1 u3 dat curMinT curMaxT wSlot\n\n  testBeneficiary2 :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run ()\n  testBeneficiary2 deadline curMinT curMaxT wSlot = do\n    users <- setupUsers\n    let [u1, u2, u3] = users\n        dat = H1.VestingDatum u1 u2 deadline\n    testHomework1 u2 u3 dat curMinT curMaxT wSlot\n\n  testNoSigning :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run ()\n  testNoSigning deadline curMinT curMaxT wSlot = do\n    users <- setupUsers\n    let [u1, u2, u3] = users\n        dat = H1.VestingDatum u1 u2 deadline\n    testHomework1 u3 u3 dat curMinT curMaxT wSlot\n\n  testHomework1 :: PubKeyHash -> PubKeyHash -> H1.VestingDatum -> POSIXTime -> POSIXTime -> Slot -> Run ()\n  testHomework1 sigUser receiver dat curMinT curMaxT wSlot = do\n    let val = adaValue 100\n    checkBalance (gives sigUser val script1) $ do\n      sp <- spend sigUser val\n      submitTx sigUser $ vestingTx1 dat sp val\n      waitNSlots wSlot\n      utxos <- utxoAt script1\n      let [(vestRef, vestOut)] = utxos\n      checkBalance (gives script1 (txOutValue vestOut) receiver) $ do\n        range <- currentTimeInterval curMinT curMaxT\n        tx <- validateIn range $ claimingTx1 receiver dat vestRef (txOutValue vestOut)\n        submitTx sigUser tx\n\n  vestingTx1 :: H1.VestingDatum -> UserSpend -> Value -> Tx\n  vestingTx1 dat usp val = mconcat [ userSpend usp , payToScript script1 (HashDatum dat) val ]\n\n  claimingTx1 :: PubKeyHash -> H1.VestingDatum -> TxOutRef -> Value -> Tx\n  claimingTx1 pkh dat vestRef vestVal = mconcat [ spendScript script1 vestRef () dat , payToKey pkh vestVal ]\n\nhomework2 :: MockConfig -> TestTree\nhomework2 cfg = testGroup \"Testing Homework2\" [\n  good \"Deadline: 5000; TxValidRange (6000, 7000)\" $ testHomework2 5000 (-999) 1 1,\n  good \"Deadline: 5000; TxValidRange (5000, 5000)\" $ testHomework2 5000 (-999) (-999) 0,\n  good \"Deadline: 5000; TxValidRange (5000, 6000)\" $ testHomework2 5000 (-999) 1 0,\n  good \"Deadline: 5000; TxValidRange (5001, 6000)\" $ testHomework2 5000 (-998) 1 0,\n  good \"Deadline: 5000; TxValidRange (5999, 6000)\" $ testHomework2 5000 0 1 0,\n  bad \"Deadline: 5000; TxValidRange (4000, 5000)\" $ testHomework2 5000 (-1999) (-999) 0,\n  bad \"Deadline: 5000; TxValidRange (4999, 5000)\" $ testHomework2 5000 (-1000) (-999) 0,\n  bad \"Deadline: 5000; TxValidRange (4999, 5999)\" $ testHomework2 5000 (-1000) 0 0\n] where\n  bad msg = good msg . mustFail\n  good = testNoErrors (adaValue 10_000_000) cfg\n\n  testHomework2 :: POSIXTime -> POSIXTime -> POSIXTime -> Slot -> Run ()\n  testHomework2 dat curMinT curMaxT wSlot = do\n    users <- setupUsers\n    let [u1, u2, _u3] = users\n        val = adaValue 100\n    checkBalance (gives u1 val $ script2 u2) $ do\n      sp <- spend u1 val\n      submitTx u1 $ vestingTx2 u2 dat sp val\n      waitNSlots wSlot\n      utxos <- utxoAt $ script2 u2\n      let [(vestRef, vestOut)] = utxos\n      checkBalance (gives (script2 u2) (txOutValue vestOut) u2) $ do\n        range <- currentTimeInterval curMinT curMaxT\n        tx <- validateIn range $ claimingTx2 u2 dat vestRef (txOutValue vestOut)\n        submitTx u2 tx\n\n  vestingTx2 :: PubKeyHash -> POSIXTime -> UserSpend -> Value -> Tx\n  vestingTx2 pkh dat usp val = mconcat [ userSpend usp , payToScript (script2 pkh) (HashDatum dat) val ]\n\n  claimingTx2 :: PubKeyHash -> POSIXTime -> TxOutRef -> Value -> Tx\n  claimingTx2 receiver dat vestRef vestVal = mconcat [ spendScript (script2 receiver) vestRef () dat , payToKey receiver vestVal ]"
},
{
  "prompt": "Write a script that figures out what this (already finished) validator does using all the tools at your disposal and also write off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing.",
  "response": "{-# LANGUAGE DataKinds         #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell   #-}\n{-# LANGUAGE TypeApplications  #-}\n{-# LANGUAGE TypeFamilies      #-}\n\nmodule Homework1 where\n\nimport           Data.Maybe                (fromJust)\nimport           Plutus.V1.Ledger.Interval (contains, to)\nimport           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, POSIXTimeRange, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript)\nimport           Plutus.V2.Ledger.Contexts (txSignedBy)\nimport           PlutusTx                  (compile, unstableMakeIsData)\nimport           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (+), (||))\nimport           Prelude                   (IO, String)\nimport           Utilities                 (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, wrapValidator, writeValidatorToFile)\n\n---------------------------------------------------------------------------------------------------\n------------------------------------------ PROMPT -------------------------------------------------\n{- 1- Figure out what this (already finished) validator does using all the tools at your disposal.\n   2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing.\n   HINT: If you get stuck, take a look at Week03's lecture -}\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\ndata MisteryDatum = MisteryDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime }\n\nunstableMakeIsData ''MisteryDatum\n\n{-# INLINABLE mkMisteryValidator #-}\nmkMisteryValidator :: MisteryDatum -> () -> ScriptContext -> Bool\nmkMisteryValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2\n  where\n    txInfo :: TxInfo\n    txInfo = scriptContextTxInfo ctx\n    txValidRange :: POSIXTimeRange\n    txValidRange  = txInfoValidRange txInfo\n\n    checkCondition1 :: Bool\n    checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange\n\n    checkCondition2 :: Bool\n    checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange\n\n{-# INLINABLE  mkWrappedMisteryValidator #-}\nmkWrappedMisteryValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedMisteryValidator = wrapValidator mkMisteryValidator\n\nvalidator :: Validator\nvalidator = mkValidatorScript $$(compile [|| mkWrappedMisteryValidator ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveVal :: IO ()\nsaveVal = writeValidatorToFile \"./assets/mistery1.plutus\" validator\n\nmisteryAddressBech32 :: Network -> String\nmisteryAddressBech32 network = validatorAddressBech32 network validator\n\nprintMisteryDatumJSON :: PubKeyHash -> PubKeyHash -> String -> IO ()\nprintMisteryDatumJSON pkh1 pkh2 time = printDataToJSON $ MisteryDatum { beneficiary1 = pkh1 , beneficiary2 = pkh2 , deadline    = fromJust $ posixTimeFromIso8601 time }"
},
{
  "prompt": "Write a script that sets blockfrost endpoint, loads local stored seed as a wallet into lucid, defines the vesting plutus script, creates the vesting datum type, sets the vesting deadline, sets the vesting beneficiary to our own key, creating a datum with a beneficiary and deadline, and asynchronous function that sends an amount of Lovelace to the script with the above datum.",
  "response": "import { Data, Lucid, Blockfrost, getAddressDetails, SpendingValidator, TxHash, Datum, UTxO, Address, AddressDetails, } from \"https://deno.land/x/lucid@0.9.1/mod.ts\"\n\nimport { secretSeed } from \"./seed.ts\"\n\nconst lucid = await Lucid.new(new Blockfrost(\"https://cardano-preprod.blockfrost.io/api/v0\", \"insert your own api key here\"), \"Preprod\");\nlucid.selectWalletFromSeed(secretSeed);\n\nconst addr: Address = await lucid.wallet.address();\nconsole.log(addr);\n\nconst vestingScript: SpendingValidator = {\n  type: \"PlutusV2\",\n  script: "590b30590b2d0100003232323322323233223232323232323233223233223232323232323232333222323232322323222323253353232323253355335323235002222222222222533533355301a12001321233001225335002210031001002502c25335333573466e3c0380040ec0e84d40b8004540b4010840ec40e4d401488009400440b04cd5ce2491f62656e65666963696172792773207369676e6174757265206d697373696e670002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b00300735500322222222222200533501433501635029350052200102d335015502802d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce248114646561646c696e65206e6f7420726561636865640002b102b135001220023333573466e1cd55cea80224000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a008603e6ae84d5d1280211931901519ab9c02d02c0283333573466e1cd55ce9baa0054800080ac8c98c80a4cd5ce0160158139999ab9a3370e6aae7540192000233221233001003002375c6ae854018dd69aba135744a00c464c6405066ae700ac0a809840a44c98c809ccd5ce2490350543500029135573ca00226ea80044d55cf280089baa00132001355023221122253350011350032200122133350052200230040023335530071200100500400112223500222350032253335333500800700400215335003100110261025102612223232323253335006215333500621533350082130044984c00d261533350072130044984c00d26100d100b1533350072130044984c00d261533350062130044984c00d26100c1533350052100a100b100915333500521533350072130054984c011261533350062130054984c01126100c100a1533350062130054984c011261533350052130054984c01126100b2533350052153335007215333500721333500b00a002001161616100b153335006215333500621333500a009002001161616100a10092533350042153335006215333500621333500a009002001161616100a1533350052153335005213335009008002001161616100910082533350032153335005215333500521333500900800200116161610091533350042153335004213335008007002001161616100810072533350022153335004215333500421333500800700200116161610081533350032153335003213335007006002001161616100710061235001222222220071222003122200212220011221233001003002122123300100300212212330010030021232230023758002640026aa034446666aae7c004940288cd4024c010d5d080118019aba200201a232323333573466e1cd55cea80124000466442466002006004601c6ae854008c014d5d09aba2500223263201833573803603402c26aae7940044dd50009191919191999ab9a3370e6aae75401120002333322221233330010050040030023232323333573466e1cd55cea80124000466442466002006004602e6ae854008cd403c058d5d09aba2500223263201d33573804003e03626aae7940044dd50009aba150043335500875ca00e6ae85400cc8c8c8cccd5cd19b875001480108c84888c008010d5d09aab9e500323333573466e1d4009200223212223001004375c6ae84d55cf280211999ab9a3370ea00690001091100191931900f99ab9c02202101d01c01b135573aa00226ea8004d5d0a80119a805bae357426ae8940088c98c8064cd5ce00e00d80b89aba25001135744a00226aae7940044dd5000899aa800bae75a224464460046eac004c8004d5405c88c8cccd55cf80112804119a8039991091980080180118031aab9d5002300535573ca00460086ae8800c0604d5d080088910010910911980080200189119191999ab9a3370ea002900011a80398029aba135573ca00646666ae68cdc3a801240044a00e464c6402866ae7005c0580480444d55cea80089baa0011212230020031122001232323333573466e1d400520062321222230040053007357426aae79400c8cccd5cd19b875002480108c848888c008014c024d5d09aab9e500423333573466e1d400d20022321222230010053007357426aae7940148cccd5cd19b875004480008c848888c00c014dd71aba135573ca00c464c6402466ae7005405004003c0380344d55cea80089baa001232323333573466e1cd55cea80124000466442466002006004600a6ae854008dd69aba135744a004464c6401c66ae700440400304d55cf280089baa0012323333573466e1cd55cea800a400046eb8d5d09aab9e500223263200c33573801e01c01426ea80048c8c8c8c8c8cccd5cd19b8750014803084888888800c8cccd5cd19b875002480288488888880108cccd5cd19b875003480208cc8848888888cc004024020dd71aba15005375a6ae84d5d1280291999ab9a3370ea00890031199109111111198010048041bae35742a00e6eb8d5d09aba2500723333573466e1d40152004233221222222233006009008300c35742a0126eb8d5d09aba2500923333573466e1d40192002232122222223007008300d357426aae79402c8cccd5cd19b875007480008c848888888c014020c038d5d09aab9e500c23263201533573803002e02602402202001e01c01a26aae7540104d55cf280189aab9e5002135573ca00226ea80048c8c8c8c8cccd5cd19b875001480088ccc888488ccc00401401000cdd69aba15004375a6ae85400cdd69aba135744a00646666ae68cdc3a80124000464244600400660106ae84d55cf280311931900719ab9c01101000c00b135573aa00626ae8940044d55cf280089baa001232323333573466e1d400520022321223001003375c6ae84d55cf280191999ab9a3370ea004900011909118010019bae357426aae7940108c98c802ccd5ce00700680480409aab9d50011375400224464646666ae68cdc3a800a40084a00c46666ae68cdc3a8012400446a010600c6ae84d55cf280211999ab9a3370ea00690001091100111931900619ab9c00f00e00a009008135573aa00226ea8004484888c00c010448880048c8cccd5cd19b8750014800880188cccd5cd19b8750024800080188c98c8018cd5ce00480400200189aab9d37540029309100109100089000a490350543100112323001001223300330020020011", };\n\nconst vestingAddress: Address = lucid.utils.validatorToAddress(vestingScript);\n\nconst VestingDatum = Data.Object({\n  beneficiary: Data.String,\n  deadline: Data.BigInt,\n});\n\ntype VestingDatum = Data.Static<typeof VestingDatum>;\n\nconst deadlineDate: Date = new Date(\"2023-03-19T00:00:00Z\")\nconst deadlinePosIx = BigInt(deadlineDate.getTime());\n\nconst details: AddressDetails = getAddressDetails(addr);\nconst beneficiaryPKH: string = details.paymentCredential.hash;\n\nconst datum: VestingDatum = {\n  beneficiary: beneficiaryPKH,\n  deadline: deadlinePosIx,\n};\n\nasync function vestFunds(amount: bigint): Promise<TxHash> {\n  const dtm: Datum = Data.to<VestingDatum>(datum, VestingDatum);\n  const tx = await lucid.newTx().payToContract(vestingAddress, { inline: dtm }, { lovelace: amount }).complete();\n  const signedTx = await tx.sign().complete();\n  const txHash = await signedTx.submit();\n  return txHash\n}\n\nasync function claimVestedFunds(): Promise<TxHash> {\n  const dtm: Datum = Data.to<VestingDatum>(datum, VestingDatum);\n  const utxoAtScript: UTxO[] = await lucid.utxosAt(vestingAddress);\n\n  const ourUTxO: UTxO[] = utxoAtScript.filter((utxo) => utxo.datum == dtm);\n\n  if (ourUTxO && ourUTxO.length > 0) {\n    const tx = await lucid.newTx().collectFrom(ourUTxO, Data.void()).addSignerKey(beneficiaryPKH).attachSpendingValidator(vestingScript).validFrom(Date.now()-100000).complete();\n    const signedTx = await tx.sign().complete();\n    const txHash = await signedTx.submit();\n    return txHash\n  } else\n    return \"No UTxO's found that can be claimed\"\n}\n\n//console.log(await vestFunds(100000000n));\n//console.log(await claimVestedFunds());"
}, 
{
  "prompt": "Write a script policy that should only allow minting (or burning) of tokens if the owner of the specified PubKeyHash has signed the transaction and if the specified deadline has not passed.",
  "response": "{-# LANGUAGE DataKinds             #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE TemplateHaskell       #-}\n\nmodule Homework1 where\n\nimport           Plutus.V2.Ledger.Api\nimport           Plutus.V2.Ledger.Contexts\nimport           Plutus.V1.Ledger.Interval\nimport qualified PlutusTx\nimport           PlutusTx.Prelude     (Bool (..), ($), traceIfFalse, (&&))\nimport           Utilities            (wrapPolicy, writeCodeToFile, currencySymbol, writePolicyToFile)\nimport           Prelude              (IO, Show (show))\nimport           Text.Printf          (printf)\n\n---------------------------------------------------------------------------------------------------\n----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------\n\n{-# INLINABLE mkDeadlinePolicy #-}\n\n-- This policy should only allow minting (or burning) of tokens if the owner of the specified PubKeyHash\n-- has signed the transaction and if the specified deadline has not passed.\nmkDeadlinePolicy :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool\nmkDeadlinePolicy owner deadline () ctx =\n    traceIfFalse \"not signed by owner\" checkSig &&\n    traceIfFalse \"too late: deadline has already passed\" checkDeadline\n  where\n    txInfo :: TxInfo\n    txInfo = scriptContextTxInfo ctx\n\n    checkSig :: Bool\n    checkSig = txSignedBy txInfo owner\n\n    txValidRange :: POSIXTimeRange\n    txValidRange = txInfoValidRange txInfo\n\n    checkDeadline :: Bool\n    checkDeadline = contains (to deadline) txValidRange\n\n{-# INLINABLE mkWrappedDeadlinePolicy #-}\nmkWrappedDeadlinePolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedDeadlinePolicy pkh deadline = wrapPolicy $ mkDeadlinePolicy pkh' deadline'\n  where\n    pkh' :: PubKeyHash\n    pkh' = PlutusTx.unsafeFromBuiltinData pkh\n\n    deadline' :: POSIXTime\n    deadline' = PlutusTx.unsafeFromBuiltinData deadline\n\n\ndeadlineCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())\ndeadlineCode = $$(PlutusTx.compile [|| mkWrappedDeadlinePolicy ||])\n\n\ndeadlinePolicy :: PubKeyHash -> POSIXTime -> MintingPolicy\ndeadlinePolicy pkh deadline = mkMintingPolicyScript $\n    deadlineCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData pkh)\n                                 `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData deadline)\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveDeadlineCode :: IO ()\nsaveDeadlineCode = writeCodeToFile \"assets/deadline.plutus\"\n\nsaveDeadlinePolicy :: PubKeyHash -> POSIXTime -> IO ()\nsaveDeadlinePolicy pkh deadline =\n    writePolicyToFile  (printf \"assets/deadline-%s.plutus\" $ show pkh)  $ deadlinePolicy pkh deadline\n\ndeadlineCurrencySymbol :: PubKeyHash -> POSIXTime -> CurrencySymbol\ndeadlineCurrencySymbol pkh deadline = currencySymbol $ deadlinePolicy pkh deadline\n"
},
{
  "prompt": "Write a script minting policy for an NFT, where the minting transaction must consume the given UTxO as input and where the TokenName will be the empty ByteString.",
  "response": "{-# LANGUAGE DataKinds             #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE NoImplicitPrelude     #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE TemplateHaskell       #-}\n\nmodule Homework2 where\n\nimport           Plutus.V2.Ledger.Api\nimport           Plutus.V1.Ledger.Value (flattenValue)\nimport           Plutus.V2.Ledger.Contexts (ownCurrencySymbol)\nimport qualified PlutusTx\nimport           PlutusTx.Builtins.Internal (emptyByteString)\nimport           PlutusTx.Prelude       (Bool (..), ($), (.), (&&),  (==), any, traceIfFalse)\nimport           Utilities              (wrapPolicy, writeCodeToFile)\nimport           Prelude (IO)\n\n{-# INLINABLE tn #-}\ntn :: TokenName\ntn = TokenName emptyByteString\n\n{-# INLINABLE mkEmptyNFTPolicy #-}\n\n-- Minting policy for an NFT, where the minting transaction must consume the given UTxO as input\n-- and where the TokenName will be the empty ByteString.\nmkEmptyNFTPolicy :: TxOutRef -> () -> ScriptContext -> Bool\nmkEmptyNFTPolicy oref () ctx =\n    traceIfFalse \"UTxO not consumed\"   hasUTxO           &&\n    traceIfFalse \"wrong amount minted\" checkMintedAmount\n  where\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n\n    hasUTxO :: Bool\n    hasUTxO = any (\\i -> txInInfoOutRef i == oref) $ txInfoInputs info\n\n    checkMintedAmount :: Bool\n    checkMintedAmount = case flattenValue (txInfoMint info) of\n        [(cs, tn', amt)] -> cs  == ownCurrencySymbol ctx && tn' == tn && amt == 1\n        _                -> False\n\n{-# INLINABLE mkWrappedEmptyNFTPolicy #-}\nmkWrappedEmptyNFTPolicy :: TxOutRef -> BuiltinData -> BuiltinData -> ()\nmkWrappedEmptyNFTPolicy = wrapPolicy . mkEmptyNFTPolicy\n\nnftCode :: PlutusTx.CompiledCode (TxOutRef -> BuiltinData -> BuiltinData -> ())\nnftCode = $$(PlutusTx.compile [|| mkWrappedEmptyNFTPolicy ||])\n\nnftPolicy :: TxOutRef -> MintingPolicy\nnftPolicy oref = mkMintingPolicyScript $ \n    $$(PlutusTx.compile [|| mkWrappedEmptyNFTPolicy ||])\n        `PlutusTx.applyCode` PlutusTx.liftCode oref\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveNFTCode :: IO ()\nsaveNFTCode = writeCodeToFile \"assets/nftPolicyH2_typed.plutus\" nftCode\n"
},
{
  "prompt": "Implement a simple escrow contract that holds funds until conditions are met in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-}\n\nmodule Escrow where\n\nimport PlutusTx\nimport PlutusTx.Prelude\nimport Plutus.V2.Ledger.Contexts (ScriptContext, txSignedBy)\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport qualified PlutusTx\n\n-- Data type for the escrow contract\n{-# INLINABLE mkEscrowValidator #-}\ndata Escrow = Escrow\n    { buyer       :: PubKeyHash\n    , seller      :: PubKeyHash\n    , amount      :: Integer\n    , isCompleted :: Bool\n    }\n\nPlutusTx.unstableMakeIsData ''Escrow\n\n-- Validator function that checks if conditions are met to release funds\nmkEscrowValidator :: Escrow -> () -> ScriptContext -> Bool\nmkEscrowValidator escrow _ ctx =\n    if isCompleted escrow\n        then traceIfFalse \"Seller must sign\" (txSignedBy (scriptContextTxInfo ctx) (seller escrow))\n        else traceIfFalse \"Buyer must sign\" (txSignedBy (scriptContextTxInfo ctx) (buyer escrow))\n\n-- Function to update escrow status after meeting conditions\nfinalize :: Escrow -> Bool -> Escrow\nfinalize escrow condition = escrow { isCompleted = condition }\n\n-- Wrapping the validator\nwrappedEscrowValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nwrappedEscrowValidator = wrapValidator mkEscrowValidator\n\n-- Compiled code\nvalidatorCode :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ())\nvalidatorCode = $$(compile [|| wrappedEscrowValidator ||])\n"
},
{
  "prompt": "Create a decentralized identity verification system in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-}\n\nmodule IdentityVerification where\n\nimport PlutusTx\nimport PlutusTx.Prelude\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport qualified PlutusTx\n\n-- Data type representing a user in the identity verification system\ndata User = User\n    { pubKey   :: PubKeyHash\n    , verified :: Bool\n    }\n\nPlutusTx.unstableMakeIsData ''User\n\n-- Function to verify user identity by matching provided public key with the stored key\nverifyIdentity :: PubKeyHash -> Bool -> User -> User\nverifyIdentity key status (User k v) =\n    if k == key then User k status else User k v\n\n-- Example usage (would be done off-chain) where a verifier sets the `verified` flag\nexampleVerify :: PubKeyHash -> Bool -> User -> User\nexampleVerify = verifyIdentity\n"
},
{
  "prompt": "Develop a simple NFT minting contract in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-}\n\nmodule NFTMinting where\n\nimport PlutusTx\nimport PlutusTx.Prelude\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport qualified PlutusTx\n\n-- Data type representing an NFT with an owner and unique token ID\ndata NFT = NFT\n    { owner   :: PubKeyHash\n    , tokenId :: Integer\n    }\n\nPlutusTx.unstableMakeIsData ''NFT\n\n-- Function to mint a new NFT by associating an owner's public key with a token ID\nmintNFT :: PubKeyHash -> Integer -> NFT\nmintNFT owner tokenId = NFT { owner = owner, tokenId = tokenId }\n\n-- Example NFT minting call (off-chain) to mint an NFT for the owner\nexampleMintNFT :: PubKeyHash -> Integer -> NFT\nexampleMintNFT = mintNFT\n"
},
{
  "prompt": "Build a decentralized crowdfunding platform in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-}\n\nmodule Crowdfunding where\n\nimport PlutusTx\nimport PlutusTx.Prelude\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport qualified PlutusTx\n\n-- Data type representing a crowdfunding project with total funds and a list of contributors\ndata Project = Project\n    { totalFunds    :: Integer\n    , contributors  :: [PubKeyHash]\n    }\n\nPlutusTx.unstableMakeIsData ''Project\n\n-- Function to contribute to a project by adding funds and recording the contributor\ncontribute :: Project -> Integer -> PubKeyHash -> Project\ncontribute project amount contributor =\n    project { totalFunds = totalFunds project + amount\n            , contributors = contributor : contributors project\n            }\n\n-- Example usage of the contribute function (off-chain) to simulate adding funds\nexampleContribution :: Project -> Integer -> PubKeyHash -> Project\nexampleContribution = contribute\n"
},
{
  "prompt": "Create a loyalty rewards contract that distributes points based on purchases in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-} {-# LANGUAGE TemplateHaskell #-}\n\nmodule LoyaltyRewards where\n\nimport PlutusTx\nimport PlutusTx.Prelude\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport qualified PlutusTx\n\n-- Data type representing a loyalty reward with customer and points earned\ndata Reward = Reward\n    { customer :: PubKeyHash\n    , points   :: Integer\n    }\n\nPlutusTx.unstableMakeIsData ''Reward\n\n-- Function to update the rewards based on a purchase amount\ntrackPurchase :: PubKeyHash -> Integer -> Reward -> Reward\ntrackPurchase customer amount (Reward c p) =\n    Reward c (p + (amount `div` 10))\n\n-- Example usage of trackPurchase function (off-chain) for a purchase event\nexampleTrackPurchase :: PubKeyHash -> Integer -> Reward -> Reward\nexampleTrackPurchase = trackPurchase\n"
},
{
  "prompt": "Implement a multisignature wallet requiring multiple signatures to authorize a transaction in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule MultisigWallet where\n\nimport PlutusTx\nimport PlutusTx.Prelude\n\ndata MultisigWallet = MultisigWallet { owners :: [PubKeyHash], requiredSigs :: Integer }\n\nauthorizeTransaction :: MultisigWallet -> [PubKeyHash] -> Bool\nauthorizeTransaction wallet signers =\n    length (filter (`elem` owners wallet) signers) >= fromInteger (requiredSigs wallet)"
},
{
  "prompt": "Create a contract to mint a simple fungible token in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule TokenMinting where\n\nimport PlutusTx\nimport PlutusTx.Prelude\n\ndata Token = Token { owner :: PubKeyHash, amount :: Integer }\n\nmintToken :: PubKeyHash -> Integer -> Token\nmintToken owner amount = Token { owner = owner, amount = amount }"
},
{
  "prompt": "Implement a simple auction system using Plutus.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule SimpleAuction where\n\nimport PlutusTx\nimport PlutusTx.Prelude\n\ndata Auction = Auction { highestBid :: Integer, highestBidder :: PubKeyHash }\n\nplaceBid :: Auction -> Integer -> PubKeyHash -> Auction\nplaceBid auction newBid bidder = if newBid > highestBid auction then auction { highestBid = newBid, highestBidder = bidder } else auction"
},
{
  "prompt": "Build a smart contract for a voting system in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule VotingSystem where\n\nimport PlutusTx\nimport PlutusTx.Prelude\n\ndata Vote = Yes | No deriving (Show)\ntype Votes = [(Vote, Integer)]\n\ncastVote :: Vote -> Votes -> Votes\ncastVote vote votes = (vote, 1) : votes\n\ncountVotes :: Votes -> (Integer, Integer)\ncountVotes votes = foldr count (0, 0) votes\n  where\n    count (v, n) (yes, no) = case v of\n        Yes -> (yes + n, no)\n        No  -> (yes, no + n)"
},
{
  "prompt": "Write a script that performs basic arithmetic operations in Plutus.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule SimpleCalculator where\n\nimport PlutusTx\nimport PlutusTx.Prelude\n\nadd :: Integer -> Integer -> Integer\nadd x y = x + y\n\nsubtract :: Integer -> Integer -> Integer\nsubtract x y = x - y\n\nmultiply :: Integer -> Integer -> Integer\nmultiply x y = x * y\n\ndivide :: Integer -> Integer -> Maybe Integer\ndivide _ 0 = Nothing\ndivide x y = Just (x `div` y)"
},
{
  "prompt": "Write a script that defines how to check if a given time has passed a specified end date in a Plutus smart contract, leveraging Haskell's type system and the capabilities of the Plutus library to safely compile and execute the logic on-chain.",
  "response": "makeLift ''EndDate;\npastEndAt :: EndDate -> Integer -> CompiledCode Bool;\npastEndAt end current = pastEnd `unsafeApplyCode` liftCode plcVersion100 end `unsafeApplyCode` liftCode plcVersion100 current\n\n{- | >>> let program = getPlc $ pastEndAt Never 5 >>> pretty $ unsafeEvaluateCk $ toTerm program (abs out_Bool (type) (lam case_True out_Bool (lam case_False out_Bool case_False))) -}"
},
{
  "prompt": "Write a script that defines the a function, which takes an integer and returns a compiled program that adds 1 to that integer.",
  "response": "addOneToN :: Integer -> CompiledCode Integer;\naddOneToN n = addOne `unsafeApplyCode` liftCode plcVersion100 n\n\n{- | >>> pretty $ getPlc addOne (program 1.0.0 [ (lam addInteger (fun (con integer) (fun (con integer) (con integer))) (lam ds (con integer) [ [ addInteger ds ] (con 1) ])) (lam arg (con integer) (lam arg (con integer) [ [ (builtin addInteger) arg ] arg ])) ]) >>> let program = getPlc $ addOneToN 4 >>> pretty program (program 1.0.0 [ [ (lam addInteger (fun (con integer) (fun (con integer) (con integer))) (lam ds (con integer) [ [ addInteger ds ] (con 1) ])) (lam arg (con integer) (lam arg (con integer) [ [ (builtin addInteger) arg ] arg ])) ] (con 4) ]) >>> pretty $ unsafeEvaluateCk $ toTerm program (con 5) -}"
},
{
  "prompt": "Write a script that sets blockfrost endpoint and loads local stored seed as a wallet into lucid.",
  "response": "import { Lucid, Blockfrost, Address, MintingPolicy, PolicyId, Unit, fromText, Data, getAddressDetails, applyParamsToScript } from \"https://deno.land/x/lucid@0.9.1/mod.ts\"\nimport { blockfrostKey, secretSeed } from \"./secret.ts\"\n\nfunction readAmount(): bigint {\n  const input = prompt(\"amount: \");\n  return input ? BigInt(Number.parseInt(input)) : 1000000n;\n}\n\nconst lucid = await Lucid.new(\n  new Blockfrost(\n    \"https://cardano-preview.blockfrost.io/api/v0\",\n    blockfrostKey\n  ),\n  \"Preview\"\n);\n\nlucid.selectWalletFromSeed(secretSeed);\n\nconst addr: Address = await lucid.wallet.address();\nconsole.log(\"own address: \" + addr);\n\nconst pkh: string = getAddressDetails(addr).paymentCredential?.hash || \"\";\nconsole.log(\"own pubkey hash: \" + pkh);\n\nconst deadlineDate: Date = new Date(\"2023-12-21T00:00:00Z\");\nconst deadlinePosix = BigInt(deadlineDate.getTime());\n\nconst Params = Data.Tuple([Data.String, Data.BigInt]);\ntype Params = Data.Static<typeof Params>;\n\nconst signedPolicy: MintingPolicy = {\n  type: \"PlutusV2\",\n  script: applyParamsToScript<Params>("590af9590af60100003232323322323233223232323232323233223233223232323232323232333222323232322222323253353232323232533553353235001222222222222533533355301912001321233001225335002210031001002502b25335333573466e3c04c0040e80e44d40b4004540b0010840e840e1400440b04cd5ce2481136e6f74207369676e6564206279206f776e65720002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b003007355003222222222222005335014335016502802d3350153502900502d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce24926746f6f206c6174653a20646561646c696e652068617320616c6c7265616479207061737365640002b102b135001220023333573466e1cd55cea802a4000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00a603e6ae84d5d1280291931901519ab9c02d02c0283333573466e1cd55ce9baa0064800080ac8c98c80a4cd5ce0160158139bad006375c00c2050264c6404c66ae712410350543500028135573ca00226ea8004c8004d5408c88448894cd40044d400c88004884ccd401488008c010008ccd54c01c480040140100044888d400888d400c894ccd4ccd402001c01000854cd400c40044098409440984888c8c8c8c94ccd4018854ccd4018854ccd402084c011261300349854ccd401c84c01126130034984034402c54ccd401c84c011261300349854ccd401884c0112613003498403054ccd401484028402c402454ccd4014854ccd401c84c015261300449854ccd401884c01526130044984030402854ccd401884c015261300449854ccd401484c0152613004498402c94ccd4014854ccd401c854ccd401c84ccd402c028008004585858402c54ccd4018854ccd401884ccd40280240080045858584028402494ccd4010854ccd4018854ccd401884ccd4028024008004585858402854ccd4014854ccd401484ccd40240200080045858584024402094ccd400c854ccd4014854ccd401484ccd4024020008004585858402454ccd4010854ccd401084ccd402001c0080045858584020401c94ccd4008854ccd4010854ccd401084ccd402001c008004585858402054ccd400c854ccd400c84ccd401c018008004585858401c401848d40048888888801c488800c4888008488800448848cc00400c00848848cc00400c00848848cc00400c00848c88c008dd6000990009aa80d111999aab9f0012500a233500930043574200460066ae880080688c8c8cccd5cd19b8735573aa004900011991091980080180118071aba150023005357426ae8940088c98c8060cd5ce00d80d00b09aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180b9aba1500233500f016357426ae8940088c98c8074cd5ce01000f80d89aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403e66ae7008808407407006c4d55cea80089baa00135742a00466a016eb8d5d09aba2500223263201933573803803602e26ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355017223233335573e0044a010466a00e66442466002006004600c6aae754008c014d55cf280118021aba200301813574200222440042442446600200800624464646666ae68cdc3a800a400046a00e600a6ae84d55cf280191999ab9a3370ea00490011280391931900a19ab9c017016012011135573aa00226ea800448488c00800c44880048c8c8cccd5cd19b875001480188c848888c010014c01cd5d09aab9e500323333573466e1d400920042321222230020053009357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900919ab9c01501401000f00e00d135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011991091980080180118029aba15002375a6ae84d5d1280111931900719ab9c01101000c135573ca00226ea80048c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8030cd5ce00780700509baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c8054cd5ce00c00b80980900880800780700689aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401c66ae7004404003002c4d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200b33573801c01a01201026aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea004900111a80418031aba135573ca00846666ae68cdc3a801a40004a010464c6401866ae7003c0380280240204d55cea80089baa0011212223003004112220022323333573466e1d40052002200623333573466e1d40092000200623263200633573801201000800626aae74dd5000a4c244004244002240029210350543100112323001001223300330020020011", [pkh, deadlinePosix], Params)\n};\n\nconst policyId: PolicyId = lucid.utils.mintingPolicyToId(signedPolicy);\nconsole.log(\"minting policy: \" + policyId);\n\nconst unit: Unit = policyId + fromText(\"PPP signed and time checked\");\nconst amount: bigint = readAmount();\n\nconst tx = await lucid\n  .newTx()\n  .mintAssets({[unit]: amount}, Data.void())\n  .attachMintingPolicy(signedPolicy)\n  .addSignerKey(pkh)\n  .validTo(Date.now() + 60000)\n  .complete();\n\nconst signedTx = await tx.sign().complete();\nconst txHash = await signedTx.submit();\n\nconsole.log(\"tid: \" + txHash);"
},
{
  "prompt": "Write a script that is useful when you want to create a token minting policy that allows unrestricted minting.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Free where\n\nimport Plutus.V2.Ledger.Api (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext, mkMintingPolicyScript)\nimport qualified PlutusTx\nimport PlutusTx.Prelude (Bool (True))\nimport Prelude (IO)\nimport Utilities (currencySymbol, wrapPolicy, writePolicyToFile)\n\n{-# INLINABLE mkFreePolicy #-}\nmkFreePolicy :: () -> ScriptContext -> Bool\nmkFreePolicy () _ = True\n\n{-# INLINABLE mkWrappedFreePolicy #-}\nmkWrappedFreePolicy :: BuiltinData -> BuiltinData -> ()\nmkWrappedFreePolicy = wrapPolicy mkFreePolicy\n\nfreePolicy :: MintingPolicy\nfreePolicy = mkMintingPolicyScript $$(PlutusTx.compile [|| mkWrappedFreePolicy ||])\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveFreePolicy :: IO ()\nsaveFreePolicy = writePolicyToFile \"assets/free.plutus\" freePolicy\n\nfreeCurrencySymbol :: CurrencySymbol\nfreeCurrencySymbol = currencySymbol freePolicy"
},
{
  "prompt": "Write a script that enables the creation and management of NFTs on the Cardano blockchain by defining the rules for minting them.",
  "response": "{-# LANGUAGE DataKinds         #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell   #-}\n\nmodule NFT where\n\nimport qualified Data.ByteString.Char8      as BS8\nimport Plutus.V1.Ledger.Value     (flattenValue)\nimport Plutus.V2.Ledger.Api       (BuiltinData, CurrencySymbol, MintingPolicy, ScriptContext (scriptContextTxInfo), TokenName (unTokenName), TxId (TxId, getTxId), TxInInfo (txInInfoOutRef), TxInfo (txInfoInputs, txInfoMint), TxOutRef (TxOutRef, txOutRefId, txOutRefIdx), mkMintingPolicyScript)\nimport qualified PlutusTx\nimport PlutusTx.Builtins.Internal (BuiltinByteString (BuiltinByteString))\nimport PlutusTx.Prelude           (Bool (False), Eq ((==)), any, traceIfFalse, ($), (&&))\nimport Prelude                    (IO, Show (show), String)\nimport Text.Printf                (printf)\nimport Utilities                  (bytesToHex, currencySymbol, wrapPolicy, writeCodeToFile, writePolicyToFile)\n\n{-# INLINABLE mkNFTPolicy #-}\nmkNFTPolicy :: TxOutRef -> TokenName -> () -> ScriptContext -> Bool\nmkNFTPolicy oref tn () ctx = traceIfFalse \"UTxO not consumed\"   hasUTxO           && traceIfFalse \"wrong amount minted\" checkMintedAmount\n  where\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n\n    hasUTxO :: Bool\n    hasUTxO = any (\\i -> txInInfoOutRef i == oref) $ txInfoInputs info\n\n    checkMintedAmount :: Bool\n    checkMintedAmount = case flattenValue (txInfoMint info) of\n        [(_, tn'', amt)] -> tn'' == tn && amt == 1\n        _                -> False\n\n{-# INLINABLE mkWrappedNFTPolicy #-}\nmkWrappedNFTPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()\nmkWrappedNFTPolicy tid ix tn' = wrapPolicy $ mkNFTPolicy oref tn\n  where\n    oref :: TxOutRef\n    oref = TxOutRef (TxId $ PlutusTx.unsafeFromBuiltinData tid) (PlutusTx.unsafeFromBuiltinData ix)\n\n    tn :: TokenName\n    tn = PlutusTx.unsafeFromBuiltinData tn'\n\nnftCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ())\nnftCode = $$(PlutusTx.compile [|| mkWrappedNFTPolicy ||])\n\nnftPolicy :: TxOutRef -> TokenName -> MintingPolicy\nnftPolicy oref tn = mkMintingPolicyScript $ nftCode\n    `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ getTxId $ txOutRefId oref)\n    `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $ txOutRefIdx oref)\n    `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData tn)\n\n---------------------------------------------------------------------------------------------------\n------------------------------------- HELPER FUNCTIONS --------------------------------------------\n\nsaveNFTCode :: IO ()\nsaveNFTCode = writeCodeToFile \"assets/nft.plutus\" nftCode\n\nsaveNFTPolicy :: TxOutRef -> TokenName -> IO ()\nsaveNFTPolicy oref tn = writePolicyToFile (printf \"assets/nft-%s#%d-%s.plutus\" (show $ txOutRefId oref) (txOutRefIdx oref) $ tn') $ nftPolicy oref tn\n  where\n    tn' :: String\n    tn' = case unTokenName tn of\n        (BuiltinByteString bs) -> BS8.unpack $ bytesToHex bs\n\nnftCurrencySymbol :: TxOutRef -> TokenName -> CurrencySymbol\nnftCurrencySymbol oref tn = currencySymbol $ nftPolicy oref tn."
},
{
  "prompt": "Write a script that is designed to implement a testing framework for a token swap mechanism in a smart contract.",
  "response": "{-# LANGUAGE DataKinds          #-}\n{-# LANGUAGE FlexibleInstances  #-}\n{-# LANGUAGE NoImplicitPrelude  #-}\n{-# LANGUAGE NumericUnderscores #-}\n{-# LANGUAGE OverloadedStrings  #-}\n\nmodule Main where\n\nimport           Plutus.Model         (Run, TypedValidator (TypedValidator), adaValue, defaultBabbage, mustFail, testNoErrors, toV2, FakeCoin (FakeCoin), fakeValue, UserSpend, Tx, DatumMode (HashDatum), userSpend, payToScript, spendScript, payToKey, newUser, spend, submitTx, utxoAt, valueAt, logError)\nimport           PlutusTx.Prelude     (($), Integer, Eq ((==)), (&&))\nimport           Prelude              (IO, (.), (<>), Monoid (mconcat), Traversable (mapM), Num ((-)))\nimport qualified ExploitableSwap      as OnChain\nimport qualified PatchedSwap          as PatchedOnChain (validator)\nimport           Test.Tasty           (defaultMain, testGroup)\nimport           Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut (txOutValue))\nimport           Control.Monad        (unless)\n\nmain :: IO ()\nmain = do\n  defaultMain $ do\n    testGroup\n      \"Catch double spend with testing\"\n      [ good \"Normal spending using vulnerable script succeeds\" $ normalSpending swapScript\n      , good \"Double spending using vulnerable script succeeds\" $ doubleSpending swapScript\n      , good \"Normal spending using patched script succeeds   \" $ normalSpending patchedSwapScript\n      , bad  \"Double spending using patched script fails      \" $ doubleSpending patchedSwapScript\n      ]\n  where\n    bad msg = good msg . mustFail\n    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage\n\nscToken :: FakeCoin\nscToken = FakeCoin \"Super-Cool-Token\"\n\ntype HomeworkScript = TypedValidator OnChain.DatumSwap ()\n\nswapScript :: HomeworkScript\nswapScript = TypedValidator $ toV2 OnChain.validator\n\npatchedSwapScript :: HomeworkScript\npatchedSwapScript = TypedValidator $ toV2 PatchedOnChain.validator\n\nlockingTx :: HomeworkScript -> PubKeyHash -> Integer -> UserSpend -> Value -> Tx\nlockingTx script benef price usp val =\n  mconcat\n    [ userSpend usp\n    , payToScript script (HashDatum (OnChain.DatumSwap benef price)) val\n    ]\n\nconsumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> Value -> Tx\nconsumingTx script benef price buyer sp2 ref token =\n  mconcat\n    [ spendScript script ref () (OnChain.DatumSwap benef price)\n    , payToKey buyer token\n    , payToKey benef $ adaValue price\n    , userSpend sp2\n    ]\n\ndoubleConsumingTx :: HomeworkScript -> PubKeyHash -> Integer -> PubKeyHash -> UserSpend -> TxOutRef -> TxOutRef -> Value -> Tx\ndoubleConsumingTx script benef price buyer sp2 ref1 ref2 token =\n  mconcat\n    [ spendScript script ref1 () (OnChain.DatumSwap benef price)\n    , spendScript script ref2 () (OnChain.DatumSwap benef price)\n    , payToKey buyer $ token <> token -- Two tokens to buyer\n    , payToKey benef $ adaValue price -- Payment for only one token to beneficiary\n    , userSpend sp2\n    ]\n\nnormalSpending :: HomeworkScript -> Run ()\nnormalSpending script = do\n  u1 <- newUser (adaValue 1000 <> fakeValue scToken 1)\n  u2 <- newUser (adaValue 1000)\n  let token = adaValue 1 <> fakeValue scToken 1\n      price = 350\n  sp1 <- spend u1 token\n  submitTx u1 $ lockingTx script u1 price sp1 token\n  utxos <- utxoAt script\n  let [(ref, out)] = utxos\n  sp2 <- spend u2 (adaValue price)\n  submitTx u2 $ consumingTx script u1 price u2 sp2 ref (txOutValue out)\n  [v1, v2] <- mapM valueAt [u1, u2]\n  let expectedV1 = adaValue 999 <> adaValue price\n      expectedV2 = adaValue (1000 - price) <> token\n  unless (v1 == expectedV1 && v2 == expectedV2) $\n    logError \"Final balances are incorrect\"\n\ndoubleSpending :: HomeworkScript -> Run ()\ndoubleSpending script = do\n  u1 <- newUser (adaValue 1000 <> fakeValue scToken 2)\n  u2 <- newUser (adaValue 1000)\n  let token = adaValue 1 <> fakeValue scToken 1\n      price = 350\n  sp1 <- spend u1 token\n  submitTx u1 $ lockingTx script u1 price sp1 token\n  sp1' <- spend u1 token\n  submitTx u1 $ lockingTx script u1 price sp1' token\n  utxos <- utxoAt script\n  let [(ref1, out),(ref2, _)] = utxos\n  sp2 <- spend u2 (adaValue price)\n  submitTx u2 $ doubleConsumingTx script u1 price u2 sp2 ref1 ref2 (txOutValue out)\n  [v1, v2] <- mapM valueAt [u1, u2]\n  let expectedV1 = adaValue 998 <> adaValue price\n      expectedV2 = adaValue (1000 - price) <> token <> token\n  unless (v1 == expectedV1 && v2 == expectedV2) $\n    logError \"Final balances are incorrect\""
},
{
  "prompt": "Write a script that ensures token sales occur correctly by verifying that the buyer pays the required amount to the seller (beneficiary) before completing the transaction.",
  "response": "languageExtensions:[\"DataKinds\",\"ImportQualifiedPost\",\"NoImplicitPrelude\",\"OverloadedStrings\",\"TemplateHaskell\"], module:\"ExploitableSwap\", imports:[\"Plutus.V2.Ledger.Api (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton)\",\"Plutus.V2.Ledger.Contexts (valuePaidTo, TxInfo)\",\"PlutusTx (compile, unstableMakeIsData)\",\"PlutusTx.Builtins (BuiltinData, Integer)\",\"PlutusTx.Prelude (Bool (..), (==), traceIfFalse)\",\"Utilities (wrapValidator)\"], dataTypes:[{\"name\":\"DatumSwap\",\"fields\":[{\"name\":\"beneficiary\",\"type\":\"PubKeyHash\"},{\"name\":\"price\",\"type\":\"Integer\"}]}], functions:[{\"name\":\"mkValidator\",\"description\":\"Validates if the correct amount is paid to the beneficiary.\",\"params\":[{\"name\":\"ds\",\"type\":\"DatumSwap\"},{\"name\":\"_\",\"type\":\"()\"},{\"name\":\"ctx\",\"type\":\"ScriptContext\"}],\"body\":\"traceIfFalse \\\"Hey! You have to pay the owner!\\\" outputToBeneficiary where txInfo = scriptContextTxInfo ctx; outputToBeneficiary = valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds)\"},{\"name\":\"mkWrappedValidator\",\"description\":\"Wraps the mkValidator function.\",\"params\":[{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"},{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"},{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"}],\"body\":\"wrapValidator mkValidator\"},{\"name\":\"validator\",\"description\":\"Compiles the wrapped validator for deployment.\",\"body\":\"mkValidatorScript $$(compile [|| mkWrappedValidator ||])\"}]"
},
{
  "prompt": "Write a script that checks the value paid to the beneficiary is equal to the price, check that the validator required to spend this output is the current one, and check that we're consuming exactly one script output.",
  "response": "languageExtensions:[\"DataKinds\",\"ImportQualifiedPost\",\"NoImplicitPrelude\",\"OverloadedStrings\",\"TemplateHaskell\",\"NamedFieldPuns\"], module:\"PatchedSwap\", imports:[\"Plutus.V2.Ledger.Api (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton, TxInfo (txInfoInputs), Credential (ScriptCredential), Address (addressCredential), TxOut (txOutAddress))\",\"Plutus.V2.Ledger.Contexts (valuePaidTo, TxInInfo, txInInfoResolved, ownHash)\",\"PlutusTx (compile, unstableMakeIsData)\",\"PlutusTx.Builtins (BuiltinData, Integer)\",\"PlutusTx.Prelude (Bool (..), (==), traceIfFalse, (&&), (.), filter, ($))\",\"Utilities (wrapValidator)\"], dataTypes:[{\"name\":\"DatumSwap\",\"fields\":[{\"name\":\"beneficiary\",\"type\":\"PubKeyHash\"},{\"name\":\"price\",\"type\":\"Integer\"}]}], functions:[{\"name\":\"mkValidator\",\"description\":\"Validates that correct amount is paid to beneficiary, only one script UTxO is consumed, and current validator is required.\",\"params\":[{\"name\":\"ds\",\"type\":\"DatumSwap\"},{\"name\":\"_\",\"type\":\"()\"},{\"name\":\"ctx\",\"type\":\"ScriptContext\"}],\"body\":\"traceIfFalse \\\"Hey! You have to pay the owner!\\\" outputToBeneficiary && traceIfFalse \\\"Hey! You can only consume one script UTxO per Tx!\\\" consumeOnlyOneOutput where txInfo = scriptContextTxInfo ctx; outputToBeneficiary = valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds); getScriptInputs = filter isScriptInput allInputs where allInputs = txInfoInputs txInfo; isScriptInput i = case addressCredential . txOutAddress . txInInfoResolved $ i of ScriptCredential vh -> vh == ownHash ctx; _ -> False; consumeOnlyOneOutput = case getScriptInputs of [_] -> True; _ -> False\"},{\"name\":\"mkWrappedValidator\",\"description\":\"Wraps the mkValidator function.\",\"params\":[{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"},{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"},{\"name\":\"BuiltinData\",\"type\":\"BuiltinData\"}],\"body\":\"wrapValidator mkValidator\"},{\"name\":\"validator\",\"description\":\"Compiles the wrapped validator for deployment.\",\"body\":\"mkValidatorScript $$(compile [|| mkWrappedValidator ||])\"}]"
},
{
  "prompt": "Write a script that defines data types and logic for an auction system on the Cardano blockchain, using the Plutus platform.",
  "response": "dataTypes:[{\"name\":\"AuctionParams\",\"fields\":[{\"name\":\"apSeller\",\"type\":\"PubKeyHash\",\"description\":\"Seller's wallet address. The highest bid (if it exists) will be sent to the seller. If there is no bid, the asset auctioned will be sent to the seller.\"},{\"name\":\"apAsset\",\"type\":\"Value\",\"description\":\"The asset being auctioned. It can be a single token, multiple tokens of the same kind, or tokens of different kinds, and the token(s) can be fungible or non-fungible.\"},{\"name\":\"apMinBid\",\"type\":\"Lovelace\",\"description\":\"The minimum bid in Lovelace.\"},{\"name\":\"apEndTime\",\"type\":\"POSIXTime\",\"description\":\"The deadline for placing a bid. This is the earliest time the auction can be closed.\"}]},{\"name\":\"Bid\",\"fields\":[{\"name\":\"bBidder\",\"type\":\"PubKeyHash\",\"description\":\"Bidder's wallet address.\"},{\"name\":\"bAmount\",\"type\":\"Lovelace\",\"description\":\"Bid amount in Lovelace.\"}]},{\"name\":\"AuctionDatum\",\"description\":\"Represents the state of a smart contract, containing the highest bid so far (if exists).\",\"fields\":[{\"name\":\"adHighestBid\",\"type\":\"Maybe Bid\"}]},{\"name\":\"AuctionRedeemer\",\"description\":\"Represents an action in the auction. In this case, it is either a new bid or a request to close the auction and pay out the seller and the highest bidder.\",\"fields\":[{\"name\":\"NewBid\",\"type\":\"Bid\"},{\"name\":\"Payout\",\"type\":\"()\"}]},\"functions\":[{\"name\":\"AuctionParams makeLift\",\"description\":\"Makes 'AuctionParams' compatible with on-chain code.\"},{\"name\":\"Bid deriveShow\",\"description\":\"Derives a show instance for 'Bid'.\"},{\"name\":\"Bid makeIsData\",\"description\":\"Allows 'Bid' to be used in on-chain code.\"},{\"name\":\"AuctionDatum makeIsData\",\"description\":\"Allows 'AuctionDatum' to be used in on-chain code.\"},{\"name\":\"AuctionRedeemer makeIsData\",\"description\":\"Allows 'AuctionRedeemer' to be used in on-chain code.\"},{\"name\":\"Eq Bid instance\",\"description\":\"Defines an equality instance for 'Bid' based on bidder address and bid amount.\"}]"
},
{
  "prompt": "Write a script that defines a validator function for an auction system, ensuring that certain rules are followed when processing bids and payouts.",
  "response": "{-# INLINEABLE auctionTypedValidator #-} -- | Given the auction parameters, determines whether the transaction is allowed to spend the UTXO.\nauctionTypedValidator :: AuctionParams -> AuctionDatum -> AuctionRedeemer -> ScriptContext -> Bool\nauctionTypedValidator params (AuctionDatum highestBid) redeemer ctx@(ScriptContext txInfo _) = PlutusTx.and conditions\n\nwhere\nconditions :: [Bool]\nconditions = case redeemer of\n  NewBid bid -> [\n    -- The new bid must be higher than the highest bid.\n    -- If this is the first bid, it must be at least as high as the minimum bid.\n    sufficientBid bid,\n    -- The bid is not too late.\n    validBidTime,\n    -- The previous highest bid should be refunded.\n    refundsPreviousHighestBid,\n    -- A correct new datum is produced, containing the new highest bid.\n    correctNewDatum bid\n  ]\n  Payout -> [\n    -- The payout is not too early.\n    validPayoutTime,\n    -- The seller gets the highest bid.\n    sellerGetsHighestBid,\n    -- The highest bidder gets the asset.\n    highestBidderGetsAsset\n  ]"
},
{
  "prompt": "Write a script that is a helper within the auction smart contract that checks whether a new bid is high enough to be accepted based on the current highest bid or the minimum bid requirement.",
  "response": "Bid -> Bool\nsufficientBid (Bid _ amt) = case highestBid of\n  Just (Bid _ amt') -> amt PlutusTx.> amt';\n  Nothing -> amt PlutusTx.>= apMinBid params"
}, 
{
  "prompt": "Write a script that checks whether the current time for placing a bid is still valid within the specified auction timeframe.",
  "response": "(validBidTime :: Bool)\nvalidBidTime = to (apEndTime params) `contains` txInfoValidRange txInfo"
},
{
  "prompt": "Write a script that checks whether the previous highest bid should be refunded.",
  "response": "Bool = case highestBid of Nothing -> True; Just (Bid bidder amt) -> case PlutusTx.find (\\o -> txOutAddress o PlutusTx.== pubKeyHashAddress bidder PlutusTx.&& txOutValue o PlutusTx.== lovelaceValue amt) (txInfoOutputs txInfo) of Just _ -> True; Nothing -> PlutusTx.traceError (\"Not found: refund output\")"
},
{
  "prompt": "Write a script that verifies whether a given Bid is correctly represented in the output datum of a transaction.",
  "response": "correctNewDatum bid = case getContinuingOutputs ctx of [o] -> case txOutDatum o of OutputDatum (Datum newDatum) -> case PlutusTx.fromBuiltinData newDatum of Just bid' -> PlutusTx.traceIfFalse ( \"Invalid output datum: expected \" PlutusTx.<> PlutusTx.show bid PlutusTx.<> \", but got \" PlutusTx.<> PlutusTx.show bid' ) (bid PlutusTx.== bid'); Nothing -> PlutusTx.traceError ( \"Failed to decode output datum: \" PlutusTx.<> PlutusTx.show newDatum ); OutputDatumHash _ -> PlutusTx.traceError \"Expected OutputDatum, got OutputDatumHash\"; NoOutputDatum -> PlutusTx.traceError \"Expected OutputDatum, got NoOutputDatum\"; os -> PlutusTx.traceError ( \"Expected exactly one continuing output, got \" PlutusTx.<> PlutusTx.show (PlutusTx.length os) )"
},
{
  "prompt": "Write a script that untyped validator function and a compiled validator script for an auction in the Plutus smart contract framework.",
  "response": "{-# INLINEABLE auctionUntypedValidator #-} auctionUntypedValidator :: AuctionParams -> BuiltinData -> BuiltinData -> BuiltinData -> PlutusTx.BuiltinUnit auctionUntypedValidator params datum redeemer ctx = PlutusTx.check ( auctionTypedValidator params (PlutusTx.unsafeFromBuiltinData datum) (PlutusTx.unsafeFromBuiltinData redeemer) (PlutusTx.unsafeFromBuiltinData ctx) ) auctionValidatorScript :: AuctionParams -> CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> PlutusTx.BuiltinUnit) auctionValidatorScript params = $$(PlutusTx.compile [||auctionUntypedValidator||]) `PlutusTx.unsafeApplyCode` PlutusTx.liftCode plcVersion100 params"
},
{
  "prompt": "Write a script that sets up the foundational elements for developing Plutus smart contracts. It imports necessary libraries and establishes the language extensions required for the Plutus Tx compiler to function correctly.",
  "response": "{-# LANGUAGE DataKinds             #-}{-# LANGUAGE MultiParamTypeClasses #-}{-# LANGUAGE NoImplicitPrelude     #-}{-# LANGUAGE ScopedTypeVariables   #-}{-# LANGUAGE TemplateHaskell       #-}{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:target-version=1.0.0 #-}module BasicPlutusTx where import PlutusCore.Version (plcVersion100) -- Main Plutus Tx module. import PlutusTx -- Builtin functions. import PlutusTx.Builtins -- The Plutus Tx Prelude, discussed further below. import PlutusTx.Prelude -- Setup for doctest examples. -- $setup -- >>> import Tutorial.PlutusTx -- >>> import PlutusTx -- >>> import PlutusCore -- >>> import PlutusCore.Evaluation.Machine.Ck -- >>> import Data.Text.Prettyprint.Doc"
},
{
  "prompt": "Write a script that defines a simple Plutus Tx compiled code for representing the integer value one. It demonstrates the use of the compile function to convert a Haskell expression into a format that can be used in Plutus smart contracts.",
  "response": "integerOne :: CompiledCode Integer {- 'compile' turns the 'TExpQ Integer' into a 'TExpQ (CompiledCode Integer)' and the splice inserts it into the program. -} integerOne = $$(compile {- The quote has type 'TExpQ Integer'. We always use unbounded integers in Plutus Core, so we have to pin down this numeric literal to an ``Integer`` rather than an ``Int``. -} [|| (1 :: Integer) ||]) {- | >>> pretty $ getPlc integerOne (program 1.0.0 (con 1) ) -}"
},
{
  "prompt": "Write a script that defines a simple identity function for integers in the Plutus Tx language. The identity function returns its input without any modification, which serves as a basic example of function compilation in Plutus.",
  "response": "integerIdentity :: CompiledCode (Integer -> Integer) integerIdentity = $$(compile [|| (x:: Integer) -> x ||]) {- | >>> pretty $ getPlc integerIdentity (program 1.0.0 (lam ds (con integer) ds) ) -}"
},
{
  "prompt": "Write a script that defines a simple Plutus program that demonstrates function definitions and their use within the Plutus Tx framework.",
  "response": "{- Functions which will be used in Plutus Tx programs should be marked with GHCs 'INLINABLE' pragma. This is usually necessary for non-local functions to be usable in Plutus Tx blocks, as it instructs GHC to keep the information that the Plutus Tx compiler needs. While you may be able to get away with omitting it, it is good practice to always include it. -} {-# INLINABLE plusOne #-} plusOne :: Integer -> Integer {- 'addInteger' comes from 'PlutusTx.Builtins', and is mapped to the builtin integer addition function in Plutus Core. -} plusOne x = x `addInteger` 1 {-# INLINABLE myProgram #-} myProgram :: Integer myProgram = let plusOneLocal :: Integer -> Integer plusOneLocal x = x `addInteger` 1 localTwo = plusOneLocal 1 externalTwo = plusOne 1 in localTwo `addInteger` externalTwo functions :: CompiledCode Integer functions = $$(compile [|| myProgram ||]) {- Weve used the CK evaluator for Plutus Core to evaluate the program and check that the result was what we expected. -} {- | >>> pretty $ unsafeEvaluateCk $ toTerm $ getPlc functions (con 4) -}"
},
{
  "prompt": "Write a script that defines a Plutus program that demonstrates how to work with the Maybe type in Haskell.",
  "response": "matchMaybe :: CompiledCode (Maybe Integer -> Integer) = $$(compile [|| \\(x:: Maybe Integer) -> case x of Just n  -> n; Nothing -> 0 ||])"
},
{
  "prompt": "Write a script that defines a data type and a function in Plutus that deals with end dates, either as a specific fixed date or an indication that there is no end date (i.e., 'never').",
  "response": "data EndDate = Fixed Integer | Never; pastEnd :: CompiledCode (EndDate -> Integer -> Bool) = $$(compile [|| \\(end::EndDate) (current::Integer) -> case end of Fixed n -> n `lessThanEqualsInteger` current; Never   -> False ||])"
},
{
  "prompt": "Write a script that checks whether a given time is past the end date.",
  "response": "'pastEnd' :: CompiledCode (EndDate -> Integer -> Bool) = $$(compile [|| \\(end::EndDate) (current::Integer) -> case end of Fixed n -> n < current; Never   -> False ||])"
},
{
  "prompt": "Write a script of a 'Hello World' contract that always succeeds regardless of the context. It demonstrates the simplest possible Plutus contract.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Typed.Scripts\nimport           Playground.Contract\n\n-- | A simple contract that always succeeds\nhelloWorld :: () -> ScriptContext -> Bool\nhelloWorld _ _ = True\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| helloWorld ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\nscriptAddress :: Address\nscriptAddress = Ledger.scriptAddress validatorScript"
},
{
  "prompt": "Write a Simple Token Minting script outlining a token-minting contract.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | A basic token-minting policy that allows minting tokens based on simple conditions\ntokenMinting :: ScriptContext -> Bool\ntokenMinting _ = True -- Simplified logic that always succeeds\n\nmkPolicy :: MonetaryPolicy\nmkPolicy = mkMonetaryPolicyScript $$(PlutusTx.compile [|| tokenMinting ||])\n\npolicyScript :: Script\npolicyScript = unMonetaryPolicyScript mkPolicy\n\ncurrencySymbol :: CurrencySymbol\ncurrencySymbol = scriptCurrencySymbol mkPolicy"
},
{
  "prompt": "Write a script for a Basic Multi-Signature Wallet contract representing a multi-signature wallet.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | A basic multi-signature wallet requires signatures from multiple parties\nmultiSig :: [PubKeyHash] -> ScriptContext -> Bool\nmultiSig pkhList _ = True -- Simplified logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| multiSig ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a Simple Voting Contract where votes are cast. The logic is simplified and would normally include vote counting and validation.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Voting logic\nvote :: Bool -> ScriptContext -> Bool\nvote _ _ = True -- Simplified voting logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| vote ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a Basic Escrow Contract representing a basic escrow mechanism where funds are held until certain conditions are met.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Escrow contract logic\nescrow :: Bool -> ScriptContext -> Bool\nescrow _ _ = True -- Simplified escrow logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| escrow ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a contract that transfers tokens based on specified conditions, ensuring the conditions are checked before the transfer is executed.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Token transfer with a condition\ntransferWithCondition :: Bool -> ScriptContext -> Bool\ntransferWithCondition condition _ = condition -- Simplified condition check before transfer\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| transferWithCondition ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for an auction contract that models a basic auction process, including bids, deadlines, and winner determination.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Auction contract logic\nauction :: Bool -> ScriptContext -> Bool\nauction _ _ = True -- Simplified auction logic, for example checking the highest bid and deadline.\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| auction ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for minting a simple non-fungible token (NFT), with logic for creating unique token IDs and metadata.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | NFT minting logic\nmintNFT :: ScriptContext -> Bool\nmintNFT _ = True -- Simplified NFT minting logic, potentially involving unique token ID generation and metadata.\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| mintNFT ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a basic crowdfunding contract that allows users to contribute funds, with the ability to set funding targets and distribute rewards.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Crowdfunding contract logic\ncrowdfunding :: Bool -> ScriptContext -> Bool\ncrowdfunding _ _ = True -- Simplified crowdfunding logic, can include fund contribution, target checking, and reward distribution.\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| crowdfunding ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a timelock contract that ensures funds can only be spent after a specified time, using POSIX time to define the unlock conditions.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Timelock contract logic\ntimelock :: POSIXTime -> ScriptContext -> Bool\ntimelock unlockTime ctx = to (from unlockTime) <= to (from (txInfoValidRange (scriptContextTxInfo ctx)))\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| timelock ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a simple staking contract that allows users to stake a certain amount, ensuring the stake amount is positive.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Simple staking contract logic\nstaking :: Integer -> ScriptContext -> Bool\nstaking stakeAmount _ = stakeAmount > 0 -- Simplified staking condition, ensuring stake is positive.\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| staking ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a whitelist contract that enforces a list of approved addresses, ensuring that only whitelisted addresses can interact with the contract.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Whitelist logic for permitted addresses\nwhitelist :: [PubKeyHash] -> ScriptContext -> Bool\nwhitelist allowed ctx = any (\pkh -> pkh `elem` allowed) (map txInPubKeyHash (txInfoInputs (scriptContextTxInfo ctx)))\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| whitelist ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a simple DeFi lending contract that requires a positive lending amount, with the logic simplified for basic lending without interest or collateral handling.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Basic DeFi lending logic\nlending :: Integer -> ScriptContext -> Bool\nlending amount _ = amount > 0 -- Simplified lending logic, ensuring the lending amount is positive.\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| lending ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a decentralized exchange (DEX) order matching contract, with simplified logic for matching orders. Real implementations would require more complex features for order matching and execution.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | DEX order matching logic\norderMatching :: ScriptContext -> Bool\norderMatching _ = True -- Simplified order matching, real implementations would include matching buy and sell orders, price validation, etc.\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| orderMatching ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a token swap contract that serves as a placeholder for swapping tokens, without implementing the actual swapping logic.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Token swap logic\ntokenSwap :: ScriptContext -> Bool\ntokenSwap _ = True -- Simplified placeholder logic for token swap, actual swap logic is not implemented.\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| tokenSwap ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a simple insurance contract that models an insurance mechanism, checking conditions but without the full implementation of policy details.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Basic insurance logic\ninsurance :: Bool -> ScriptContext -> Bool\ninsurance _ _ = True -- Simplified insurance logic, actual conditions like policy terms are not implemented.\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| insurance ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a complex voting contract that allows voting on multiple options, ensuring the selected option falls within a specified range.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Complex voting contract with multiple options\nvoteComplex :: Integer -> ScriptContext -> Bool\nvoteComplex option _ = option >= 1 && option <= 5 -- Example with options 1 to 5, ensuring the option is within the range.\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| voteComplex ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for dynamic NFT minting, where each NFT is minted with dynamic metadata. The contract should include basic logic for minting, with more complex metadata management to be implemented.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | NFT minting with dynamic metadata\nmintDynamicNFT :: BuiltinData -> ScriptContext -> Bool\nmintDynamicNFT _ _ = True -- Simplified minting logic with metadata (dynamic management not yet implemented).\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| mintDynamicNFT ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a bonding curve contract that models a basic bonding curve, without implementing the actual mathematical curve used in bonding.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Bonding curve logic\nbondingCurve :: Integer -> ScriptContext -> Bool\nbondingCurve _ _ = True -- Simplified bonding curve logic (mathematical curve not implemented).\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| bondingCurve ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for an Automated Market Maker (AMM) contract that represents basic functionality, with the real implementation requiring liquidity pools and trading logic.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Automated Market Maker (AMM) logic\namm :: ScriptContext -> Bool\namm _ = True -- Simplified AMM logic (real liquidity pools and trading not implemented).\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| amm ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a basic yield farming contract that models a yield farming mechanism, with reward distribution logic to be implemented based on staked amounts.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Yield farming logic\nyieldFarming :: Integer -> ScriptContext -> Bool\nyieldFarming _ _ = True -- Simplified yield farming logic (reward distribution not implemented).\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| yieldFarming ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a governance voting contract that allows voting on multiple options, ensuring the selected vote is within a valid range of choices.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Governance voting logic\ngovernanceVoting :: Integer -> ScriptContext -> Bool\ngovernanceVoting vote _ = vote >= 1 && vote <= 10 -- Example voting options 1 to 10\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| governanceVoting ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a complex multi-signature wallet contract that includes delegation capabilities, with simplified logic for illustration.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Multi-signature wallet with delegation\nmultiSigWithDelegation :: [PubKeyHash] -> ScriptContext -> Bool\nmultiSigWithDelegation _ _ = True -- Simplified multi-signature logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| multiSigWithDelegation ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for an on-chain data oracle contract that provides external data, with basic logic for data retrieval and secure updating mechanisms to be implemented.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | On-chain data oracle logic\ndataOracle :: BuiltinData -> ScriptContext -> Bool\ndataOracle _ _ = True -- Simplified data oracle logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| dataOracle ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a layered DeFi protocol contract that models lending and borrowing, with simplified logic that would need more detail for a real-world implementation.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Layered DeFi protocol logic\ndefiProtocol :: Integer -> ScriptContext -> Bool\ndefiProtocol _ _ = True -- Simplified DeFi protocol logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| defiProtocol ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a decentralized identity verification contract that models basic identity verification, with more detailed verification processes to be included in a real implementation.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Decentralized identity verification logic\nidentityVerification :: BuiltinData -> ScriptContext -> Bool\nidentityVerification _ _ = True -- Simplified identity verification logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| identityVerification ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a cross-chain token transfer contract that facilitates token transfers across different blockchains, with cross-chain communication mechanisms to be implemented in a real-world scenario.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Cross-chain token transfer logic\ncrossChainTransfer :: BuiltinData -> ScriptContext -> Bool\ncrossChainTransfer _ _ = True -- Simplified cross-chain transfer logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| crossChainTransfer ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a Decentralized Autonomous Organization (DAO) framework contract, with simplified logic for governance and decision-making mechanisms to be implemented in a real-world scenario.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | DAO framework logic\ndaoFramework :: Integer -> ScriptContext -> Bool\ndaoFramework _ _ = True -- Simplified DAO logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| daoFramework ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a privacy-preserving smart contract that aims to protect data privacy during execution, with cryptographic techniques to be implemented for ensuring data privacy.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Privacy-preserving smart contract logic\nprivacyPreserving :: BuiltinData -> ScriptContext -> Bool\nprivacyPreserving _ _ = True -- Simplified privacy logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| privacyPreserving ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for an advanced financial derivatives contract, with simplified logic for modeling complex financial instruments, requiring more detailed implementation for real-world scenarios.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Advanced financial derivatives logic\nfinancialDerivatives :: Integer -> ScriptContext -> Bool\nfinancialDerivatives _ _ = True -- Simplified derivatives logic\n\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| financialDerivatives ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator"
},
{
  "prompt": "Write a script for a Hello World contract that defines a `helloWorld` function, which always returns True, ensuring the contract always succeeds. Include boilerplate code to compile the contract and retrieve the validator script address.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\nimport           Prelude (IO)\n\n-- | The helloWorld validator always succeeds\nhelloWorld :: ScriptContext -> Bool\nhelloWorld _ = True\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| helloWorld ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a simple token minting contract that checks if the minted value matches the expected token and amount. Replace 'TokenSymbol' with your actual token symbol.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Token minting logic\nmint :: TokenName -> Integer -> ScriptContext -> Bool\nmint tn amount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        minted = valueMint txInfo\n    in\n        -- Check if the minted value matches the expected token and amount\n        minted == singleton (CurrencySymbol \"TokenSymbol\") tn amount\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| mint ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a simple token minting contract that checks if the minted value matches the expected token and amount. Replace 'TokenSymbol' with your actual token symbol.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Token minting logic\nmint :: TokenName -> Integer -> ScriptContext -> Bool\nmint tn amount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        minted = valueMint txInfo\n    in\n        -- Check if the minted value matches the expected token and amount\n        minted == singleton (CurrencySymbol \"TokenSymbol\") tn amount\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| mint ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a simple voting contract that handles a basic voting mechanism, verifying that the provided vote option is within a list of valid options.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Voting logic\nvote :: Integer -> ScriptContext -> Bool\nvote option ctx =\n    let\n        validOptions = [1, 2, 3]  -- Example valid voting options\n    in\n        -- Check if the vote option is one of the valid options\n        option `elem` validOptions\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| vote ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a basic escrow contract that checks if the payer is among the signatories and ensures a condition is met before releasing the funds.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Escrow contract logic\nescrow :: PubKeyHash -> Bool -> ScriptContext -> Bool\nescrow payer condition ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the payer is the one who signed the transaction\n        isPayer = payer `elem` txInfoSignatories txInfo\n        -- Check if the condition is met\n        conditionMet = condition\n    in\n        isPayer && conditionMet\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| escrow ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a token swap contract that verifies the amount of tokens being swapped matches the expected amount before executing the swap.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Token swap logic\nswapTokens :: CurrencySymbol -> TokenName -> Integer -> ScriptContext -> Bool\nswapTokens currencySymbol tokenName amount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the amount of the token in the swap is correct\n        expectedAmount = singleton currencySymbol tokenName amount\n        swappedAmount = valueSpent txInfo\n    in\n        -- Check if the token amount matches\n        swappedAmount == expectedAmount\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| swapTokens ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a decentralized exchange (DEX) order matching contract that verifies the order amount matches the expected amount before executing the trade.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Order matching logic for DEX\nmatchOrder :: CurrencySymbol -> TokenName -> Integer -> ScriptContext -> Bool\nmatchOrder currencySymbol tokenName amount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the order amount matches the expected amount\n        expectedAmount = singleton currencySymbol tokenName amount\n        matchedAmount = valueSpent txInfo\n    in\n        -- Check if the token amount matches\n        matchedAmount == expectedAmount\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| matchOrder ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for an NFT minting and transfer contract that verifies the amount of NFTs minted and transferred matches the expected amount before execution.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | NFT minting and transfer logic\nnftMintTransfer :: CurrencySymbol -> TokenName -> Integer -> ScriptContext -> Bool\nnftMintTransfer currencySymbol tokenName amount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        mintedAmount = valueMint txInfo\n        transferredAmount = valueSpent txInfo\n    in\n        -- Check if the minted and transferred amount matches\n        mintedAmount == singleton currencySymbol tokenName amount &&\n        transferredAmount == singleton currencySymbol tokenName amount\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| nftMintTransfer ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a lending protocol contract that requires collateral, verifying that the collateral provided in the transaction meets the required amount before proceeding.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Lending protocol with collateral logic\nlendingWithCollateral :: Integer -> Integer -> ScriptContext -> Bool\nlendingWithCollateral loanAmount collateralAmount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Ensure collateral is provided for the loan\n        collateralProvided = valueSpent txInfo\n        sufficientCollateral = collateralProvided >= singleton \"CollateralSymbol\" \"CollateralToken\" collateralAmount\n    in\n        -- Check if collateral is sufficient\n        sufficientCollateral\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| lendingWithCollateral ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a staking rewards contract that calculates and verifies the staking rewards, ensuring the actual rewards match the expected rewards.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Staking rewards logic\nstakingRewards :: Integer -> ScriptContext -> Bool\nstakingRewards expectedRewards ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Calculate the actual rewards\n        actualRewards = valueSpent txInfo\n    in\n        -- Check if the actual rewards match the expected rewards\n        actualRewards == singleton \"RewardTokenSymbol\" \"RewardToken\" expectedRewards\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| stakingRewards ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a charity donation contract that ensures the correct amount is donated, verifying that the donation amount matches the expected amount before proceeding.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Charity donation logic\ncharityDonation :: Integer -> ScriptContext -> Bool\ncharityDonation donationAmount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Ensure that the correct donation amount is received\n        receivedAmount = valueSpent txInfo\n    in\n        -- Check if the donation amount is correct\n        receivedAmount == singleton \"CharityTokenSymbol\" \"CharityToken\" donationAmount\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| charityDonation ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for an insurance claim contract that verifies the claim amount and ensures the required conditions are met before processing the claim.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Insurance claim logic\ninsuranceClaim :: Integer -> Bool -> ScriptContext -> Bool\ninsuranceClaim claimAmount condition ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Ensure the claim amount is correct and condition is met\n        claimedAmount = valueSpent txInfo\n    in\n        -- Check if the claim amount and condition are valid\n        claimedAmount == singleton \"InsuranceTokenSymbol\" \"InsuranceToken\" claimAmount &&\n        condition\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| insuranceClaim ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a subscription service contract that verifies if the correct subscription fee is paid before granting access to the service.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Subscription service logic\nsubscriptionService :: Integer -> ScriptContext -> Bool\nsubscriptionService subscriptionFee ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Ensure that the subscription fee is paid\n        paidAmount = valueSpent txInfo\n    in\n        -- Check if the paid amount matches the subscription fee\n        paidAmount == singleton \"SubscriptionTokenSymbol\" \"SubscriptionToken\" subscriptionFee\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| subscriptionService ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for an asset management contract that verifies the amount of the asset being managed matches the expected amount before allowing transfer or storage.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Asset management logic\nmanageAsset :: CurrencySymbol -> TokenName -> Integer -> ScriptContext -> Bool\nmanageAsset currencySymbol tokenName expectedAmount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Get the amount of the asset being managed\n        managedAmount = valueSpent txInfo\n        -- Define the expected asset amount\n        expectedAsset = singleton currencySymbol tokenName expectedAmount\n    in\n        -- Check if the managed amount matches the expected amount\n        managedAmount == expectedAsset\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| manageAsset ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a property rental contract that ensures the rental amount paid matches the expected amount and verifies that the landlord is one of the signatories before processing the transaction.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Property rental logic\nrentalAgreement :: Integer -> PubKeyHash -> ScriptContext -> Bool\nrentalAgreement rentalAmount landlord ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the rental amount matches\n        paidAmount = valueSpent txInfo\n        -- Ensure the landlord is the one who signed the transaction\n        isLandlord = landlord `elem` txInfoSignatories txInfo\n    in\n        -- Check if the rental amount is correct and the landlord is the signatory\n        paidAmount == singleton \"RentalTokenSymbol\" \"RentalToken\" rentalAmount &&\n        isLandlord\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| rentalAgreement ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a conditional payment contract that ensures the payment is made only if a specified condition is met, verifying that the payment amount is correct and the condition (a boolean value) is true.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Conditional payment logic\nconditionalPayment :: Integer -> Bool -> ScriptContext -> Bool\nconditionalPayment paymentAmount condition ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the payment amount matches the expected amount\n        paidAmount = valueSpent txInfo\n        -- Ensure the condition is met\n        conditionMet = condition\n    in\n        -- Check if the payment amount is correct and the condition is satisfied\n        paidAmount == singleton \"PaymentTokenSymbol\" \"PaymentToken\" paymentAmount &&\n        conditionMet\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| conditionalPayment ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for an escrow contract with a timelock, where funds are only released if the timelock has expired, the payer is a signatory, and the specified condition is met.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Escrow contract with timelock\nescrowWithTimelock :: POSIXTime -> PubKeyHash -> Bool -> ScriptContext -> Bool\nescrowWithTimelock releaseTime payer condition ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the timelock has expired\n        currentTime = txInfoValidRange txInfo\n        timelockExpired = currentTime >= releaseTime\n        -- Ensure the payer is among the signatories\n        isPayer = payer `elem` txInfoSignatories txInfo\n        -- Check if the condition is met\n        conditionMet = condition\n    in\n        -- Check if the timelock is expired and the condition is met\n        timelockExpired && isPayer && conditionMet\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| escrowWithTimelock ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a dynamic asset pricing contract that verifies the amount paid for an asset is greater than or equal to the asset price before completing the transaction.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Dynamic asset pricing logic\ndynamicPricing :: Integer -> Integer -> ScriptContext -> Bool\ndynamicPricing assetPrice paidAmount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the asset price matches the paid amount\n        actualAmount = valueSpent txInfo\n    in\n        -- Check if the paid amount matches the asset price\n        paidAmount >= assetPrice\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| dynamicPricing ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for an auction contract that ensures the bid amount does not exceed the highest bid and verifies that the correct bidder is participating before accepting the bid.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Auction logic\nauction :: Integer -> PubKeyHash -> ScriptContext -> Bool\nauction highestBid bidder ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Ensure the highest bid is not exceeded\n        bidAmount = valueSpent txInfo\n        isHighestBidder = bidder `elem` txInfoSignatories txInfo\n    in\n        -- Check if the bid amount is valid and the bidder is correct\n        bidAmount <= highestBid &&\n        isHighestBidder\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| auction ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a vesting contract that ensures tokens are only released if the current time is past the vesting release time and verifies that the vested amount is correct.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Vesting logic\nvesting :: POSIXTime -> Integer -> ScriptContext -> Bool\nvesting releaseTime vestedAmount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the current time is past the release time\n        currentTime = txInfoValidRange txInfo\n        timePassed = currentTime >= releaseTime\n        -- Ensure the vested amount is correct\n        amountVested = valueSpent txInfo\n    in\n        -- Check if the time has passed and the amount vested is correct\n        timePassed && amountVested == singleton \"VestingTokenSymbol\" \"VestingToken\" vestedAmount\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| vesting ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a lottery contract that verifies the ticket price is correct and ensures the winner is among the signatories before awarding the prize.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Lottery logic\nlottery :: Integer -> PubKeyHash -> ScriptContext -> Bool\nlottery ticketPrice winner ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Ensure the ticket price is paid\n        paidAmount = valueSpent txInfo\n        -- Ensure the winner is correct\n        isWinner = winner `elem` txInfoSignatories txInfo\n    in\n        -- Check if the ticket price is correct and the winner is correct\n        paidAmount == singleton \"LotteryTokenSymbol\" \"LotteryToken\" ticketPrice &&\n        isWinner\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| lottery ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a dividend distribution contract that ensures the amount of dividends distributed matches the expected dividend amount before proceeding with the distribution.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Dividend distribution logic\ndistributeDividends :: Integer -> ScriptContext -> Bool\ndistributeDividends dividendAmount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Ensure the correct dividend amount is distributed\n        distributedAmount = valueSpent txInfo\n    in\n        -- Check if the distributed amount matches the dividend amount\n        distributedAmount == singleton \"DividendTokenSymbol\" \"DividendToken\" dividendAmount\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| distributeDividends ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a digital identity verification contract that checks if the specified public key hash is among the signatories in the transaction before verifying the identity.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Digital identity verification logic\nverifyIdentity :: PubKeyHash -> ScriptContext -> Bool\nverifyIdentity userPubKeyHash ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the user is among the signatories\n        isVerifiedUser = userPubKeyHash `elem` txInfoSignatories txInfo\n    in\n        -- Ensure the user identity is verified\n        isVerifiedUser\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| verifyIdentity ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a simple voting contract that verifies the voter is among the signatories and ensures the voting choice is valid before accepting the vote.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Simple voting logic\nvote :: Integer -> PubKeyHash -> ScriptContext -> Bool\nvote choice voter ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Ensure the voter is among the signatories\n        isVoter = voter `elem` txInfoSignatories txInfo\n        -- Ensure the choice is valid (e.g., choice >= 0)\n        isValidChoice = choice >= 0\n    in\n        -- Check if the voter is valid and the choice is valid\n        isVoter && isValidChoice\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| vote ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a rewards redemption contract that verifies the amount of rewards redeemed matches the expected amount before processing the redemption.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Rewards redemption logic\nredeemRewards :: Integer -> ScriptContext -> Bool\nredeemRewards rewardsAmount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Ensure the correct amount of rewards is redeemed\n        redeemedAmount = valueSpent txInfo\n    in\n        -- Check if the redeemed amount matches the rewards amount\n        redeemedAmount == singleton \"RewardsTokenSymbol\" \"RewardsToken\" rewardsAmount\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| redeemRewards ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a token swap contract that verifies the amount of tokens being swapped from one type to another matches the expected amounts before executing the swap.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Token swap logic\ntokenSwap :: CurrencySymbol -> TokenName -> Integer -> CurrencySymbol -> TokenName -> Integer -> ScriptContext -> Bool\ntokenSwap fromCurrency fromToken fromAmount toCurrency toToken toAmount ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Get the amounts of tokens being swapped\n        fromAmountSpent = valueSpent txInfo `valueOf` fromCurrency fromToken\n        toAmountReceived = valueSpent txInfo `valueOf` toCurrency toToken\n    in\n        -- Check if the correct amounts of tokens are swapped\n        fromAmountSpent == fromAmount && toAmountReceived == toAmount\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| tokenSwap ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a charity donation contract that verifies the donation amount is correct and ensures the charity address is among the signatories before processing the donation.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Charity donation logic\ncharityDonation :: Integer -> PubKeyHash -> ScriptContext -> Bool\ncharityDonation donationAmount charityAddr ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the donation amount is correct\n        donatedAmount = valueSpent txInfo\n        -- Ensure the charity address is among the signatories\n        isCharity = charityAddr `elem` txInfoSignatories txInfo\n    in\n        -- Check if the donation amount is correct and the charity address is verified\n        donatedAmount == singleton \"CharityTokenSymbol\" \"CharityToken\" donationAmount &&\n        isCharity\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| charityDonation ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a license management contract that ensures the license fee is paid and verifies that the license holder is a signatory before granting access to the license.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | License management logic\nlicenseManagement :: PubKeyHash -> Integer -> ScriptContext -> Bool\nlicenseManagement licenseHolder licenseFee ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the license fee is paid\n        paidAmount = valueSpent txInfo\n        -- Ensure the license holder is among the signatories\n        isLicenseHolder = licenseHolder `elem` txInfoSignatories txInfo\n    in\n        -- Check if the paid amount matches the license fee and the holder is correct\n        paidAmount == singleton \"LicenseTokenSymbol\" \"LicenseToken\" licenseFee &&\n        isLicenseHolder\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| licenseManagement ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a reward points redemption contract that verifies the points redeemed match the required amount and ensures the user is a signatory before processing the redemption.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Reward points redemption logic\nredeemPoints :: Integer -> PubKeyHash -> ScriptContext -> Bool\nredeemPoints pointsRequired user ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the points redeemed match the required points\n        redeemedPoints = valueSpent txInfo\n        -- Ensure the user is among the signatories\n        isUser = user `elem` txInfoSignatories txInfo\n    in\n        -- Check if the redeemed points match the required points and the user is correct\n        redeemedPoints == singleton \"RewardPointsTokenSymbol\" \"RewardPointsToken\" pointsRequired &&\n        isUser\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| redeemPoints ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script for a subscription management contract that ensures the subscription fee is paid and verifies that the subscriber is a signatory before granting access to the subscription.",
  "response": "{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\n\n-- | Subscription management logic\nsubscriptionManagement :: Integer -> PubKeyHash -> ScriptContext -> Bool\nsubscriptionManagement subscriptionFee subscriber ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        -- Check if the subscription fee is paid\n        paidAmount = valueSpent txInfo\n        -- Ensure the subscriber is among the signatories\n        isSubscriber = subscriber `elem` txInfoSignatories txInfo\n    in\n        -- Check if the paid amount matches the subscription fee and the subscriber is correct\n        paidAmount == singleton \"SubscriptionTokenSymbol\" \"SubscriptionToken\" subscriptionFee &&\n        isSubscriber\n\n-- Boilerplate code for compiling the validator\nmkValidator :: Validator\nmkValidator = mkValidatorScript $$(PlutusTx.compile [|| subscriptionManagement ||])\n\nvalidatorScript :: Script\nvalidatorScript = unValidatorScript mkValidator\n\n-- Utility function to get the script address\nscriptAddress :: Address\nscriptAddress = scriptAddress validatorScript"
},
{
  "prompt": "Write a script to create a public key address for a wallet controlled by a public key, using PubKeyHash to derive the address.",
  "response": "import Plutus.V1.Ledger.Address (Address(..), pubKeyHashAddress)\nimport Plutus.V1.Ledger.Crypto (PubKeyHash)\n\n-- Suppose you have a public key hash\nmyPubKeyHash :: PubKeyHash\nmyPubKeyHash = ...\n\n-- Create a public key address\nmyAddress :: Address\nmyAddress = pubKeyHashAddress myPubKeyHash"
},
{
  "prompt": "Write a script to create a script address for an address controlled by a smart contract, using ScriptHash to derive the address.",
  "response": "import Plutus.V1.Ledger.Address (Address(..), scriptHashAddress)\nimport Plutus.V1.Ledger.Scripts (ScriptHash)\n\n-- Suppose you have a script hash\nmyScriptHash :: ScriptHash\nmyScriptHash = ...\n\n-- Create a script address\nmyScriptAddress :: Address\nmyScriptAddress = scriptHashAddress myScriptHash"
},
{
  "prompt": "Write a script to check the type of an address, verifying whether it is controlled by a public key or a script, using appropriate methods to differentiate between the two.",
  "response": "case addressCredential myAddress of\n    PubKeyCredential pkh -> putStrLn \"This is a public key address.\"\n    ScriptCredential sh  -> putStrLn \"This is a script address.\""
},
{
  "prompt": "Write a script to create an address with a staking credential, utilizing the appropriate methods for attaching the staking key or credential to the address.",
  "response": "import Plutus.V1.Ledger.Address (Address(..), pubKeyHashAddress)\nimport Plutus.V1.Ledger.Crypto (PubKeyHash)\nimport Plutus.V1.Ledger.Credential (StakingCredential)\n\nmyStakingCredential :: StakingCredential\nmyStakingCredential = ...\n\n-- Address with staking credential\nmyStakingAddress :: Address\nmyStakingAddress = Address (PubKeyCredential myPubKeyHash) (Just myStakingCredential)"
},
{
  "prompt": "Write a script to verify if a transaction is signed by a specific public key. The script should accept a `PubKeyHash` (requiredPubKey) as input, representing the public key that must have signed the transaction. It should use the `txSignedBy` function to check if the transaction in the `ScriptContext` is signed by the required public key. If the public key is not among the signatories, the contract should fail with an error message.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule VerifySignature where\n\nimport Plutus.V1.Ledger.Contexts (txSignedBy, ScriptContext, TxInfo, scriptContextTxInfo)\nimport Plutus.V2.Ledger.Api (PubKeyHash)\nimport PlutusTx.Prelude (Bool, traceIfFalse)\n\n-- Validator function: checks if a transaction is signed by a specific public key\nsignedByValidator :: PubKeyHash -> () -> () -> ScriptContext -> Bool\nsignedByValidator requiredPubKey _ _ ctx = \n    let\n        txInfo :: TxInfo\n        txInfo = scriptContextTxInfo ctx\n    in\n        traceIfFalse \"Transaction not signed by required public key\" $ txSignedBy txInfo requiredPubKey"
},
{
  "prompt": "Write a script to check the total value sent to a specific address. The script should take an `Address` (recipientAddr) and a `Value` (requiredValue) as input. It should use the `valuePaidTo` function to check how much value has been paid to the given address in the current transaction. If the value sent is less than the required amount, the contract should fail.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule ValuePaidTo where\n\nimport Plutus.V1.Ledger.Contexts (valuePaidTo, ScriptContext, scriptContextTxInfo)\nimport Plutus.V2.Ledger.Api (Address, Value)\nimport PlutusTx.Prelude (Bool, traceIfFalse, (>=))\n\n-- Validator function: checks if a specific value is paid to an address\npaidToAddressValidator :: Address -> Value -> () -> () -> ScriptContext -> Bool\npaidToAddressValidator recipientAddr requiredValue _ _ ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        valuePaid = valuePaidTo txInfo recipientAddr\n    in\n        traceIfFalse \"Not enough value paid to address\" $ valuePaid >= requiredValue"
},
{
  "prompt": "Write a script to ensure a specific output is spent in a transaction. The script should take a `TxId` and an output index as input, representing the output expected to be spent. It should use the `spendsOutput` function to check if the output with the given `TxId` and index is spent in the transaction. If the output is not spent, the contract should fail.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule OutputSpent where\n\nimport Plutus.V1.Ledger.Contexts (spendsOutput, ScriptContext, scriptContextTxInfo)\nimport Plutus.V2.Ledger.Api (TxId)\nimport PlutusTx.Prelude (Bool, traceIfFalse)\n\n-- Validator function: checks if a specific output is spent\noutputSpentValidator :: TxId -> Integer -> () -> () -> ScriptContext -> Bool\noutputSpentValidator txId outputIndex _ _ ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n    in\n        traceIfFalse \"Required output not spent\" $ spendsOutput txInfo txId outputIndex"
},
{
  "prompt": "Write a script to check the script outputs at a specific address. The script should use `scriptOutputsAt` to retrieve the list of outputs locked by the given script address (`scriptAddr`). It should then check if the total value locked in those outputs is at least the required amount (`minValue`). If the value locked is less than the required amount, the contract should fail.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule ScriptOutputs where\n\nimport Plutus.V1.Ledger.Contexts (scriptOutputsAt, ScriptContext, scriptContextTxInfo)\nimport Plutus.V2.Ledger.Api (Address, Value)\nimport PlutusTx.Prelude (Bool, traceIfFalse)\n\n-- Validator function: check if at least some value is locked at a script address\nvalueLockedAtScript :: Address -> Value -> () -> () -> ScriptContext -> Bool\nvalueLockedAtScript scriptAddr minValue _ _ ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        outputs = scriptOutputsAt scriptAddr txInfo\n        totalValue = foldMap snd outputs\n    in\n        traceIfFalse \"Not enough value locked at script\" $ totalValue >= minValue"
},
{
  "prompt": "Write a script to find the input being spent by the script. The script should use the `findOwnInput` function to retrieve the input that is being spent by the currently running script. If no such input is found, the contract should fail.",
  "response": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE NoImplicitPrelude #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule FindOwnInput where\n\nimport Plutus.V1.Ledger.Contexts (findOwnInput, ScriptContext)\nimport Plutus.V2.Ledger.Api (TxInInfo)\nimport PlutusTx.Prelude (Maybe, traceIfNothing)\n\n-- Validator function: ensure the script finds its own input\nfindOwnInputValidator :: () -> () -> ScriptContext -> Bool\nfindOwnInputValidator _ _ ctx =\n    case findOwnInput ctx of\n        Nothing -> traceIfNothing \"Own input not found\" Nothing\n        Just _  -> True"
},
{
  "prompt": "Write a script to check if a specific time falls within a given interval. Use the `interval` function to define the time range (e.g., from 1000 to 2000) and the `contains` function to check if the specified time (e.g., 1500) is within this range. The script should return `True` if the time is within the interval.",
  "response": "import Plutus.V1.Ledger.Interval\nimport Plutus.V1.Ledger.Time (POSIXTime)\n\n-- Create an interval from 1000 to 2000 POSIXTime\nmyInterval :: Interval POSIXTime\nmyInterval = interval 1000 2000\n\n-- Check if the time 1500 falls within the interval\ncheckTime :: POSIXTime -> Bool\ncheckTime t = contains myInterval t\n\n-- Test\nmain :: IO ()\nmain = print $ checkTime 1500  -- True"
},
{
  "prompt": "Write a script to check if two intervals overlap. Define two intervals using the `interval` function (e.g., from 1000 to 2000 and from 1500 to 2500), and use the `overlaps` function to determine if they intersect. The script should return `True` if the intervals overlap.",
  "response": "import Plutus.V1.Ledger.Interval\nimport Plutus.V1.Ledger.Time (POSIXTime)\n\n-- Create two intervals\ninterval1 :: Interval POSIXTime\ninterval1 = interval 1000 2000\n\ninterval2 :: Interval POSIXTime\ninterval2 = interval 1500 2500\n\n-- Check if the two intervals overlap\ndoIntervalsOverlap :: Bool\ndoIntervalsOverlap = overlaps interval1 interval2\n\n-- Test\nmain :: IO ()\nmain = print doIntervalsOverlap  -- True"
},
{
  "prompt": "Write a script to create a singleton interval and check if a specific value is within it. Use the `singleton` function to create an interval containing only one element (e.g., 1500), and use the `contains` function to verify if the given value (e.g., 1500) is within the interval. The script should return `True` if the value is in the singleton interval.",
  "response": "import Plutus.V1.Ledger.Interval\nimport Plutus.V1.Ledger.Time (POSIXTime)\n\n-- Create a singleton interval at 1500\nsingletonInterval :: Interval POSIXTime\nsingletonInterval = singleton 1500\n\n-- Check if 1500 is within the interval\ncheckSingleton :: Bool\ncheckSingleton = contains singletonInterval 1500  -- True\n\n-- Test\nmain :: IO ()\nmain = print checkSingleton"
},
{
  "prompt": "Write a script to check if one interval occurs entirely before another. Define two intervals using the `interval` function (e.g., `interval1` from 1000 to 2000 and `interval2` from 2500 to 3000), and use the `before` function to determine if the first interval is completely before the second. The script should return `True` if the condition is met.",
  "response": "import Plutus.V1.Ledger.Interval\nimport Plutus.V1.Ledger.Time (POSIXTime)\n\n-- Create two intervals\ninterval1 :: Interval POSIXTime\ninterval1 = interval 1000 2000\n\ninterval2 :: Interval POSIXTime\ninterval2 = interval 2500 3000\n\n-- Check if interval1 is completely before interval2\nisBefore :: Bool\nisBefore = before interval1 interval2  -- True\n\n-- Test\nmain :: IO ()\nmain = print isBefore"
},
{
  "prompt": "Write a script to define a simple validator that always succeeds or checks a basic condition, such as the equality of the datum and redeemer. Serialize the script for deployment using the appropriate tools and include example values for the datum and redeemer to demonstrate interaction with the validator. Ensure the script is clear, reusable, and structured effectively.",
  "response": "import Plutus.V1.Ledger.Scripts\nimport Plutus.V1.Ledger.Api\nimport PlutusTx\n\n-- Define a simple validator script\n{-# INLINABLE myValidator #-}\nmyValidator :: Integer -> () -> () -> ScriptContext -> Bool\nmyValidator requiredAmount _ _ ctx =\n    let\n        txInfo = scriptContextTxInfo ctx\n        totalInputValue = mconcat [txOutValue (txInInfoResolved i) | i <- txInfoInputs txInfo]\n    in\n        totalInputValue >= requiredAmount\n\n-- Create a validator script\nvalidatorScript :: Validator\nvalidatorScript = mkValidatorScript $$(PlutusTx.compile [|| myValidator ||])\n\n-- Serialize the script\nserializedScript :: SerializedScript\nserializedScript = serialiseScript validatorScript\n\n-- Example redeemer and datum\nexampleRedeemer :: Redeemer\nexampleRedeemer = Redeemer unitRedeemer\n\nexampleDatum :: Datum\nexampleDatum = Datum unitDatum"
},
{
  "prompt": "Write a simple token deposit/withdrawal contract using the Plutus.Contract monad. The contract should allow users to deposit and withdraw a token, checking if they have enough tokens for withdrawal and updating the balance when tokens are deposited or withdrawn.",
  "response": "# LANGUAGE DataKinds           #-\n{-# LANGUAGE DeriveAnyClass      #-}\n{-# LANGUAGE DeriveGeneric       #-}\n{-# LANGUAGE OverloadedStrings   #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TypeApplications    #-}\n{-# LANGUAGE TypeFamilies        #-}\n{-# LANGUAGE NoImplicitPrelude   #-}\n\nimport           Plutus.Contract\nimport           PlutusTx.Prelude          hiding (unless)\nimport qualified PlutusTx\nimport           Ledger\nimport           Ledger.Constraints         as Constraints\nimport           Ledger.Value               as Value\nimport           Ledger.Typed.Scripts       as Scripts\nimport           Prelude                    (IO, String)\nimport           Control.Monad              (void)\n\n-- | Define the contract state\ndata ContractState = ContractState\n    { deposited :: Integer\n    , withdrawn :: Integer\n    }\n\nPlutusTx.unstableMakeIsData ''ContractState\n\n-- | Define the contract's schema\ntype DepositSchema = Endpoint \"deposit\" Integer\ntype WithdrawSchema = Endpoint \"withdraw\" Integer\n\n-- | Define the contract logic\ndeposit :: Integer -> Contract w s Text ()\ndeposit amount = do\n    -- Log deposit action\n    logInfo @String $ \"Depositing \" ++ show amount\n    -- Implement deposit logic here (omitted for simplicity)\n    pure ()\n\nwithdraw :: Integer -> Contract w s Text ()\nwithdraw amount = do\n    -- Log withdrawal action\n    logInfo @String $ \"Withdrawing \" ++ show amount\n    -- Implement withdrawal logic here (omitted for simplicity)\n    pure ()\n\nendpoints :: Contract () DepositSchema Text ()\nendpoints = do\n    depositAmount <- endpoint @\"deposit\"\n    withdrawAmount <- endpoint @\"withdraw\"\n    deposit depositAmount\n    withdraw withdrawAmount"
},
{
  "prompt": "Write a script to define the contract's validation logic using Plutus validators. The script should check if the deposit or withdrawal actions meet the required conditions, such as verifying the user's balance and ensuring that the transaction can proceed based on the defined rules.",
  "response": "# LANGUAGE DataKinds           #-\n{-# LANGUAGE NoImplicitPrelude   #-}\n{-# LANGUAGE TemplateHaskell     #-}\n{-# LANGUAGE TypeApplications    #-}\n\nimport           PlutusTx.Prelude          hiding (unless)\nimport           Ledger\nimport           Ledger.Typed.Scripts       as Scripts\nimport           Ledger.Value               as Value\n\n-- | Define the validator\ndata DepositWithdraw\ninstance Scripts.ValidatorTypes DepositWithdraw where\n    type instance DatumType DepositWithdraw = ContractState\n    type instance RedeemerType DepositWithdraw = Integer\n\nvalidate :: ContractState -> Integer -> ScriptContext -> Bool\nvalidate (ContractState deposited withdrawn) amount _ =\n    -- Define validation logic (simplified)\n    amount >= 0 -- Just a simple check for demonstration\n\ntypedValidator :: Scripts.TypedValidator DepositWithdraw\ntypedValidator = Scripts.mkTypedValidator @DepositWithdraw\n    ($$(PlutusTx.compile [|| validate ||])\n        `PlutusTx.applyCode` PlutusTx.liftCode ())\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.mkValidator @DepositWithdraw\n\nvalidator :: Validator\nvalidator = Scripts.validatorScript typedValidator\n\nscrAddress :: Ledger.Address\nscrAddress = Scripts.validatorAddress typedValidator"
},
{
  "prompt": "Write a script to define the state machine data types for a simple voting contract in Plutus.",
  "response": "# LANGUAGE DataKinds #-\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nimport           PlutusTx.Prelude\nimport           PlutusTx\nimport           Ledger\nimport           Ledger.Constraints as Constraints\nimport           Ledger.Typed.Scripts\nimport           Plutus.Contract\nimport           Plutus.V1.Ledger.Api\nimport           Plutus.V1.Ledger.Scripts\nimport           Plutus.V1.Ledger.Tx\nimport           Prelude (Semigroup(..), Show(..), String)\n\ndata VotingState = Idle | Voting | Closed\n    deriving (Eq, Show)\n\ndata VotingAction = StartVoting | Vote | CloseVoting\n    deriving (Eq, Show)\n\nPlutusTx.unstableMakeIsData ''VotingState\nPlutusTx.unstableMakeIsData ''VotingAction\n\ndata Voting = Voting\n    { vsState :: VotingState\n    , vsVotes :: [(String, Integer)]  -- Candidate names and their vote counts\n    } deriving (Show)\n\nPlutusTx.unstableMakeIsData ''Voting"
}, 
{
  "prompt": "Write a script to define the transition logic for the voting contract's state machine. The script should specify how the contract moves between the Idle, Voting, and Closed states based on user actions, such as starting the vote, casting a vote, and closing the vote. Ensure proper validation for each state transition.",
  "response": "# LANGUAGE RankNTypes #-\n\ntransition :: VotingState -> VotingAction -> Voting -> Maybe Voting\ntransition Idle StartVoting voting =\n    Just $ voting { vsState = Voting }\ntransition Voting Vote voting =\n    Just $ voting { vsVotes = incrementVote (vsVotes voting) }\ntransition Voting CloseVoting voting =\n    Just $ voting { vsState = Closed }\ntransition _ _ _ = Nothing\n\nincrementVote :: [(String, Integer)] -> [(String, Integer)]\nincrementVote votes = -- Define how to increment votes"
},
{
  "prompt": "Write a script to define the state machine for the voting contract. The state machine should include the three states: Idle, Voting, and Closed, and handle the transitions between these states based on user actions. Implement the necessary logic for managing state transitions and validation for each step of the voting process.",
  "response": "data VotingSM\ninstance Scripts.ScriptType VotingSM where\n    type instance DatumType VotingSM = Voting\n    type instance RedeemerType VotingSM = VotingAction\n\ninstance Scripts.ValidatorTypes VotingSM where\n    type instance DatumType VotingSM = Voting\n    type instance RedeemerType VotingSM = VotingAction\n\n{-# INLINABLE mkValidator #-}\nmkValidator :: Voting -> VotingAction -> ScriptContext -> Bool\nmkValidator datum redeemer context =\n    case transition (vsState datum) redeemer datum of\n        Just newState -> True\n        Nothing       -> False\n\nvalidator :: Scripts.TypedValidator VotingSM\nvalidator = Scripts.mkTypedValidator @VotingSM\n    $$(PlutusTx.compile [|| mkValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.mkUntypedValidator @Voting @VotingAction"
},
{
  "prompt": "Write a script to define the voting contract using the state machine.",
  "response": "type VotingSchema =\n    Endpoint \"startVoting\" ()\n    .\/ Endpoint \"vote\" ()\n    .\/ Endpoint \"closeVoting\" ()\n\nstartVoting :: AsContractError e => Contract w s e ()\nstartVoting = do\n    -- Implementation for starting the voting\n    return ()\n\nvote :: AsContractError e => Contract w s e ()\nvote = do\n    -- Implementation for casting a vote\n    return ()\n\ncloseVoting :: AsContractError e => Contract w s e ()\ncloseVoting = do\n    -- Implementation for closing the voting\n    return ()\n\nendpoints :: AsContractError e => Contract () VotingSchema e ()\nendpoints = do\n    startVoting\n    vote\n    closeVoting"
},
{
  "prompt": "Write a script to access `TxInfo` in a Plutus smart contract. The script should retrieve and inspect details such as transaction inputs, outputs, the value being transferred, and any other relevant metadata from the transaction attempting to interact with the contract.",
  "response": "# LANGUAGE DataKinds #-\n# LANGUAGE NoImplicitPrelude #-\n# LANGUAGE TemplateHaskell #-\n# LANGUAGE ScopedTypeVariables #-\n\nmodule SimpleValidator where\n\nimport Plutus.V1.Ledger.Contexts (ScriptContext, TxInfo, scriptContextTxInfo)\nimport PlutusTx.Prelude\n\n-- A simple validator that checks if the transaction has been signed by a specific public key\nvalidateTransaction :: PubKeyHash -> () -> () -> ScriptContext -> Bool\nvalidateTransaction expectedPubKey _ _ ctx = \n    let\n        txInfo :: TxInfo\n        txInfo = scriptContextTxInfo ctx\n\n        signatories :: [PubKeyHash]\n        signatories = txInfoSignatories txInfo\n    in\n        expectedPubKey `elem` signatories"
},
{
  "prompt": "Write a Solidity smart contract that implements the ERC20 token standard. The contract should include functions for issuing and transferring tokens, as well as a simple ownership model to manage the owner of the contract.",
  "response": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PropertyToken is ERC20, Ownable {\n    address public propertyOwner;\n    uint256 public totalTokens;\n\n    event SharesIssued(address indexed to, uint256 amount);\n\n    constructor(string memory name, string memory symbol, uint256 _totalTokens) ERC20(name, symbol) {\n        propertyOwner = msg.sender;\n        totalTokens = _totalTokens;\n        _mint(propertyOwner, totalTokens);\n    }\n\n    function issueShares(address to, uint256 amount) public onlyOwner {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(propertyOwner) >= amount, \"Insufficient balance to issue shares\");\n        _transfer(propertyOwner, to, amount);\n        emit SharesIssued(to, amount);\n    }\n\n    function sellShares(address from, address to, uint256 amount) public onlyOwner {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance to sell shares\");\n        _transfer(from, to, amount);\n    }\n}"
},
{
  "prompt": "Write a script to define the currency symbol and token name, along with the schema for the contract. The script should include the contract definition and boilerplate code for a Plutus contract. Ensure it includes the necessary imports and structures for initializing the contract with the specified token details.",
  "response": "{-# LANGUAGE DataKinds           #-}\n{-# LANGUAGE NoImplicitPrelude   #-}\n{-# LANGUAGE OverloadedStrings   #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell     #-}\n{-# LANGUAGE TypeApplications    #-}\n{-# LANGUAGE TypeFamilies        #-}\n{-# LANGUAGE FlexibleContexts    #-}\n\nmodule PropertyToken where\n\nimport           PlutusTx\nimport           PlutusTx.Prelude\nimport           Ledger\nimport           Ledger.Value as Value\nimport           Ledger.Typed.Scripts as Scripts\nimport           Ledger.Constraints as Constraints\nimport           Playground.Contract\nimport           Plutus.Contract\n\n-- Define the currency symbol and token name\npropertyTokenSymbol :: CurrencySymbol\npropertyTokenSymbol = \"propertyToken\"\n\npropertyTokenName :: TokenName\npropertyTokenName = \"Property\"\n\n-- Define the schema for the contract\ndata PropertyTokenSchema =\n    MintToken Integer | TransferToken Integer PubKeyHash deriving (Show, Eq)\n\nPlutusTx.unstableMakeIsData ''PropertyTokenSchema\n\n-- Define the contract\nmkPropertyToken :: Integer -> Contract w s Text ()\nmkPropertyToken amount = do\n    let token = Value.singleton propertyTokenSymbol propertyTokenName amount\n    let lookups = Constraints.mintingPolicy (mintPolicy amount)\n    let tx = Constraints.mustMintValue token\n    ledgerTx <- submitTxConstraintsWith @Scripts.MintingPolicy lookups tx\n    awaitTxConfirmed $ getCardanoTxId ledgerTx\n    logInfo @String $ \"Minted \" ++ show amount ++ \" tokens\"\n\ntransferToken :: Integer -> PubKeyHash -> Contract w s Text ()\ntransferToken amount recipient = do\n    let token = Value.singleton propertyTokenSymbol propertyTokenName amount\n    let lookups = Constraints.ownPaymentPubKeyHash\n    let tx = Constraints.mustPayToPubKey recipient token\n    ledgerTx <- submitTxConstraintsWith @Scripts.MintingPolicy lookups tx\n    awaitTxConfirmed $ getCardanoTxId ledgerTx\n    logInfo @String $ \"Transferred \" ++ show amount ++ \" tokens to \" ++ show recipient\n\nmintPolicy :: Integer -> MintingPolicy\nmintPolicy amount = Scripts.wrapMintingPolicy $ \\_ _ _ -> if amount > 0 then () else error ()\n\n-- Boilerplate code for Plutus Contract\nendpoints :: Contract () PropertyTokenSchema Text ()\nendpoints = do\n    logInfo @String \"Property Token Contract started\"\n    awaitPromise\n        (mintToken `select` transferToken)\n    where\n        mintToken = endpoint @\"mint\" >>= mkPropertyToken\n        transferToken = endpoint @\"transfer\" >>= \\(amount, recipient) -> transferToken amount recipient\n\nmkSchemaDefinitions ''PropertyTokenSchema\n\nmkKnownCurrencies []"
},
]
