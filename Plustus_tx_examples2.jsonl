{"text": "What does the following Haskell Plutus smart contract code implement, and how does it work? [/INST]This Haskell Plutus smart contract implements an n-out-of-m multisig (multi-signature) scheme that allows multiple participants (m signatories) to propose and authorize payments, where at least n participants' signatures are required to release the funds. The contract manages state transitions through a state machine, tracking when a payment proposal is made, when signatures are added, and when payments are executed. The contract uses off-chain and on-chain code to achieve this."
    "detailed_explanation": {
      "language_extensions": [
        "{-# LANGUAGE DeriveGeneric #-}",
        "{-# LANGUAGE MultiParamTypeClasses #-}"
      ],
      "imports": [
        "Control.Lens (makeClassyPrisms)",
        "qualified Ledger.Interval as Interval",
        "GHC.Generics (Generic)",
        "Ledger.Validation (PendingTx, PendingTx'(..))",
        "qualified Ledger.Validation as Validation",
        "qualified Ledger.Typed.Scripts as Scripts",
        "Ledger.Value (Value)",
        "qualified Ledger.Value as Value",
        "Ledger (PubKey, Slot)",
        "Playground.Contract (printSchemas, ensureIotsDefinitions, ensureKnownCurrencies, KnownCurrency, mkSchemaDefinitions, ToSchema)",
        "qualified Language.PlutusTx as PlutusTx",
        "Language.Plutus.Contract",
        "Language.Plutus.Contract.StateMachine (ValueAllocation(..), AsSMContractError, StateMachine(..))",
        "qualified Language.Plutus.Contract.StateMachine as SM",
        "qualified Language.Plutus.Contract.Tx as Tx",
        "Language.PlutusTx.Prelude hiding (check, Applicative (..), (<>))",
        "qualified Prelude as Haskell"
      ],
      "concepts_implemented": [
        {
          "concept": "Payment Structure",
          "description": "Defines a `Payment` structure that holds the amount to be paid, the recipient's public key, and the deadline by which signatures must be collected."
        },
        {
          "concept": "State Transitions",
          "description": "The smart contract transitions between states (such as Holding and CollectingSignatures) depending on whether a payment has been proposed or signatures are being collected."
        },
        {
          "concept": "Multisig Scheme",
          "description": "The contract checks whether a minimum number of required signatures have been collected, and only allows the transaction to proceed if the required signatories agree."
        },
        {
          "concept": "State Machine Logic",
          "description": "The contract operates as a state machine where actions like proposing payments, adding signatures, canceling payments, and making payments all trigger state transitions."
        },
        {
          "concept": "Input and Output Validation",
          "description": "The contract ensures that the funds are preserved correctly and paid to the right addresses by verifying signatures and checking the validity of payment proposals."
        },
        {
          "concept": "Error Handling",
          "description": "Defines custom error types (`MultiSigError`) and uses lenses (`makeClassyPrisms`) for extensibility and error handling."
        }
      ],
      "data_types": [
        {
          "type": "Payment",
          "fields": {
            "paymentAmount": "Value",
            "paymentRecipient": "PubKey",
            "paymentDeadline": "Slot"
          },
          "description": "Represents a payment proposal including amount, recipient, and deadline."
        },
        {
          "type": "Params",
          "fields": {
            "mspSignatories": "[PubKey]",
            "mspRequiredSigs": "Integer"
          },
          "description": "Represents the parameters of the multisig contract, including the list of signatories and the required number of signatures."
        },
        {
          "type": "State",
          "variants": [
            "Holding Value",
            "CollectingSignatures Value Payment [PubKey]"
          ],
          "description": "The state of the contract, either holding funds or collecting signatures for a proposed payment."
        },
        {
          "type": "Input",
          "variants": [
            "ProposePayment Payment",
            "AddSignature PubKey",
            "Cancel",
            "Pay"
          ],
          "description": "Represents the inputs to the state machine, including proposing payments, adding signatures, canceling, and paying."
        }
      ],
      "core_functions": [
        {
          "function": "isSignatory",
          "description": "Checks if a given public key is one of the authorized signatories."
        },
        {
          "function": "isValidProposal",
          "description": "Validates whether a proposed payment can be made with the current locked funds."
        },
        {
          "function": "proposalExpired",
          "description": "Checks if the deadline for a proposed payment has passed."
        },
        {
          "function": "step",
          "description": "Defines the state transitions based on inputs like proposing a payment, adding a signature, or making the payment."
        },
        {
          "function": "check",
          "description": "Ensures that inputs and transactions are valid by checking conditions such as whether enough signatures are collected and whether the funds are preserved."
        }
      ],
      "smart_contract_flow": {
        "initial_state": "Holding funds",
        "transitions": [
          "ProposePayment: Transitions to CollectingSignatures with the proposed payment and an empty signature list.",
          "AddSignature: Adds the signer's public key to the list of collected signatures.",
          "Cancel: Cancels the current proposal if the deadline is passed, returning to the Holding state.",
          "Pay: Moves to the Holding state after transferring the value to the recipient."
        ]
      },
      "onchain_validation": {
        "mkValidator": "This function checks whether the transaction complies with the contract's logic (valid signatures, valid proposals, etc.)",
        "validatorCode": "Compiles the validation logic into Plutus Core, the low-level language of the Plutus platform."
      },
      "schema_definitions": [
        {
          "name": "MultiSigSchema",
          "endpoints": [
            "propose-payment",
            "add-signature",
            "cancel-payment",
            "pay",
            "lock"
          ],
          "description": "The schema defines the endpoints for proposing a payment, adding a signature, canceling, making a payment, and locking funds."
        }
      ],
      "full_code": "```haskell\n{-# LANGUAGE DeriveGeneric #-}{-# LANGUAGE MultiParamTypeClasses #-}import Control.Lens (makeClassyPrisms)import qualified Ledger.Interval as Intervalimport GHC.Generics (Generic)import Ledger.Validation (PendingTx, PendingTx'(..))import qualified Ledger.Validation as Validationimport qualified Ledger.Typed.Scripts as Scriptsimport Ledger.Value (Value)import qualified Ledger.Value as Valueimport Ledger (PubKey, Slot)import Playground.Contract (printSchemas, ensureIotsDefinitions, ensureKnownCurrencies, KnownCurrency, mkSchemaDefinitions, ToSchema)import qualified Language.PlutusTx as PlutusTximport Language.Plutus.Contractimport Language.Plutus.Contract.StateMachine (ValueAllocation(..), AsSMContractError, StateMachine(..))import qualified Language.Plutus.Contract.StateMachine as SMimport qualified Language.Plutus.Contract.Tx as Tximport Language.PlutusTx.Prelude hiding (check, Applicative (..), (<>))import qualified Prelude as Haskell --   $multisig --   The n-out-of-m multisig contract works like a joint account of --   m people, requiring the consent of n people for any payments. --   In the smart contract the signatories are represented by public keys, --   and approval takes the form of signatures on transactions. -- --   The multisig contract in --   'Language.PlutusTx.Coordination.Contracts.MultiSig' expects n signatures on --   a single transaction. This requires an off-chain communication channel. The --   multisig contract implemented in this module uses a proposal system that --   allows participants to propose payments and attach their signatures to --   proposals over a period of time, using separate transactions. All contract --   state is kept on the chain so there is no need for off-chain communication. -- | A proposal for making a payment under the multisig scheme. data Payment = Payment { paymentAmount :: Value , paymentRecipient :: PubKey , paymentDeadline :: Slot } deriving stock (Show, Generic) deriving anyclass (ToSchema)instance Eq Payment where {-# INLINABLE (==) #-}(Payment vl pk sl) == (Payment vl' pk' sl') = vl == vl' && pk == pk' && sl == sl' data Params = Params { mspSignatories :: [PubKey] , mspRequiredSigs :: Integer } -- | State of the multisig contract. data State = Holding Value | CollectingSignatures Value Payment [PubKey] deriving (Show)instance Eq State where {-# INLINABLE (==) #-}(Holding v) == (Holding v') = v == v'(CollectingSignatures vl pmt pks) == (CollectingSignatures vl' pmt' pks') = vl == vl' && pmt == pmt' && pks == pks' _ == _ = False data Input = ProposePayment Payment | AddSignature PubKey | Cancel | Pay deriving Show data MultiSigError = MSContractError ContractError | MSStateMachineError (SM.SMContractError State Input) deriving Show makeClassyPrisms ''MultiSigErrorinstance AsContractError MultiSigError where _ContractError = _MSContractErrorinstance AsSMContractError MultiSigError State Input where _SMContractError = _MSStateMachineError type MultiSigSchema = BlockchainActions .\/ Endpoint "propose-payment" Payment .\/ Endpoint "add-signature" () .\/ Endpoint "cancel-payment" () .\/ Endpoint "pay" () .\/ Endpoint "lock" Value{-# INLINABLE isSignatory #-}isSignatory :: PubKey -> Params -> BoolisSignatory pk (Params sigs _) = any (\pk' -> pk == pk') sigs{-# INLINABLE containsPk #-}containsPk :: PubKey -> [PubKey] -> BoolcontainsPk pk = any (\pk' -> pk' == pk){-# INLINABLE isValidProposal #-}isValidProposal :: Value -> Payment -> BoolisValidProposal vl (Payment amt _ _) = amt `Value.leq` vl{-# INLINABLE proposalExpired #-}proposalExpired :: PendingTx -> Payment -> BoolproposalExpired PendingTx{pendingTxValidRange} Payment{paymentDeadline} = paymentDeadline `Interval.before` pendingTxValidRange{-# INLINABLE proposalAccepted #-}proposalAccepted :: Params -> [PubKey] -> BoolproposalAccepted (Params signatories numReq) pks = let numSigned = length (filter (\pk -> containsPk pk pks) signatories) in numSigned >= numReq{-# INLINABLE valuePreserved #-}valuePreserved :: Value -> PendingTx -> BoolvaluePreserved vl ptx = vl == Validation.valueLockedBy ptx (Validation.ownHash ptx){-# INLINABLE valuePaid #-}valuePaid :: Payment -> PendingTx -> BoolvaluePaid (Payment vl pk _) ptx = vl == (Validation.valuePaidTo ptx pk){-# INLINABLE step #-}step :: State -> Input -> Maybe Statestep s i = case (s, i) of (Holding vl, ProposePayment pmt) -> Just $ CollectingSignatures vl pmt [] (CollectingSignatures vl pmt pks, AddSignature pk) -> Just $ CollectingSignatures vl pmt (pk:pks) (CollectingSignatures vl _ _, Cancel) -> Just $ Holding vl (CollectingSignatures vl (Payment vp _ _) _, Pay) -> let vl' = vl - vp in Just $ Holding vl' _ -> Nothing{-# INLINABLE check #-}check :: Params -> State -> Input -> PendingTx -> Boolcheck p s i ptx = case (s, i) of (Holding vl, ProposePayment pmt) -> isValidProposal vl pmt && valuePreserved vl ptx (CollectingSignatures vl _ pks, AddSignature pk) -> Validation.txSignedBy ptx pk && isSignatory pk p && not (containsPk pk pks) && valuePreserved vl ptx (CollectingSignatures vl pmt _, Cancel) -> proposalExpired ptx pmt && valuePreserved vl ptx (CollectingSignatures vl pmt@(Payment vp _ _) pks, Pay) -> let vl' = vl - vp in not (proposalExpired ptx pmt) && proposalAccepted p pks && valuePreserved vl' ptx && valuePaid pmt ptx _ -> False{-# INLINABLE final #-}final :: State -> Boolfinal (Holding v) = Value.isZero vfinal _ = False{-# INLINABLE mkValidator #-}mkValidator :: Params -> Scripts.ValidatorType MultiSigSymmkValidator p = SM.mkValidator $ StateMachine step (check p) final validatorCode :: Params -> PlutusTx.CompiledCode (Scripts.ValidatorType MultiSigSym)validatorCode params = $$(PlutusTx.compile [|| mkValidator ||]) `PlutusTx.applyCode` PlutusTx.liftCode params type MultiSigSym = StateMachine State Input scriptInstance :: Params -> Scripts.ScriptInstance MultiSigSymscriptInstance params = Scripts.validator @MultiSigSym (validatorCode params) $$(PlutusTx.compile [|| wrap ||]) where wrap = Scripts.wrapValidator @State @Input machineInstance :: Params -> SM.StateMachineInstance State InputmachineInstance params = SM.StateMachineInstance (StateMachine step (check params) final) (scriptInstance params) allocate :: State -> Input -> Value -> ValueAllocationallocate (CollectingSignatures _ (Payment vp pk _) _) Pay vl = let vl' = vl - vp in ValueAllocation{vaOwnAddress=vl', vaOtherPayments=Tx.payToPubKey vp pk}allocate _ _ vl = ValueAllocation{vaOwnAddress = vl, vaOtherPayments = Haskell.mempty} client :: Params -> SM.StateMachineClient State Inputclient p = SM.mkStateMachineClient (machineInstance p) allocate contract :: ( AsContractError e , AsSMContractError e State Input ) => Params -> Contract MultiSigSchema e ()contract params = go where theClient = client params go = endpoints >> go endpoints = lock <|> propose <|> cancel <|> addSignature <|> pay propose = endpoint @"propose-payment" >>= SM.runStep theClient . ProposePayment cancel = endpoint @"cancel-payment" >> SM.runStep theClient Cancel addSignature = endpoint @"add-signature" >> ownPubKey >>= SM.runStep theClient . AddSignature lock = do value <- endpoint @"lock" SM.runInitialise theClient (Holding value) value pay = endpoint @"pay" >> SM.runStep theClient Pay PlutusTx.makeIsData ''Payment PlutusTx.makeLift ''Payment PlutusTx.makeIsData ''State PlutusTx.makeLift ''State PlutusTx.makeLift ''Params PlutusTx.makeIsData ''Input PlutusTx.makeLift ''Input mkSchemaDefinitions ''MultiSigSchema
  }
  }
{"text": "<s>[INST] What is the purpose of the `collect-gift.sh` script, and how does it handle the process of submitting a Cardano transaction on a testnet? [/INST] The `collect-gift.sh` script is designed to automate the process of submitting a Cardano transaction on a testnet. It handles querying protocol parameters, building a transaction, signing it, and submitting it to the network. After submission, it retrieves and prints the transaction ID and provides a link to view the transaction on CardanoScan. The script first queries the protocol parameters and saves them to `protocol-parameters.json`. It then builds the transaction by specifying the input, script file, datum, redeemer, collateral, change address, and protocol parameters, saving the transaction body to `collect-gift.txbody`. Next, it signs the transaction using the signing key and saves it to `collect-gift.tx`. Finally, it submits the transaction to the testnet and prints the transaction ID along with a CardanoScan link for viewing the transaction status. #!/bin/bash assets=/workspaces/plutus-pioneer-program/code/Week02/assets keypath=/workspaces/plutus-pioneer-program/keys name=\"$1\" collateral=\"$2\" txin=\"$3\" pp=\"$assets/protocol-parameters.json\" body=\"$assets/collect-gift.txbody\" tx=\"$assets/collect-gift.tx\" # Query the protocol parameters \\ cardano-cli query protocol-parameters \\ --testnet-magic 2 \\ --out-file \"$pp\" # Build the transaction cardano-cli transaction build \\ --babbage-era \\ --testnet-magic 2 \\ --tx-in \"$txin\" \\ --tx-in-script-file \"$assets/gift.plutus\" \\ --tx-in-inline-datum-present \\ --tx-in-redeemer-file \"$assets/unit.json\" \\ --tx-in-collateral \"$collateral\" \\ --change-address \"$(cat \"$keypath/$name.addr\")\" \\ --protocol-params-file \"$pp\" \\ --out-file \"$body\" # Sign the transaction cardano-cli transaction sign \\ --tx-body-file \"$body\" \\ --signing-key-file \"$keypath/$name.skey\" \\ --testnet-magic 2 \\ --out-file \"$tx\" # Submit the transaction cardano-cli transaction submit \\ --testnet-magic 2 \\ --tx-file \"$tx\" tid=$(cardano-cli transaction txid --tx-file \"$tx\") echo \"transaction id: $tid\" echo \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\" </s>"}
{"text": "<s>[INST] What does the `make-gift.sh` script do and how does it manage Cardano transactions on a testnet? [/INST] The `make-gift.sh` script is used to automate the process of building, signing, and submitting a Cardano transaction on a testnet. It starts by building a gift address from a payment script file and saving it to `gift.addr`. Then, it constructs a transaction by specifying inputs, outputs, inline datum, and change address, saving the transaction body to `gift.txbody`. The script signs the transaction with the provided signing key and saves the signed transaction to `gift.tx`. Finally, it submits the transaction to the testnet and prints the transaction ID along with a CardanoScan link to view the transaction status. #!/bin/bash assets=/workspaces/plutus-pioneer-program/code/Week02/assets keypath=/workspaces/plutus-pioneer-program/keys name=\"$1\" txin=\"$2\" body=\"$assets/gift.txbody\" tx=\"$assets/gift.tx\" # Build gift address cardano-cli address build \\ --payment-script-file \"$assets/gift.plutus\" \\ --testnet-magic 2 \\ --out-file \"$assets/gift.addr\" # Build the transaction cardano-cli transaction build \\ --babbage-era \\ --testnet-magic 2 \\ --tx-in \"$txin\" \\ --tx-out \"$(cat \"$assets/gift.addr\") + 3000000 lovelace\" \\ --tx-out-inline-datum-file \"$assets/unit.json\" \\ --change-address \"$(cat \"$keypath/$name.addr\")\" \\ --out-file \"$body\" # Sign the transaction cardano-cli transaction sign \\ --tx-body-file \"$body\" \\ --signing-key-file \"$keypath/$name.skey\" \\ --testnet-magic 2 \\ --out-file \"$tx\" # Submit the transaction cardano-cli transaction submit \\ --testnet-magic 2 \\ --tx-file \"$tx\" tid=$(cardano-cli transaction txid --tx-file \"$tx\") echo \"transaction id: $tid\" echo \"Cardanoscan: https://preview.cardanoscan.io/transaction/$tid\" </s>"}
{"text": "<s>[INST] What functionality does the `Homework.hs` module provide in the context of Plutus smart contracts? [/INST] The `Homework.hs` module includes Haskell code for testing two Plutus smart contracts (`Homework1` and `Homework2`) using the `Tasty` testing framework. It defines scripts and validators for each homework assignment, sets up users with initial balances, and tests various cases of transactions involving gift transfers. The module performs the following: it builds and submits transactions, checks balances, and verifies that transactions have the desired effects on user balances. It uses different redeemer values to test the behavior of the contracts and reports errors if final balances are not as expected. The code is organized into functions for setting up transactions (`giveTx`, `takeTx`, `giveTx'`, `takeTx'`) and validating results against expected outcomes. {-# LANGUAGE NumericUnderscores #-} module Main where import Control.Monad (replicateM, unless) import Plutus.Model import Plutus.V2.Ledger.Api import Prelude import Test.Tasty import qualified Homework1 as H1 import qualified Homework2 as H2 type Homework1Script = TypedValidator () (Bool, Bool) script1 :: Homework1Script script1 = TypedValidator $ toV2 H1.validator type Homework2Script = TypedValidator () H2.MyRedeemer script2 :: Homework2Script script2 = TypedValidator $ toV2 H2.validator setupUsers :: Run [PubKeyHash] setupUsers = replicateM 3 $ newUser $ ada (Lovelace 1000) main :: IO () main = do defaultMain $ do testGroup \"Homework tests\" [ homework1 defaultBabbage , homework2 defaultBabbage ] homework1 :: MockConfig -> TestTree homework1 cfg = do testGroup \"Testing Homework1\" [ good \"Case: (True, True)\" $ giveGift (True, True) , bad \"Case: (True, False)\" $ giveGift (True, False) , bad \"Case: (False, True)\" $ giveGift (False, True) , bad \"Case: (False, False)\" $ giveGift (False, False) ] where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000) cfg giveGift :: (Bool, Bool) -> Run () giveGift redeemer = do users <- setupUsers let [u1, u2, _u3] = users val = adaValue 100 checkBalance (gives u1 val script1) $ do sp <- spend u1 val submitTx u1 $ giveTx sp val utxos <- utxoAt script1 let [(giftRef, giftOut)] = utxos checkBalance (gives script1 (txOutValue giftOut) u2) $ do submitTx u2 $ takeTx u2 redeemer giftRef (txOutValue giftOut) vals <- mapM valueAt users let [v1, v2, _] = vals unless (v1 == adaValue 900 && v2 == adaValue 1100) $ logError \"Final balances are incorrect\" giveTx :: UserSpend -> Value -> Tx giveTx usp val = mconcat [ userSpend usp , payToScript script1 (HashDatum ()) val ] takeTx :: PubKeyHash -> (Bool, Bool) -> TxOutRef -> Value -> Tx takeTx pkh redeemer giftRef giftVal = mconcat [ spendScript script1 giftRef redeemer () , payToKey pkh giftVal ] homework2 :: MockConfig -> TestTree homework2 cfg = do testGroup \"Testing Homework2\" [ bad \"Case: MyRedeemer True True\" $ giveGift' (H2.MyRedeemer True True) , good \"Case: MyRedeemer True False\" $ giveGift' (H2.MyRedeemer True False) , good \"Case: MyRedeemer False True\" $ giveGift' (H2.MyRedeemer False True) , bad \"Case: MyRedeemer False False\" $ giveGift' (H2.MyRedeemer False False) ] where bad msg = good msg . mustFail good = testNoErrors (adaValue 10_000_000) cfg giveGift' :: H2.MyRedeemer -> Run () giveGift' redeemer = do users <- setupUsers let [u1, u2, _u3] = users val = adaValue 100 checkBalance (gives u1 val script2) $ do sp <- spend u1 val submitTx u1 $ giveTx' sp val utxos <- utxoAt script2 let [(giftRef, giftOut)] = utxos checkBalance (gives script2 (txOutValue giftOut) u2) $ do submitTx u2 $ takeTx' u2 redeemer giftRef (txOutValue giftOut) vals <- mapM valueAt users let [v1, v2, _] = vals unless (v1 == adaValue 900 && v2 == adaValue 1100) $ logError \"Final balances are incorrect\" giveTx' :: UserSpend -> Value -> Tx giveTx' usp val = mconcat [ userSpend usp , payToScript script2 (HashDatum ()) val ] takeTx' :: PubKeyHash -> H2.MyRedeemer -> TxOutRef -> Value -> Tx takeTx' pkh redeemer giftRef giftVal = mconcat [ spendScript script2 giftRef redeemer () , payToKey pkh giftVal ] </s>"}
{"text": "<s>[INST] What is a smart contract that defines a validator which checks if two Booleans in the redeemer are true. If both are true, the smart contract validates successfully and is marked as valid by the ledger? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} {-# LANGUAGE OverloadedStrings   #-} module Homework1 where import qualified Plutus.V2.Ledger.Api as PlutusV2 import           PlutusTx             (compile) import           PlutusTx.Prelude     (Bool (..), BuiltinData, traceIfFalse, ($), (&&)) import           Utilities            (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkValidator #-} -- This should validate if and only if the two Booleans in the redeemer are True! mkValidator :: () -> (Bool, Bool) -> PlutusV2.ScriptContext -> Bool mkValidator _ (a, b) _ = traceIfFalse \"One or more bools are not true\" $ a && b wrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedVal = wrapValidator mkValidator validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||]) </s>"}
{"text": "<s>[INST] What is the basic structure of a Plutus smart contract that checks if two Boolean flags are different and validates the contract if they are? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE DeriveAnyClass      #-} {-# LANGUAGE DeriveGeneric       #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} {-# LANGUAGE OverloadedStrings   #-} module Homework2 where import qualified Plutus.V2.Ledger.Api as PlutusV2 import           PlutusTx             (unstableMakeIsData,compile) import           PlutusTx.Prelude     (Bool, BuiltinData, traceIfFalse, ($), (/=)) import           Utilities            (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MyRedeemer = MyRedeemer { flag1 :: Bool , flag2 :: Bool } PlutusTx.unstableMakeIsData ''MyRedeemer {-# INLINABLE mkValidator #-} -- Create a validator that unlocks the funds if MyRedemeer's flags are different mkValidator :: () -> MyRedeemer -> PlutusV2.ScriptContext -> Bool mkValidator _ myRed _ = traceIfFalse \"flags are not different\" $ flag1 myRed /= flag2 myRed wrappedVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedVal = wrapValidator mkValidator validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedVal ||]) </s>"}
{"text": "<s>[INST] What does the Plutus smart contract in the Burn module do, and how does it use traceError and writeValidatorToFile to create a validator that always fails and saves the validator to a file? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module Burn where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import PlutusTx.Prelude (traceError) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator always fails --                    Datum         Redeemer     ScriptContext mkBurnValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkBurnValidator _ _ _ = traceError \"it burns!!!\" {-# INLINABLE mkBurnValidator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkBurnValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/burn.plutus\" validator"}
{"text": "<s>[INST] How can I use Template Haskell and unstableMakeIsData to create a custom data type for my redeemer and a validator that succeeds only when the redeemer is a specific value? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module CustomTypes where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile, unstableMakeIsData) import PlutusTx.Prelude (Bool, Eq ((==)), Integer, traceIfFalse, ($)) import Prelude (IO) import Utilities (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- We can create custom data types for our datum and redeemer like this: newtype MySillyRedeemer = MkMySillyRedeemer Integer PlutusTx.unstableMakeIsData ''MySillyRedeemer -- Use TH to create an instance for IsData. -- This validator succeeds only if the redeemer is `MkMySillyRedeemer 42` --              Datum     Redeemer            ScriptContext mkCTValidator :: () -> MySillyRedeemer -> PlutusV2.ScriptContext -> Bool mkCTValidator _ (MkMySillyRedeemer r) _ = traceIfFalse \"expected 42\" $ r == 42 {-# INLINABLE mkCTValidator #-} wrappedMkVal :: BuiltinData -> BuiltinData -> BuiltinData -> () wrappedMkVal = wrapValidator mkCTValidator {-# INLINABLE wrappedMkVal #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrappedMkVal ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/customtypes.plutus\" validator"}
{"text": "<s>[INST] How can I make a Plutus validator that checks if the redeemer is exactly 42 and succeeds if it is? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module FortyTwo where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import PlutusTx.Builtins as Builtins (mkI) import PlutusTx.Prelude (otherwise, traceError, (==)) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator succeeds only if the redeemer is 42 --                  Datum         Redeemer     ScriptContext mk42Validator :: BuiltinData -> BuiltinData -> BuiltinData -> () mk42Validator _ r _ | r == Builtins.mkI 42 = () | otherwise            = traceError \"expected 42\" {-# INLINABLE mk42Validator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mk42Validator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/fortytwo.plutus\" validator"}
{"text": "<s>[INST] What does the validator do in the FortyTwo module, and how does it use PlutusTx.Builtins.mkI to check if the redeemer is exactly 42? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE OverloadedStrings   #-} {-# LANGUAGE TemplateHaskell     #-} module FortyTwoTyped where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (compile) import PlutusTx.Prelude (Bool, Eq ((==)), Integer, traceIfFalse, ($)) import Prelude (IO) import Utilities (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ -- This validator succeeds only if the redeemer is 42 --              Datum  Redeemer        ScriptContext mk42Validator :: () -> Integer -> PlutusV2.ScriptContext -> Bool mk42Validator _ r _ = traceIfFalse \"expected 42\" $ r == 42 {-# INLINABLE mk42Validator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| wrapValidator mk42Validator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/fortytwotyped.plutus\" validator"}
{"text": "<s>[INST] How does the Gift module's validator always succeed, and how can it be written to a file with writeValidatorToFile? [/INST] {-# LANGUAGE DataKinds           #-} {-# LANGUAGE ImportQualifiedPost #-} {-# LANGUAGE NoImplicitPrelude   #-} {-# LANGUAGE TemplateHaskell     #-} module Gift where import qualified Plutus.V2.Ledger.Api as PlutusV2 import PlutusTx (BuiltinData, compile) import Prelude (IO) import Utilities (writeValidatorToFile) --------------------------------------------------------------------------------------------------- -------------------------------- ON-CHAIN CODE / VALIDATOR ---------------------------------------- -- This validator always succeeds --                    Datum         Redeemer     ScriptContext mkGiftValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkGiftValidator _ _ _ = () {-# INLINABLE mkGiftValidator #-} validator :: PlutusV2.Validator validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile [|| mkGiftValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/gift.plutus\" validator"}
{"text": "<s>[INST] How does a validator determine if either beneficiary has signed the transaction at the correct time (before or after a deadline) using time checks on signatures and transaction details? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} {-# LANGUAGE TypeApplications  #-} {-# LANGUAGE TypeFamilies      #-} module Homework1 where import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts (txSignedBy) import Plutus.V1.Ledger.Interval import PlutusTx (compile, unstableMakeIsData) import PlutusTx.Prelude (traceIfFalse, Bool(..), (||), (&&), (+)) import Utilities (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingDatum = VestingDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime } unstableMakeIsData ''VestingDatum {-# INLINABLE mkVestingValidator #-} -- This should validate if either beneficiary1 has signed the transaction and the current slot is before or at the deadline -- or if beneficiary2 has signed the transaction and the deadline has passed. mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool mkVestingValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE  mkWrappedVestingValidator #-} mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedVestingValidator = wrapValidator mkVestingValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||])"}
{"text": "<s>[INST] How does a validator check if a transaction has a signature from a specified beneficiary and if a deadline has passed, using checks on signatures and transaction details? [/INST] {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module Homework2 where import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts import Plutus.V1.Ledger.Interval import PlutusTx (applyCode, compile, liftCode) import PlutusTx.Prelude (Bool(..), (.), traceIfFalse, (&&)) import Utilities (wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkParameterizedVestingValidator #-} -- This should validate if the transaction has a signature from the parameterized beneficiary and the deadline has passed. mkParameterizedVestingValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkParameterizedVestingValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkSig :: Bool checkSig = txSignedBy txInfo beneficiary checkDeadline :: Bool checkDeadline = contains (from deadline) txValidRange {-# INLINABLE  mkWrappedParameterizedVestingValidator #-} mkWrappedParameterizedVestingValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator validator :: PubKeyHash -> Validator validator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode beneficiary)"}
{"text": "<s>[INST] How does a validator determine if a transaction has been signed by a specific beneficiary and if the deadline for that beneficiary has passed, using checks on the transaction and its parameters? [/INST] {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module ParameterizedVesting where import           Plutus.V1.Ledger.Interval (contains) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (applyCode, compile, liftCode, makeLift) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (.) ) import           Prelude                   (IO) import           Utilities                 (writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingParams = VestingParams { beneficiary :: PubKeyHash , deadline    :: POSIXTime } makeLift ''VestingParams {-# INLINABLE mkParameterizedVestingValidator #-} mkParameterizedVestingValidator :: VestingParams -> () -> () -> ScriptContext -> Bool mkParameterizedVestingValidator params () () ctx = traceIfFalse \"beneficiary's signature missing\" signedByBeneficiary && traceIfFalse \"deadline not reached\" deadlineReached where info :: TxInfo info = scriptContextTxInfo ctx signedByBeneficiary :: Bool signedByBeneficiary = txSignedBy info $ beneficiary params deadlineReached :: Bool deadlineReached = contains (from $ deadline params) $ txInfoValidRange info {-# INLINABLE  mkWrappedParameterizedVestingValidator #-} mkWrappedParameterizedVestingValidator :: VestingParams -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedVestingValidator = wrapValidator . mkParameterizedVestingValidator validator :: VestingParams -> Validator validator params = mkValidatorScript ($$(compile [|| mkWrappedParameterizedVestingValidator ||]) `applyCode` liftCode params) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: VestingParams -> IO () saveVal = writeValidatorToFile \"./assets/parameterized-vesting.plutus\" . validator"}
{"text": "<s>[INST] How does the Vesting Validator check if a transaction has been signed by a specific beneficiary and if the deadline for that beneficiary has passed, using checks on signatures and transaction details, and how can the validator be written to a file or be displayed in JSON format using the writeValidatorToFile and printDataToJSON functions? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} module Vesting where import           Data.Maybe                (fromJust) import           Plutus.V1.Ledger.Interval (contains) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (compile, unstableMakeIsData) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&)) import           Prelude                   (IO, String) import           Utilities                 (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingDatum = VestingDatum { beneficiary :: PubKeyHash , deadline    :: POSIXTime } unstableMakeIsData ''VestingDatum {-# INLINABLE mkVestingValidator #-} mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool mkVestingValidator dat () ctx = traceIfFalse \"beneficiary's signature missing\" signedByBeneficiary && traceIfFalse \"deadline not reached\" deadlineReached where info :: TxInfo info = scriptContextTxInfo ctx signedByBeneficiary :: Bool signedByBeneficiary = txSignedBy info $ beneficiary dat deadlineReached :: Bool deadlineReached = contains (from $ deadline dat) $ txInfoValidRange info {-# INLINABLE  mkWrappedVestingValidator #-} mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedVestingValidator = wrapValidator mkVestingValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/vesting.plutus\" validator vestingAddressBech32 :: Network -> String vestingAddressBech32 network = validatorAddressBech32 network validator printVestingDatumJSON :: PubKeyHash -> String -> IO () printVestingDatumJSON pkh time = printDataToJSON $ VestingDatum { beneficiary = pkh , deadline    = fromJust $ posixTimeFromIso8601 time }"}
{"text": "<s>[INST] How does the Mistery Validator ensure that two signatures are received from different beneficiaries, one of which can be late while the other must be timely, and how can the validator be saved to a file or display the data in JSON format? [/INST] {-# LANGUAGE DataKinds         #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell   #-} {-# LANGUAGE TypeApplications  #-} {-# LANGUAGE TypeFamilies      #-} module Homework1 where import           Data.Maybe                (fromJust) import           Plutus.V1.Ledger.Interval (contains, to) import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, POSIXTimeRange, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (compile, unstableMakeIsData) import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), (+), (||)) import           Prelude                   (IO, String) import           Utilities                 (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MisteryDatum = MisteryDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline     :: POSIXTime } unstableMakeIsData ''MisteryDatum {-# INLINABLE mkMisteryValidator #-} mkMisteryValidator :: MisteryDatum -> () -> ScriptContext -> Bool mkMisteryValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE  mkWrappedMisteryValidator #-} mkWrappedMisteryValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedMisteryValidator = wrapValidator mkMisteryValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedMisteryValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/mistery1.plutus\" validator misteryAddressBech32 :: Network -> String misteryAddressBech32 network = validatorAddressBech32 network validator printMisteryDatumJSON :: PubKeyHash -> PubKeyHash -> String -> IO () printMisteryDatumJSON pkh1 pkh2 time = printDataToJSON $ MisteryDatum { beneficiary1 = pkh1 , beneficiary2 = pkh2 , deadline    = fromJust $ posixTimeFromIso8601 time }"}
{"text": "<s>[INST] How does the Parameterized Mistery Validator ensure that a transaction has been signed by a specified beneficiary and that the deadline for that beneficiary has passed, using checks on the transaction and its parameters, and how can the validator be written to a file with different beneficiaries? [/INST] {-# LANGUAGE DataKinds             #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude     #-} {-# LANGUAGE OverloadedStrings     #-} {-# LANGUAGE ScopedTypeVariables   #-} {-# LANGUAGE TemplateHaskell       #-} module Homework2 where import           Plutus.V1.Ledger.Interval (contains) import           Plutus.V2.Ledger.Api import           Plutus.V2.Ledger.Contexts (txSignedBy) import           PlutusTx                  (applyCode, compile, liftCode) import           PlutusTx.Prelude          (Bool (..), traceIfFalse, (&&), (.) ) import           Prelude                   (IO) import           Utilities                 (wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkParameterizedMisteryValidator #-} mkParameterizedMisteryValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkParameterizedMisteryValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange  = txInfoValidRange txInfo checkSig :: Bool checkSig = txSignedBy txInfo beneficiary checkDeadline :: Bool checkDeadline = contains (from deadline) txValidRange {-# INLINABLE  mkWrappedParameterizedMisteryValidator #-} mkWrappedParameterizedMisteryValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedMisteryValidator = wrapValidator . mkParameterizedMisteryValidator validator :: PubKeyHash -> Validator validator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedMisteryValidator ||]) `applyCode` liftCode beneficiary) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: PubKeyHash -> IO () saveVal = writeValidatorToFile \"./assets/parameterized-Mistery.plutus\" . validator"}
{"text": "<s>[INST] Can you explain the process by which the vesting contract is set up, including how the datum is created and used, and how funds can be vested and claimed? [/INST] import { Data, Lucid, Blockfrost, getAddressDetails, SpendingValidator, TxHash, Datum, UTxO, Address, AddressDetails, } from \"https://deno.land/x/lucid@0.9.1/mod.ts\"; import { secretSeed } from \"./seed.ts\"; const lucid = await Lucid.new(new Blockfrost(\"https://cardano-preprod.blockfrost.io/api/v0\", \"insert you own api key here\"), \"Preprod\"); lucid.selectWalletFromSeed(secretSeed); const addr: Address = await lucid.wallet.address(); console.log(addr); const vestingScript: SpendingValidator = { type: \"PlutusV2\", script: \"590b30590b2d0100003232323322323233223232323232323233223233223232323232323232333222323232322323222323253353232323253355335323235002222222222222533533355301a12001321233001225335002210031001002502c25335333573466e3c0380040ec0e84d40b8004540b4010840ec40e4d401488009400440b04cd5ce2491f62656e65666963696172792773207369676e6174757265206d697373696e670002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b00300735500322222222222200533501433501635029350052200102d335015502802d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce248114646561646c696e65206e6f7420726561636865640002b102b135001220023333573466e1cd55cea80224000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a008603e6ae84d5d1280211931901519ab9c02d02c0283333573466e1cd55ce9baa0054800080ac8c98c80a4cd5ce0160158139999ab9a3370e6aae7540192000233221233001003002375c6ae854018dd69aba135744a00c464c6405066ae700ac0a809840a44c98c809ccd5ce2490350543500029135573ca00226ea80044d55cf280089baa00132001355023221122253350011350032200122133350052200230040023335530071200100500400112223500222350032253335333500800700400215335003100110261025102612223232323253335006215333500621533350082130044984c00d261533350072130044984c00d26100d100b1533350072130044984c00d261533350062130044984c00d26100c1533350052100a100b100915333500521533350072130054984c011261533350062130054984c01126100c100a1533350062130054984c011261533350052130054984c01126100b2533350052153335007215333500721333500b00a002001161616100b153335006215333500621333500a009002001161616100a10092533350042153335006215333500621333500a009002001161616100a1533350052153335005213335009008002001161616100910082533350032153335005215333500521333500900800200116161610091533350042153335004213335008007002001161616100810072533350022153335004215333500421333500800700200116161610081533350032153335003213335007006002001161616100710061235001222222220071222003122200212220011221233001003002122123300100300212212330010030021232230023758002640026aa034446666aae7c004940288cd4024c010d5d080118019aba200201a232323333573466e1cd55cea80124000466442466002006004601c6ae854008c014d5d09aba2500223263201833573803603402c26aae7940044dd50009191919191999ab9a3370e6aae75401120002333322221233330010050040030023232323333573466e1cd55cea80124000466442466002006004602e6ae854008cd403c058d5d09aba2500223263201d33573804003e03626aae7940044dd50009aba150043335500875ca00e6ae85400cc8c8c8cccd5cd19b875001480108c84888c008010d5d09aab9e500323333573466e1d4009200223212223001004375c6ae84d55cf280211999ab9a3370ea00690001091100191931900f99ab9c02202101d01c01b135573aa00226ea8004d5d0a80119a805bae357426ae8940088c98c8064cd5ce00e00d80b89aba25001135744a00226aae7940044dd5000899aa800bae75a224464460046eac004c8004d5405c88c8cccd55cf80112804119a8039991091980080180118031aab9d5002300535573ca00460086ae8800c0604d5d080088910010910911980080200189119191999ab9a3370ea002900011a80398029aba135573ca00646666ae68cdc3a801240044a00e464c6402866ae7005c0580480444d55cea80089baa0011212230020031122001232323333573466e1d400520062321222230040053007357426aae79400c8cccd5cd19b875007480008c848888888c014020c038d5d09aab9e500c23263201533573803002e02602402202001e01c01a26aae7540104d55cf280189aab9e5002135573ca00226ea80048c8c8c8c8cccd5cd19b875001480088ccc888488ccc00401401000cdd69aba15004375a6ae85400cdd69aba135744a00c466666ae68cdc39aab9e50022756303008000002c8e1aabaa00315e4534245600000b5235e5342516e6400010053003436366e7575e53d4961520e1c008013758003007ccdeeb4906200e8355c023071800f5e5d4b9ea305a51b00c011023020047c843066c071904003b3ea00223e4d540880030bb4800c02311222300331126001b0030110040027dbe535ff09c00000260520000000000001e636c6d00396e6b3e4b1e48000694e0008ff8880a8a1a7d5355da003b3e004e38217a8023ea00352535533300a1736000427300022dd0b19c1200390ea0022e79e3a112c00253f33405353746e1802003320008c44c3a7b01003333573466e200060090a1ae23e4003c3522230001e004520035e03cbb3a2111e753b8aa91c220089aa1b8a14d0601ae0076110500836800a1c2213e02333560014e81c19e00352f3b03535567340b1e000002d5b00584c22b1e23a01d0006f572235a211d23e4d5401a00ae330111f6820005b8451220032224e5601c6f6c000e4c22c03f23770d1c720093330023036b0406f3e5a04c6c5f350f24446c045b043d2114d5d0a80199a805b330011c355744aa1e2285e94a1e2430320059a81a5e0048053e000002a00229a8aa621cfa00321f706046e8a00004caa810a005d9a0b4f23ea001e24303200580d780a0022a79e00484b2a980c01c006c7e0019e7506d0335a9e00004b6d9a0022a845ff0007b8033457547c90005c9000b4a00357a0063322a87d5e0a80d201005e7e00005b8209a2609d0132543d990022d20e7d8c200325500d070dd1a0033d03c035204c50002a8e0800000097e00b00000323337353743660000b0374347001e000000092a470033252a7d5b82e037393348a123100011a8002298a9a8a5a8a00c6d1a01491e0002d2034009a17b0d3224e54dba4c3b8a004d40000113f055e009e026d9e43506a45302012331e2c28a2d4d4a4b038024d03a038b023120e02804d80208293e42226c7e02881b6228a2e91c28d902a002d50002c2f0e000035a02a212e001a028e40000185f40a0a0d22e67000900922a92a0388d2d035d0a2d08e501d440ea019fa0413d013e68a05d06ea050e0205c103022b680f20a03840022a1a0212e1900918d08a38a0080b5e1e0035457e63d0022222e60e00b2b092b9302c0d2901043080031c190088d003b5d7d023111001001900008e0c0180241f00713b009236a11c80012d43025d501b41c8002d05880b01279e4d4003c4d7d8d0230335560d6e00324400c01d758000252e002e04e20026200e1d9e8e007f3e002260f03f302df9e004d752e1c27f032034c68a235006f930006000050023422e1e0099088a14e6a1e7a9d0282006b004c2b08e0c076003310c62a0c0930b022b6d03e5a1008f45e5a9e83cda020e0b9a07441e042275f14d500e085ec0b6ea0040131000000200039a1c13b82390360021c059c02606400f004a0030b75c05c87a1c02702805d024e0019e9c030740000b50d4007a0e88aa081d005400054e006302d6800b3d5d0a8e3000245d7e0028b0267082e070c08441c8d0132097a029013540097a81e5403d0086a235013e7a09b33d00562d0801a18004700448e1005c18002685a6aab8a90802c60c09300e4c4c8e0a2004c007009c750010b5d035e90d4b81a013403b11a0018a014d9d7008f05b6d2000073e00480002838e1f079dd3002c3e8002b5002340445b83a3003700172a8c00d01a9b0504b7c8c7d0056002c8c9000280454b2e3e0e0d7f0313e00020402004000253b00004d9e0b903b02400a601008402d20b0057d0b902052b20009a8a03753a0095010c0089d50309b4255e4300125f000081c9f36b7d8200138520a82a00d1701f2433002820040067503f2a6d9e0000a7e5030469d540a0824b34e810007d4533e7d34000880333d3000c12009d0c3d4a1e6000c16c40e20007e03f4240284d0e402800200013f000804c8e81e0b21005b03e4d7f0230202069c06002b1b283aa02c83d087d0b0268c12009d00300882007dce000090ee2200209c70020d505201053bb0d0105d4605002a0203e502025e032200b8c8c05c03004d8040080094a0802c007e7e0a006044d9004b010a05500903d7002a023004d60e1e600c004007042750b050000f005035700ca0c6002dba030087102b2e05618a08608c02520020c2eab05d20735b2c1045004d50064b80010d5d06c2003d004a002d904005b003d8c0008b5d0a8e90009462e03f05d423b300054b8e062208022920000a8c0002e0090017e220e03393a60003b8c806b95d780e0b27d2055002b00b0a1d802a8c0244a20003001d006ff0a002b8000a50014b004810b022005c4a019a7f40b8e90003c61a6d5d0a8e500012b2b00c4e3e003d83000b5004b026006d64022b04a094c81d00400202001e0077103a380017809b7f9e004b6d9e00403d92015e035a6a0621d4b00028e601008040020e1d600c50004b00e8c00919b8e0826002b50d8040445d6e80b6d7d5a0244d00b008400038b6d02d004b93a330025540032304d55cf080094d0a9fcb240006d94a00620180d0b0b034a8c024dd0062006600933d0a0271e1e03a50035d4c22f91b7b1e81010001d805f7e01e1d000044800a000a8d20006a1600e07c800013c36d006b200f33001b1e023d0180207c003d0057b49e015e09d4c0139e79e041900b9d002d0a170f008027d6c700002055be80000364aa002c0048d0d00700405d020605500065e2403004e9e01500002a60260022a9d035a6d00597c0053e0035d5e0063d009b3d00143a340e2e03c40a2c0020840326c0280e16b50132b8000160e0023f3d0b007d00650105022b076a0280805b80b54e4d9e0140223507d04b0044002d0a95b0280000d2e7d0060a980b044ba0006d0059a8a6a006c01331f028061003d0a91e01d170be008cf6d004f4b800028a28e015b005b0e5e6e0058005c007c9003e003c2a0041006c1f8e82b009d0210d0023700e004b1e0144a009d025a9e001c01e9e00b80042d1a05b8d29e00430a2d00d000043a005005bb003e93d40e1006c003d00163e20067d22e018028002a7600557e190b0040602e053206c00124a3e044e12b3800240840052b080029b0700180d4b0630e4b0041000a02b1d0578c0072300e063c0050303400408042208000264d9002a1e8006a49e00d30040f4080028030004b94f00670024d100e00707034b7a007e1e0282b5e003a00b9d6a002003d9e08c8a5b0133c030030c20001426003a5d60003e1c4a0210071001e100b400080004e800007c9e001e1d0b023d0019e0068c500390ea00303b9000d8e037e0b3c8a0c005ea004003031003d0809b8000000a3d27b0502e003d0a93a1c1706e003e02a50013a003cb4d8e4000f00252b05860022004b6d9e006a2b00b8e00391e00f2f06e40159e009d0404b0130c57b0003a0240044400283e04a43c0800210000079e025600280003b05d1d022b9e004a1e00d003f5000002a0b0062d023b6000e1e0d0b0400052b0326d002b003e0c080084003f8a9e0039001902b0038d8c004c0541c1e001f8e100062009000a580010e0024e2e0066f0003b6d004b6d00e2f43002552e001e0065004b06c08c1e0005b2d00202b00b8000f0012b02800d008e003e8002607e009a5b0e02764a0070a1e0053403800a03100240067e0b2b5e011b0a2d007024ed6d1e8c02e600092b780c9d86c004001e003e1c840040a2000e8000a21d00032e028045b700d07c025b9a02400303b00104041c35080f4103d00a003d40302400680001a4052d6c004003900d23a006c1e0656038a11a2d034ee0e00032d00175b00c6f91c000f033033a10b004a8d0022006b008c65009d0674a006a080048b0480073e05307d000b43e005d43e3a2c000b4a00300037001f2900275b804b6d0027b0002000808d00605e03d026d0702006b062d08b2a00703d0900c800041900002f004003780d0e63d000202a00e002b0c6d000c40d6a1a3b028100000f9c40330034006a04d005e6e005e7a0039000233337d0044c0068d20132a000025e0405b5e00014c8a0060f002c50a005e00262d0b80a1a0001e7cfa006c6c00300058000d2c03e05b50016004e8c034800b65b2e003000e4d81a2d003501d94e03820006001d003805d7000390e200262b8a028004b033b80002a008d00382b09e12d004b3d1a013ea4200008e2b1e0022e5004a024405e00090f2a1a10000c8d003e040084004c0027d9d0029a003e7000e05d401021d1a002a330000cc3e00b8d84b2e9e7a3002000d63e0d0e001e28d104401c0033e021022700b1b0500a88b10a7002b20002105a01808cbb05027e0b8e024d91c54000072b02800d90018e0053e002e03d0e013e6200b5d1e002600006b50a009c03b00d1c40c011c503a0039006801d99a0a37c60d2002e7a0328001e08002b085ba80a011c6d80008c0136000f530019e603b5d9e0300428e0a01c3d200002f0900e0508c0380041a1a0108a98e003d9d80e0c7a003c00c1a43d5500019c2e007005b60004080b1d8c6d0024d5e000090029b41c0068029d80502c028a00500048a3e060042a04e03e00a0100a004a01000e5e010f9e050003d800029a6a008a08b96e00550004828e0040041e2d0052e1201006c2d023003f8c026c62a02d0402b9005b3b003e028e002b08a5e8033b9d006a011dd002b0004003b00315d00380002800434a0c0136c3a0a3e00224d5e013e004a8a1a007e03d580e023e21e002d960009301a0e0b003d08a0006a03e00d5b9a08015a0006a08d0e06f90013e08002c0016001a0054d50d00154e0019e5b5a1a039e002a3a015e1e8c066b8a3e04260c005b80c4000406000b5d0c0093d1a0147a2000000980006e0d009903f0009d3d003c0180e7c063e0037001b780c00e040002003f0a130d5a0e1a005403c6e003403b00602d9000e2d7d028b3b9004e002400a2d007e04e00253e80d06040d4e3a0c01605b804c004c000091c800037b00202d0089000e083b8000e5b0000278d0092d700004601e8d029b8a00d52b030a6a006201b2b0e002d009c40053e003200bc0052e03d1d8d060022b8000a009e4a1e065bd28000c0004d00370080d5e02c6d2d006c020c03e036013b30009b016a02d00130003e009c023004e8a06000203e0c006a003f5b0064d9e007600004a00b2d0004e5b80d062b0058c0001b5e04a2028d0028d8d04000a40b16b4d00005b00022a0006a00005a380003aa012c9e009b024a00560008a9d8001e000be8a040062005a012aa2e7c00b9b300037e005ed6c0040400027e2b2e00440e022d003a26003e8c0010401c2d006c05e4a039d003c009c8a0095e002bda005d0b0600601a040005b0e009a0280e001d000a00e0d8009d19e009d1e0067b003b660b200b3a60002d062b8a04a3d8d00d7b9e003d4d060b6006e001a8d003d6b900077002b3e0057007b00220073e0b19d0e1c007e09e0489e005e0019d6d003e1d0082a01002a6001b7004b6000970054c004c013e00b5b6d037c028a2e0c0026e0035bda0032c009e0033b0e003e014e4c013a003d90024002e050e018028009c040028d5e03a8a0080e00c6d6d0022c004b6d0180006e03a5d0032a1c0029a0e004e02800a4a005003c0009b5006b002d9a9e001c0278000009a00422d007e0032d03e001a009603c00e0b8002a3800007b00d7a1e02e4e003c03210001d001e02d001e00802d0034e0379e1c002e0066d00e04a0d0e005b4b9e0029b806b006d8d003c006b8e0235a003d9e01d601c0064025e002ec0a04a03a40012d7e004ae00003d98a0100428e00192a1c0e003e1d9e04005b000067d005b048030b004400b81e1c038002b1a024c019003c006f1d0090a000ab0000038000981e0074004d3d8e00b8b00020007c4e004a017c023c0037c002e008d061c03d002b8a0068a004400d1e03d003c3d1e003b2800a002d04890003d003c60023d00f2c012a022a0b8a0400380a002000280a005e0e003a0c6d0001d0b7c005d043b4e0069a009d0276d004a8a1e003e4000e0281e017b2e0064000a6c000300d20011e008a0000401a0332e00e4a003b8a3a6b90004a23a001e0076001e003e9e0046e08d00b2a000000b800a003a023e1c006c0216004d07008000e0806e003d28d006202c0056e006a5000007c5d0e0091d8e0018e00320014d0e008005e5e006b9d003d9d5a021e044d005600080b980010a00002a003e009700068d003a02e0e0042a003e0288007c0200090200a00e007c003b008800b0003d07009e4e00c2d03a060044023e006803c006001c002b002d007e003ec6e004c00c0c00d1a00a202b5b0052009a0033d021e003ed800080006b5e002b003d028b0368c0096004a1a003b004500e06d007b9d006b020c0004d0e0250e1a1a003a0600035e5e0067b005e0e0054d000045d02c003c8c0022e002800046c00e001c003a0037c0145a009b0600d6b9e002d1a002700040019003d0098d0074d003e0040030034001e006f005e6d009f0037c006d0082b0064d9a027c03a400e08e01c0b0278a003a0c002004b11a0132d029b006c003a0280a009e001a006c0033d02b005b0150009e00602a003d3400e005b9e0062000a003e0b004d1a000b2a03a1d028c1a021e066c002d002003b8e0026004b1a02b0121e02803b5b003d034c0044008c003b18e000066003b6000639d0200c4a00a100800008a00d0b8e00b81000480e00c8004a0504d033e003d028b0280b00c1a003d9e00f29005c027e003d08000c02d0399e0001e024d9d003c0d003c2a060000e8b8a0036004a5e003b02b001a8d00809b0000e03d2003d00e9e0064d0a006a9e002000d503b0038a004004500d003e0b0036b00a00350048a03e0031004a00600e80002c050a001a000032003a12009a0000b009d024e0801e002a6d0050b90006a0e008e6c003b90a023e038d1c003a001c003400780048014d028e05c000d000d9d0300039001e2d000bc0000277b400400a003900c400e00600006c0058a0039e0060a003002d023e015e003100a0e00b0038c006a0064d1e00e0024009d0d06003c002b00570007004803000c8a000e1e0b200046001b7c003b06003b1e8c1e00d6002c0019e02006b3e0068006d1a00e2004007c0019004800269e9d027e0c4b02b0005b7c0096e028002003b046c00e0083800098c0003a4a4d0284c00b50003a00d003a0034000b9d001e0b80027e00460d00360007e022d003e8e03e02d0070028e03a8008c003b9e01b400060003d01d019b400e006c0019000902b0e0e028000e00e027803a004e012e009d003d0040a006f0136d00b4a00600a8a00a003e1e0078d040030040a1a006c02d00e0042005b0059e4d00c0e001e003c00800c8000229e024003a80000320058a02c004b80003d4a0039d01b002b003d1e0028000f7a1a005b0800c00e027e00c6004c0005000040a00e14d9e0040c2d0190039e00c4b1e0038006b00000074003b028b00a3002d9a0059e0b0028a009e003600660002d048a1a027e0089b000003d023d1a001c002b005b80003004c1a006c03c0090d0040e06a9e006f04a0002006b004c003d003400a0d00e4002c006000a000e029e004e003a500018004e0027e00b0e003e028005f003d00f0e0d003e0e9e014200a0b002a0049e008003f000ea1d0032c003f0105001d00b4e0c0006c001a02a0044c00a0a3a0d002b8d00d1a0034007e1e007a00a8a00e800c4d000e0e0038a00c400e800360028e0021d3e00260078007000340000000d0d00a000f6000660036009a003c0322001d80002d00360008d3b003d60036e5e002a0b9e00f1a0d007e0b006b03b0028a00c003b0060031a0280a004e00a028c00a0c7b9e0049e0e0034d0028a0038005d000b8002e0400700036a000a6d003b0c003e0801e000c9b003c005a0042a0027002c0036004e01e003a003c00e00009a005d007a003b800f1a003b0d0e00a028a005000a009d0a003d003800a1000b3800a0003d03e004a000018c0033002a0067004e00d0e0054008b00b8e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
{"text": "<s>[INST] How does the Vesting Validator ensure that a transaction has been signed by the specified beneficiary and that the deadline has been reached, using checks on the transaction and its parameters, and how can the validator be saved to a file or display the datum in JSON format? [/INST] {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell #-} module Vesting where import Data.Maybe (fromJust) import Plutus.V1.Ledger.Interval (contains) import Plutus.V2.Ledger.Api (BuiltinData, POSIXTime, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import Plutus.V2.Ledger.Contexts (txSignedBy) import PlutusTx (compile, unstableMakeIsData) import PlutusTx.Prelude (Bool, traceIfFalse, ($), (&&)) import Prelude (IO, String) import Utilities (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, writeValidatorToFile, wrapValidator) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data VestingDatum = VestingDatum { beneficiary :: PubKeyHash , deadline :: POSIXTime } unstableMakeIsData ''VestingDatum {-# INLINABLE mkVestingValidator #-} mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool mkVestingValidator dat () ctx = traceIfFalse "beneficiary's signature missing" signedByBeneficiary && traceIfFalse "deadline not reached" deadlineReached where info :: TxInfo info = scriptContextTxInfo ctx signedByBeneficiary :: Bool signedByBeneficiary = txSignedBy info $ beneficiary dat deadlineReached :: Bool deadlineReached = contains (from $ deadline dat) $ txInfoValidRange info {-# INLINABLE mkWrappedVestingValidator #-} mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedVestingValidator = wrapValidator mkVestingValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile "./assets/vesting.plutus" validator vestingAddressBech32 :: Network -> String vestingAddressBech32 network = validatorAddressBech32 network validator printVestingDatumJSON :: PubKeyHash -> String -> IO () printVestingDatumJSON pkh time = printDataToJSON $ VestingDatum { beneficiary = pkh , deadline = fromJust $ posixTimeFromIso8601 time } <s>"}
{"text": "<s>[inst] What is the purpose of this validator and how does it work? It looks like the validator checks whether a transaction has been signed by a particular beneficiary within a specified time range (deadline) and whether another beneficiary signed or is too early, using functions to check conditions based on transaction information and parameters. It appears that the validator can be saved to a file, and the MisteryDatum can be displayed in JSON format. What are the possible use cases for such a validator? [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell #-} {-# LANGUAGE TypeApplications #-} {-# LANGUAGE TypeFamilies #-} module Homework1 where import Data.Maybe (fromJust) import Plutus.V1.Ledger.Interval (contains, to) import Plutus.V2.Ledger.Api (BuiltinData, POSIXTime, POSIXTimeRange, PubKeyHash, ScriptContext (scriptContextTxInfo), TxInfo (txInfoValidRange), Validator, from, mkValidatorScript) import Plutus.V2.Ledger.Contexts (txSignedBy) import PlutusTx (compile, unstableMakeIsData) import PlutusTx.Prelude (Bool, traceIfFalse, ($), (&&), (+), (||)) import Prelude (IO, String) import Utilities (Network, posixTimeFromIso8601, printDataToJSON, validatorAddressBech32, wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ data MisteryDatum = MisteryDatum { beneficiary1 :: PubKeyHash , beneficiary2 :: PubKeyHash , deadline :: POSIXTime } unstableMakeIsData ''MisteryDatum {-# INLINABLE mkMisteryValidator #-} mkMisteryValidator :: MisteryDatum -> () -> ScriptContext -> Bool mkMisteryValidator dat () ctx = traceIfFalse \"Benificiary1 did not sign or to late\" checkCondition1 || traceIfFalse \"Benificiary2 did not sign or is to early\" checkCondition2 where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange = txInfoValidRange txInfo checkCondition1 :: Bool checkCondition1 = txSignedBy txInfo (beneficiary1 dat) && contains (to (deadline dat)) txValidRange checkCondition2 :: Bool checkCondition2 = txSignedBy txInfo (beneficiary2 dat) && contains (from (1 + deadline dat)) txValidRange {-# INLINABLE mkWrappedMisteryValidator #-} mkWrappedMisteryValidator :: BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedMisteryValidator = wrapValidator mkMisteryValidator validator :: Validator validator = mkValidatorScript $$(compile [|| mkWrappedMisteryValidator ||]) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: IO () saveVal = writeValidatorToFile \"./assets/mistery1.plutus\" validator misteryAddressBech32 :: Network -> String misteryAddressBech32 network = validatorAddressBech32 network validator printMisteryDatumJSON :: PubKeyHash -> PubKeyHash -> String -> IO () printMisteryDatumJSON pkh1 pkh2 time = printDataToJSON $ MisteryDatum { beneficiary1 = pkh1 , beneficiary2 = pkh2 , deadline = fromJust $ posixTimeFromIso8601 time } <s>"}
{"text": "<s>[inst] What are the benefits of having a parameterized validator, and what are some use cases for this type of validator? [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TemplateHaskell #-} module Homework2 where import Plutus.V1.Ledger.Interval (contains) import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts (txSignedBy) import PlutusTx (applyCode, compile, liftCode) import PlutusTx.Prelude (Bool (..), traceIfFalse, (&&), (.)) import Prelude (IO) import Utilities (wrapValidator, writeValidatorToFile) --------------------------------------------------------------------------------------------------- ------------------------------------------ PROMPT ------------------------------------------------- {- 1- Figure out what this (already finished) validator does using all the tools at your disposal. 2- Write the off-chain code necessary to cover all possible interactions with the validator using the off-chain tool of your choosing. HINT: If you get stuck, take a look at Week03's lecture -} --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkParameterizedMisteryValidator #-} mkParameterizedMisteryValidator :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkParameterizedMisteryValidator beneficiary deadline () ctx = traceIfFalse \"not signed by beneficiary\" checkSig && traceIfFalse \"deadline has not passed yet\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx txValidRange :: POSIXTimeRange txValidRange = txInfoValidRange txInfo checkSig :: Bool checkSig = txSignedBy txInfo beneficiary checkDeadline :: Bool checkDeadline = contains (from deadline) txValidRange {-# INLINABLE mkWrappedParameterizedMisteryValidator #-} mkWrappedParameterizedMisteryValidator :: PubKeyHash -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedParameterizedMisteryValidator = wrapValidator . mkParameterizedMisteryValidator validator :: PubKeyHash -> Validator validator beneficiary = mkValidatorScript ($$(compile [|| mkWrappedParameterizedMisteryValidator ||]) `applyCode` liftCode beneficiary) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveVal :: PubKeyHash -> IO () saveVal = writeValidatorToFile \"./assets/parameterized-Mistery.plutus\" . validator <s>"}
{"text": "<s>[inst] Write a Plutus smart contract that implements a token burning mechanism. The contract should allow token holders to submit token burning transactions. When the transactions are received, they should be verified to ensure that the sender owns the tokens and that the tokens have not been previously burned. The contract should then update the token ledger and mint a new token with an increased supply. [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TemplateHaskell #-} module Homework1 where import Plutus.V2.Ledger.Api import Plutus.V2.Ledger.Contexts import Plutus.V1.Ledger.Interval import qualified PlutusTx import PlutusTx.Prelude (Bool (..), ($), traceIfFalse, (&&)) import Utilities (wrapPolicy, writeCodeToFile, currencySymbol, writePolicyToFile) import Prelude (IO, Show (show)) import Text.Printf (printf) --------------------------------------------------------------------------------------------------- ----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------ {-# INLINABLE mkDeadlinePolicy #-} -- This policy should only allow minting (or burning) of tokens if the owner of the specified PubKeyHash -- has signed the transaction and if the specified deadline has not passed. mkDeadlinePolicy :: PubKeyHash -> POSIXTime -> () -> ScriptContext -> Bool mkDeadlinePolicy owner deadline () ctx = traceIfFalse \"not signed by owner\" checkSig && traceIfFalse \"too late: deadline has allready passed\" checkDeadline where txInfo :: TxInfo txInfo = scriptContextTxInfo ctx checkSig :: Bool checkSig = txSignedBy txInfo owner txValidRange :: POSIXTimeRange txValidRange = txInfoValidRange txInfo checkDeadline :: Bool checkDeadline = contains (to deadline) txValidRange {-# INLINABLE mkWrappedDeadlinePolicy #-} mkWrappedDeadlinePolicy :: BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> () mkWrappedDeadlinePolicy pkh deadline = wrapPolicy $ mkDeadlinePolicy pkh' deadline' where pkh' :: PubKeyHash pkh' = PlutusTx.unsafeFromBuiltinData pkh deadline' :: POSIXTime deadline' = PlutusTx.unsafeFromBuiltinData deadline deadlineCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinData -> ()) deadlineCode = $$(PlutusTx.compile [|| mkWrappedDeadlinePolicy ||]) deadlinePolicy :: PubKeyHash -> POSIXTime -> MintingPolicy deadlinePolicy pkh deadline = mkMintingPolicyScript $ deadlineCode `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData pkh) `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData deadline) --------------------------------------------------------------------------------------------------- ------------------------------------- HELPER FUNCTIONS -------------------------------------------- saveDeadlineCode :: IO () saveDeadlineCode = writeCodeToFile \"assets/deadline.plutus\" deadlineCode saveDeadlinePolicy :: PubKeyHash -> POSIXTime -> IO () saveDeadlinePolicy pkh deadline = writePolicyToFile (printf \"assets/deadline-%s.plutus\" $ show pkh) $ deadlinePolicy pkh deadline deadlineCurrencySymbol :: PubKeyHash -> POSIXTime -> CurrencySymbol deadlineCurrencySymbol pkh deadline = currencySymbol $ deadlinePolicy pkh deadline <s>"}
{"text": "<s>[inst] Implement a Plutus smart contract that allows for minting of a collection of NFTs based on a date. The contract should accept a list of UTxO references and a date, and should allow the UTxOs to be minted after the specified date. The minting should be limited to one NFT per UTxO, and each minted NFT should have a unique identifier (e.g., a random number). [/inst] {-# LANGUAGE DataKinds #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE NoImplicitPrelude #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TemplateHaskell #-} module Homework2 where import Plutus.V2.Ledger.Api import Plutus.V1.Ledger.Value (flattenValue) import Plutus.V2.Ledger.Contexts (ownCurrencySymbol) import qualified PlutusTx import PlutusTx.Builtins.Internal (emptyByteString) import PlutusTx.Prelude (Bool (..), ($), (.), (&&), (==), any, traceIfFalse) import Utilities (wrapPolicy, writeCodeToFile) import Prelude (IO) {-# INLINABLE tn #-} tn :: TokenName tn = TokenName emptyByteString {-# INLINABLE mkEmptyNFTPolicy #-} -- Minting policy for an NFT, where the minting transaction must consume the given UTxO as input -- and where the TokenName will be the empty ByteString. mkEmptyNFTPolicy :: TxOutRef -> () -> ScriptContext -> Bool mkEmptyNFTPolicy oref () ctx = traceIfFalse \"UTxO not consumed\" hasUTxO && traceIfFalse \"wrong amount minted\" checkMintedAmount where info :: TxInfo info = scriptContextTxInfo ctx hasUTxO :: Bool hasUTxO = any (\\i -> txInInfoOutRef i == oref) $ txInfoInputs info checkMintedAmount :: Bool checkMintedAmount = case flattenValue (txInfoMint info) of [(cs, tn', amt)] -> cs == ownCurrencySymbol ctx && tn' == tn && amt == 1 _ -> False {-# INLINABLE mkWrappedEmptyNFTPolicy #-} mkWrappedEmptyNFTPolicy :: TxOutRef -> BuiltinData -> BuiltinData -> () mkWrappedEmptyNFTPolicy = wrapPolicy . mkEmptyNFTPolicy nftCode :: PlutusTx.CompiledCode (TxOutRef -> BuiltinData -> BuiltinData -> ()) nftCode = $$(PlutusTx.compile [|| mkWrappedEmptyNFTPolicy ||]) nftPolicy :: TxOutRef -> MintingPolicy nftPolicy oref = mkMintingPolicyScript $ $$(PlutusTx.compile [|| mkWrappedEmptyNFTPolicy ||]) `PlutusTx.applyCode` PlutusTx.liftCode oref --------------------------------------------------------------------------------- --------------------------------- HELPER FUNCTIONS ------------------------------ saveNFTCode :: IO () saveNFTCode = writeCodeToFile \"assets/nftPolicyH2_typed.plutus\" nftCode <s>"}
{"text": "What is the purpose of the Params type in the Lucid code snippet? What is it used for and why is it necessary?" [/inst]"
"import {
    Lucid,
    Blockfrost,
    Address,
    MintingPolicy,
    PolicyId,
    Unit,
    fromText,
    Data,
    getAddressDetails,
    applyParamsToScript
} from "https://deno.land/x/lucid@0.9.1/mod.ts"
import { blockfrostKey, secretSeed } from "./secret.ts"

function readAmount(): bigint {
    const input = prompt("amount: ");
    return input ? BigInt(Number.parseInt(input)) : 1000000n;
}

// set blockfrost endpoint
const lucid = await Lucid.new(
    new Blockfrost(
        "https://cardano-preview.blockfrost.io/api/v0",
        blockfrostKey
    ),
    "Preview"
);

// load local stored seed as a wallet into lucid
lucid.selectWalletFromSeed(secretSeed);
const addr: Address = await lucid.wallet.address();
console.log("own address: " + addr);

const pkh: string = getAddressDetails(addr).paymentCredential?.hash || "";
console.log("own pubkey hash: " + pkh);

const deadlineDate: Date = new Date("2023-12-21T00:00:00Z")
const deadlinePosix = BigInt(deadlineDate.getTime());

const Params = Data.Tuple([Data.String, Data.BigInt]);
type Params = Data.Static<typeof Params>;
const signedPolicy: MintingPolicy = {
    type: "PlutusV2",
    script: applyParamsToScript<Params>(
        "590af9590af60100003232323322323233223232323232323233223233223232323232323232333222323232322222323253353232323232533553353235001222222222222533533355301912001321233001225335002210031001002502b25335333573466e3c04c0040e80e44d40b4004540b0010840e840e1400440b04cd5ce2481136e6f74207369676e6564206279206f776e65720002b15335323232350022235002223500522350022253335333501900b00600215335001153350051333501800b00300710361333501800b00300710361333501800b003007355003222222222222005335014335016502802d3350153502900502d123333333300122333573466e1c0080040bc0b8894cd4ccd5cd19b8700200102f02e101515335333573466e240080040bc0b8404c405088ccd5cd19b8800200102f02e22333573466e240080040bc0b888ccd5cd19b8900200102e02f22333573466e200080040b80bc894cd4ccd5cd19b8900200102f02e10011002225335333573466e240080040bc0b84008400440b04cd5ce24926746f6f206c6174653a20646561646c696e652068617320616c6c7265616479207061737365640002b102b135001220023333573466e1cd55cea802a4000466442466002006004646464646464646464646464646666ae68cdc39aab9d500c480008cccccccccccc88888888888848cccccccccccc00403403002c02802402001c01801401000c008cd408c090d5d0a80619a8118121aba1500b33502302535742a014666aa04eeb94098d5d0a804999aa813bae502635742a01066a0460606ae85401cccd5409c0c5d69aba150063232323333573466e1cd55cea80124000466a0486464646666ae68cdc39aab9d5002480008cd40a8cd40edd69aba15002303e357426ae8940088c98c8100cd5ce02182101f09aab9e5001137540026ae854008c8c8c8cccd5cd19b8735573aa0049000119a81499a81dbad35742a004607c6ae84d5d1280111931902019ab9c04304203e135573ca00226ea8004d5d09aba2500223263203c33573807e07c07426aae7940044dd50009aba1500533502375c6ae854010ccd5409c0b48004d5d0a801999aa813bae200135742a004605e6ae84d5d1280111931901c19ab9c03b03a036135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d5d1280089aba25001135744a00226ae8940044d55cf280089baa00135742a00a603e6ae84d5d1280291931901519ab9c02d02c0283333573466e1cd55ce9baa0064800080ac8c98c80a4cd5ce0160158139bad006375c00c2050264c6404c66ae712410350543500028135573ca00226ea8004c8004d5408c88448894cd40044d400c88004884ccd401488008c010008ccd54c01c480040140100044888d400888d400c894ccd4ccd402001c01000854cd400c40044098409440984888c8c8c8c94ccd4018854ccd4018854ccd402084c011261300349854ccd401c84c01126130034984034402c54ccd401c84c011261300349854ccd401884c0112613003498403054ccd401484028402c402454ccd4014854ccd401c84c015261300449854ccd401884c01526130044984030402854ccd401884c015261300449854ccd401484c0152613004498402c94ccd4014854ccd401c854ccd401c84ccd402c028008004585858402c54ccd4018854ccd401884ccd40280240080045858584028402494ccd4010854ccd4018854ccd401884ccd4028024008004585858402854ccd4014854ccd401484ccd40240200080045858584024402094ccd400c854ccd4014854ccd401484ccd4024020008004585858402454ccd4010854ccd401084ccd402001c0080045858584020401c94ccd4008854ccd4010854ccd401084ccd402001c008004585858402054ccd400c854ccd400c84ccd401c018008004585858401c401848d40048888888801c488800c4888008488800448848cc00400c00848848cc00400c00848848cc00400c00848c88c008dd6000990009aa80d111999aab9f0012500a233500930043574200460066ae880080688c8c8cccd5cd19b8735573aa004900011991091980080180118071aba150023005357426ae8940088c98c8060cd5ce00d80d00b09aab9e5001137540024646464646666ae68cdc39aab9d5004480008cccc888848cccc00401401000c008c8c8c8cccd5cd19b8735573aa0049000119910919800801801180b9aba1500233500f016357426ae8940088c98c8074cd5ce01000f80d89aab9e5001137540026ae854010ccd54021d728039aba150033232323333573466e1d4005200423212223002004357426aae79400c8cccd5cd19b875002480088c84888c004010dd71aba135573ca00846666ae68cdc3a801a400042444006464c6403e66ae7008808407407006c4d55cea80089baa00135742a00466a016eb8d5d09aba2500223263201933573803803602e26ae8940044d5d1280089aab9e500113754002266aa002eb9d6889119118011bab00132001355017223233335573e0044a010466a00e66442466002006004600c6aae754008c014d55cf280118021aba200301813574200222440042442446600200800624464646666ae68cdc3a800a400046a00e600a6ae84d55cf280191999ab9a3370ea00490011280391931900a19ab9c017016012011135573aa00226ea800448488c00800c44880048c8c8cccd5cd19b875001480188c848888c010014c01cd5d09aab9e500323333573466e1d400920042321222230020053009357426aae7940108cccd5cd19b875003480088c848888c004014c01cd5d09aab9e500523333573466e1d40112000232122223003005375c6ae84d55cf280311931900919ab9c01501401000f00e00d135573aa00226ea80048c8c8cccd5cd19b8735573aa004900011991091980080180118029aba15002375a6ae84d5d1280111931900719ab9c01101000c135573ca00226ea80048c8cccd5cd19b8735573aa002900011bae357426aae7940088c98c8030cd5ce00780700509baa001232323232323333573466e1d4005200c21222222200323333573466e1d4009200a21222222200423333573466e1d400d2008233221222222233001009008375c6ae854014dd69aba135744a00a46666ae68cdc3a8022400c4664424444444660040120106eb8d5d0a8039bae357426ae89401c8cccd5cd19b875005480108cc8848888888cc018024020c030d5d0a8049bae357426ae8940248cccd5cd19b875006480088c848888888c01c020c034d5d09aab9e500b23333573466e1d401d2000232122222223005008300e357426aae7940308c98c8054cd5ce00c00b80980900880800780700689aab9d5004135573ca00626aae7940084d55cf280089baa0012323232323333573466e1d400520022333222122333001005004003375a6ae854010dd69aba15003375a6ae84d5d1280191999ab9a3370ea0049000119091180100198041aba135573ca00c464c6401c66ae7004404003002c4d55cea80189aba25001135573ca00226ea80048c8c8cccd5cd19b875001480088c8488c00400cdd71aba135573ca00646666ae68cdc3a8012400046424460040066eb8d5d09aab9e500423263200b33573801c01a01201026aae7540044dd500089119191999ab9a3370ea00290021091100091999ab9a3370ea004900111a80418031aba135573ca00846666ae68cdc3a801a40004a010464c6401866ae7003c0380280240204d55cea80089baa0011212223003004112220022323333573466e1d40052002200623333573466e1d40092000200623263200633573801201000800626aae74dd5000a4c244004244002240029210350543100112323001001223300330020020011",
        [pkh, deadlinePosix],
        Params)
};

const policyId: PolicyId = lucid.utils.mintingPolicyToId(signedPolicy);
console.log("minting policy: " + policyId);

const unit: Unit = policyId + fromText("PPP signed and time checked");
const amount: bigint = readAmount();

const tx = await lucid
    .newTx()
    .mintAssets({[unit]: amount}, Data.void())
    .attachMintingPolicy(signedPolicy)
    .addSignerKey(pkh)
    .validTo(Date.now()+60000) // adding 1 minute 
    .complete();

const signedTx = await tx.sign().complete();
const txHash = await signedTx.submit();
console.log("tid: " + txHash);}}"
